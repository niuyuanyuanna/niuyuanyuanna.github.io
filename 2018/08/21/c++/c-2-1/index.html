<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="类成员变量"><meta name="keywords" content="C++,北大课程"><meta name="author" content="NYY,undefined"><meta name="copyright" content="NYY"><title>类成员变量 | NYY's blog</title><link rel="shortcut icon" href="/img/my_icon.jpg"><link rel="stylesheet" href="/css/index.css?version=1.5.6"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css?version=1.5.6"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#静态成员变量"><span class="toc-number">1.</span> <span class="toc-text">静态成员变量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#静态成员和普通成员区别"><span class="toc-number">1.1.</span> <span class="toc-text">静态成员和普通成员区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#成员对象和封闭类"><span class="toc-number">2.</span> <span class="toc-text">成员对象和封闭类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#封闭类构造函数"><span class="toc-number">2.1.</span> <span class="toc-text">封闭类构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#构造函数调用顺序"><span class="toc-number">2.1.1.</span> <span class="toc-text">构造函数调用顺序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#测验"><span class="toc-number">3.</span> <span class="toc-text">测验</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.jpg"></div><div class="author-info__name text-center">NYY</div><div class="author-info__description text-center"></div><div class="follow-button"><a href="https://github.com/niuyuanyuanna" target="_blank">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">24</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">18</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">5</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://www.ouyangsong.com" target="_blank">欧阳松的博客</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://i.loli.net/2018/04/06/5ac70d2defba5.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">NYY's blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">类成员变量</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-08-21</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Programming-Language/">Programming Language</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2018/08/21/c++/c-2-1/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2018/08/21/c++/c-2-1/"></span></a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">1,586</span><span class="post-meta__separator">|</span><span>Reading time: 6 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h1><p>静态成员：在说明前面加了static关键字的成员。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CRectangle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line"> 		<span class="keyword">int</span> w, h;</span><br><span class="line"> 		<span class="keyword">static</span> <span class="keyword">int</span> nTotalArea; <span class="comment">//静态成员变量</span></span><br><span class="line"> 		<span class="keyword">static</span> <span class="keyword">int</span> nTotalNumber;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line"> 		CRectangle(<span class="keyword">int</span> w_,<span class="keyword">int</span> h_);</span><br><span class="line">		~CRectangle();</span><br><span class="line"> 		<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintTotal</span><span class="params">()</span></span>; <span class="comment">//静态成员函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="静态成员和普通成员区别"><a href="#静态成员和普通成员区别" class="headerlink" title="静态成员和普通成员区别"></a>静态成员和普通成员区别</h2><ul>
<li>普通成员变量每个对象有各自的一份</li>
<li>静态成员变量一共就一份，为所有对象共享</li>
<li>静态成员不需要通过对象就可以访问</li>
</ul>
<p>当使用sizeof运算时，不会计算静态成员变量的size，如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyclass</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">sizeof</span>(CMclass);    <span class="comment">// 等于4，不计算静态成员变量的值</span></span><br></pre></td></tr></table></figure>
<ul>
<li>普通成员函数必须具体作用于某个对象</li>
<li>静态成员函数并不具体作用于某个对象</li>
</ul>
<p>静态成员变量本质上是全局变量，哪怕一个对象都不存在，类的静态成员变量也存在。相同，静态成员函数本质上是全局函数。设置静态成员这种机制的目的是将和某些类紧密相关的全局变量和函数写到类里面，看上去像一个整体，易于维护和理解。</p>
<p>例：</p>
<p>考虑一个需要随时知道矩形总数和总面积的图形处理程序，可以用全局变量来记录总数和总面积，但此时的弊端就是无法直观看出两个全局变量跟矩形类之间的关系，且其他类的全局函数也可以访问这个变量，不安全。</p>
<p>因此，用静态成员将这两个变量封装进类中，更容易<br>理解和维护。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CRectangle</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="keyword">int</span> w, h;</span><br><span class="line">    	<span class="keyword">static</span> <span class="keyword">int</span> nTotalArea;</span><br><span class="line">    	<span class="keyword">static</span> <span class="keyword">int</span> nTotalNumber;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	CRectangle(<span class="keyword">int</span> w_, <span class="keyword">int</span> h_);</span><br><span class="line">    	~CRectangle();</span><br><span class="line">    	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintTotal</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CRectangle::CRectangle(<span class="keyword">int</span> w_, <span class="keyword">int</span> h_)&#123;</span><br><span class="line">    w = w_;</span><br><span class="line">    h = h_;</span><br><span class="line">    nTotalNumber++;</span><br><span class="line">    nTotalArea += w * h;</span><br><span class="line">&#125;</span><br><span class="line">CRectangle::~CRectangle()&#123;</span><br><span class="line">    nTotalNumber--;</span><br><span class="line">    nTotalArea -= w * h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> CRectangle::PrintTotal()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;nTotalNumber&lt;&lt;<span class="string">","</span>&lt;&lt;nTotalArea&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用的时候，必须在定义类的文件中对静态成员变量进行声明或初始化，否则编译通过但链接不通过。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> CRectangle::nTotalNumber = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> CRectangle::nTotalArea = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CRectangle r1(3, 3), r2(2, 2);</span><br><span class="line">    <span class="comment">// cout&lt;&lt;CRectangle::nTotalNumber;</span></span><br><span class="line">    CRectangle::PrintTotal();</span><br><span class="line">    r1.PrintTotal();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三行代码在外部直接访问类的私有变量，无法通过编译。</p>
<ul>
<li>在静态成员函数中，不能访问非静态成员变量，也不能调用非静态成员函数<br>如果在<code>PrintTotal()</code>静态成员函数中<code>cout&lt;&lt;w&lt;&lt;endle</code>时编译错误 </li>
</ul>
<p>其输出为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>,<span class="number">13</span></span><br><span class="line"><span class="number">2</span>,<span class="number">13</span></span><br><span class="line"><span class="number">1</span>,<span class="number">9</span></span><br><span class="line"><span class="number">0</span>,<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>上面的CRectangle类写法有很大的缺陷，即忽略了复制构造函数，因为在使用CRectangle类时，有时会调用复制构造函数，生成临时的隐藏CRectangle对象，有两种情况：</p>
<ul>
<li>调用一个以CRectangle类对象作为参数的函数时</li>
<li>调用一个以CRectangle类对象作为返回值的函数时</li>
</ul>
<p>临时对象在消亡时会调用析构函数，减少nTotalNumber 和nTotalArea的值，可是这些临时对象在生成时却没有增加nTotalNumber 和 nTotalArea的值。</p>
<p>解决办法：为CRectangle类写一个复制构造函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CRectangle::CRectangle(CRectangle &amp; r )&#123;</span><br><span class="line">    w = r.w; </span><br><span class="line">    h = r.h;</span><br><span class="line">    nTotalNumber ++;</span><br><span class="line">    nTotalArea += w * h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="成员对象和封闭类"><a href="#成员对象和封闭类" class="headerlink" title="成员对象和封闭类"></a>成员对象和封闭类</h1><p>成员对象：一个类的成员变量是另一个类的对象</p>
<p>封闭类（Enclosing）：包含成员对象的类</p>
<p>如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTyre</span>&#123;</span>                  <span class="comment">// 轮胎类</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="keyword">int</span> radius;</span><br><span class="line">    	<span class="keyword">int</span> width;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	CTyre(<span class="keyword">int</span> r, <span class="keyword">int</span> w):radius(r), width(w)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CEngine</span>&#123;</span>                <span class="comment">// 引擎类</span></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCar</span>&#123;</span>                  <span class="comment">// 封闭类</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="keyword">int</span> price;</span><br><span class="line">    	CTyre tyre;          <span class="comment">// 成员对象轮胎</span></span><br><span class="line">    	CEngine engine;      <span class="comment">// 成员对象引擎</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	CCar(<span class="keyword">int</span> p, <span class="keyword">int</span> tr, <span class="keyword">int</span> tw);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 初始化列表，初始化tyre</span></span><br><span class="line">CCar::CCar(<span class="keyword">int</span> p, <span class="keyword">int</span> tr, <span class="keyword">int</span> tw):price(p), tyre(tr, tw)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">CCar <span class="title">car</span><span class="params">(<span class="number">20000</span>, <span class="number">17</span>, <span class="number">225</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>CTyre</code>类中，编写构造函数时，使用初始化列表的方式对<code>radius</code>和<code>width</code>进行初始化。使用这样的方式的好处是进行复制的风格更好。</p>
<p>如果CCar类不定义构造函数，则在执行<code>CCar car</code>时会编译错误，因为编译器不知道<code>car.tyre</code>该如何初始化，但<code>car.engine</code>的初始化没有问题。</p>
<h2 id="封闭类构造函数"><a href="#封闭类构造函数" class="headerlink" title="封闭类构造函数"></a>封闭类构造函数</h2><p>定义封闭类的构造函数时，添加初始化列表的方法为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">类名::构造函数(参数表):成员变量1(参数表),成员变量2(参数表),...&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>成员对象初始化列表中的参数可以是任意复杂的表达式，也可以使函数、变量、表达式中的函数</p>
<h3 id="构造函数调用顺序"><a href="#构造函数调用顺序" class="headerlink" title="构造函数调用顺序"></a>构造函数调用顺序</h3><p>当封闭类对象生成的时候，类的构造函数的调用顺序为：</p>
<ol>
<li>执行所有成员对象的构造函数</li>
<li>执行封闭类的构造函数</li>
</ol>
<p>成员对象的构造函数调用顺序和成员对象在封闭类中的声明顺序一致，和在成员初始化列表中的出现顺序无关。</p>
<p>当封闭类对象消亡时，类的析构函数调用顺序为：</p>
<ol>
<li>执行封闭类的析构函数</li>
<li>执行成员对象的析构函数</li>
</ol>
<p>构造函数和析构函数的调用顺序刚好相反。</p>
<p>例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTyre</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	CTyre() &#123; </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"CTyre constructor"</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">        &#125;</span><br><span class="line"> 		~CTyre() &#123; </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"CTyre destructor"</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CEngine</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		CEngine() &#123; </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"CEngine constructor"</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">        &#125;</span><br><span class="line">		~CEngine() &#123; </span><br><span class="line">        	<span class="built_in">cout</span> &lt;&lt; <span class="string">"CEngine destructor"</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCar</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	CEngine engine;</span><br><span class="line">    	CTyre tyre;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	CCar()&#123;</span><br><span class="line">        	<span class="built_in">cout</span> &lt;&lt; <span class="string">"CCar constructor"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	~CCar()&#123;</span><br><span class="line">        	<span class="built_in">cout</span> &lt;&lt; <span class="string">"CCar destructor"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CCar car;</span><br><span class="line">    reurn <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先执行成员对象的构造函数，根据声明的顺序，分别调用<code>CEngine</code>和<code>CTyre</code>的构造函数，最后执行封闭类<code>CCar</code>封闭类自身的构造函数。析构函数的调用顺序与构造函数调用顺序相反，因此输出为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CEngine constructor</span><br><span class="line">CTyre constructor</span><br><span class="line">CCar constructor</span><br><span class="line">CCar destructor</span><br><span class="line">CTyre destructor</span><br><span class="line">CEngine destructor</span><br></pre></td></tr></table></figure>
<h1 id="测验"><a href="#测验" class="headerlink" title="测验"></a>测验</h1><ol>
<li>如果某函数的返回值是个对象，则该函数被调用时，返回的对象</li>
</ol>
<ul>
<li style="list-style: none"><input type="checkbox" checked> 是通过复制构造函数初始化的</li>
<li style="list-style: none"><input type="checkbox"> 不需要初始化</li>
<li style="list-style: none"><input type="checkbox"> 是通过无参数的构造函数初始化的</li>
<li style="list-style: none"><input type="checkbox"> 用哪个构造函数初始化取决于函数中 return 语句是怎么写的</li>
</ul>
<ol start="2">
<li>以下说法正确的是：</li>
</ol>
<ul>
<li style="list-style: none"><input type="checkbox"> const成员函数不能作用于非 const 对象</li>
<li style="list-style: none"><input type="checkbox"> 静态成员变量每个对象有各自的一份</li>
<li style="list-style: none"><input type="checkbox" checked> 在静态成员函数中不能使用 this 指针</li>
<li style="list-style: none"><input type="checkbox"> 在静态成员函数中可以调用同类的其他任何成员函数const成员函数不能作用于非 const 对象</li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">NYY</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2018/08/21/c++/c-2-1/">http://yoursite.com/2018/08/21/c++/c-2-1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a><a class="post-meta__tags" href="/tags/北大课程/">北大课程</a></div><div class="social-share"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2018/08/22/c++/c-2-2/"><i class="fa fa-chevron-left">  </i><span>友元、this指针、常量</span></a></div><div class="next-post pull-right"><a href="/2018/08/06/c++/c-1-2/"><span>c++类和函数</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'http://yoursite.com/2018/08/21/c++/c-2-1/';
  this.page.identifier = '2018/08/21/c++/c-2-1/';
  this.page.title = '类成员变量';
}
var d = document, s = d.createElement('script');
s.src = "https://" + 'niuyuanyuan' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-src" src="https://niuyuanyuan.disqus.com/count.js" async></script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 By NYY</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.6"></script><script src="/js/fancybox.js?version=1.5.6"></script><script src="/js/sidebar.js?version=1.5.6"></script><script src="/js/copy.js?version=1.5.6"></script><script src="/js/fireworks.js?version=1.5.6"></script><script src="/js/transition.js?version=1.5.6"></script><script src="/js/scroll.js?version=1.5.6"></script><script src="/js/head.js?version=1.5.6"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>