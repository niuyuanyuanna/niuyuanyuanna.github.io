<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="c++类和函数"><meta name="keywords" content="C++,北大课程"><meta name="author" content="NYY,undefined"><meta name="copyright" content="NYY"><title>c++类和函数 | NYY's blog</title><link rel="shortcut icon" href="/img/my_icon.jpg"><link rel="stylesheet" href="/css/index.css?version=1.5.6"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css?version=1.5.6"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#内联函数、重载函数"><span class="toc-number">1.</span> <span class="toc-text">内联函数、重载函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#内联函数"><span class="toc-number">1.1.</span> <span class="toc-text">内联函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#内联成员函数"><span class="toc-number">1.1.1.</span> <span class="toc-text">内联成员函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数重载"><span class="toc-number">1.2.</span> <span class="toc-text">函数重载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#成员函数的重载"><span class="toc-number">1.2.1.</span> <span class="toc-text">成员函数的重载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数缺省"><span class="toc-number">1.3.</span> <span class="toc-text">函数缺省</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#成员函数缺省"><span class="toc-number">1.3.1.</span> <span class="toc-text">成员函数缺省</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#程序设计方法"><span class="toc-number">2.</span> <span class="toc-text">程序设计方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#类基础"><span class="toc-number">2.1.</span> <span class="toc-text">类基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#访问类成员变量"><span class="toc-number">2.1.1.</span> <span class="toc-text">访问类成员变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类的成员函数"><span class="toc-number">2.1.2.</span> <span class="toc-text">类的成员函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#类的构造函数"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">类的构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#构造函数作用"><span class="toc-number">2.1.2.1.1.</span> <span class="toc-text">构造函数作用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#构造函数在数组中的使用"><span class="toc-number">2.1.2.1.2.</span> <span class="toc-text">构造函数在数组中的使用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#复制构造函数"><span class="toc-number">2.1.2.2.</span> <span class="toc-text">复制构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#作用"><span class="toc-number">2.1.2.2.1.</span> <span class="toc-text">作用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#类型转换构造函数"><span class="toc-number">2.1.2.3.</span> <span class="toc-text">类型转换构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#析构函数"><span class="toc-number">2.1.2.4.</span> <span class="toc-text">析构函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#析构函数和数组"><span class="toc-number">2.1.2.4.1.</span> <span class="toc-text">析构函数和数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#delete运算符"><span class="toc-number">2.1.2.4.2.</span> <span class="toc-text">delete运算符</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#构造函数和析构函数调用例子"><span class="toc-number">2.1.2.5.</span> <span class="toc-text">构造函数和析构函数调用例子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类成员的访问权限"><span class="toc-number">2.1.3.</span> <span class="toc-text">类成员的访问权限</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第一周作业"><span class="toc-number">3.</span> <span class="toc-text">第一周作业</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#测验"><span class="toc-number">3.1.</span> <span class="toc-text">测验</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#编程"><span class="toc-number">3.2.</span> <span class="toc-text">编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#描述"><span class="toc-number">3.2.1.</span> <span class="toc-text">描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#输入"><span class="toc-number">3.2.2.</span> <span class="toc-text">输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#输出"><span class="toc-number">3.2.3.</span> <span class="toc-text">输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#样例"><span class="toc-number">3.2.4.</span> <span class="toc-text">样例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#答案"><span class="toc-number">3.2.5.</span> <span class="toc-text">答案</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.jpg"></div><div class="author-info__name text-center">NYY</div><div class="author-info__description text-center"></div><div class="follow-button"><a href="https://github.com/niuyuanyuanna" target="_blank">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">41</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">32</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">8</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://www.ouyangsong.com" target="_blank">欧阳松的博客</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://i.loli.net/2018/04/06/5ac70d2defba5.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">NYY's blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">c++类和函数</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-08-06</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Programming-Language/">Programming Language</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2018/08/06/c++/c-1-2/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2018/08/06/c++/c-1-2/"></span></a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">4,618</span><span class="post-meta__separator">|</span><span>Reading time: 18 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="内联函数、重载函数"><a href="#内联函数、重载函数" class="headerlink" title="内联函数、重载函数"></a>内联函数、重载函数</h1><p>在调用一个函数的时候，需要首先要把参数放到栈中， 返回地址也要放到栈中。 这个函数执行完返回以后，要从栈中取出返回地址，再跳转到返回地址去执行。 </p>
<h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><ul>
<li>函数调用是有时间开销的。如果函数本身只有几条语句，执行非常快，而且函数被反复执行很多次，相比之下调用函数所产生的这个开销就会显得比较大。</li>
<li>为了减少函数调用的开销，引入了内联函数机制。编译器处理对内联函数的调用语句时，将整个函数的代码插入到调用语句处，而不会产生调用函数的语句。</li>
</ul>
<p>定义内联函数时，在定义前面加上<code>inline</code>关键字。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &gt; b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="内联成员函数"><a href="#内联成员函数" class="headerlink" title="内联成员函数"></a>内联成员函数</h3><p>其定义方式可以为：</p>
<ul>
<li><code>inline</code>+成员函数</li>
<li>在类定义内部定义整个函数体</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>;   <span class="comment">// 第一种方式</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;&#125;;        <span class="comment">// 第二种方式</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> B::func1()&#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>一个或多个函数，名字相同，参数个数或参数类型相同，叫做函数的重载。<br>如下面函数为重载函数：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">double</span> f1, <span class="keyword">double</span> f2)</span></span>&#123;&#125;</span><br><span class="line">Max(<span class="number">3.4</span>, <span class="number">2.5</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> n1, <span class="keyword">int</span> n2)</span></span>&#123;&#125;</span><br><span class="line">Max(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> n1, <span class="keyword">int</span> n2, <span class="keyword">int</span> n3)</span></span>&#123;&#125;</span><br><span class="line">Max(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">Max(<span class="number">3</span>, <span class="number">2.4</span>)       <span class="comment">// 编译错误（二义性）</span></span><br></pre></td></tr></table></figure></p>
<p>其优点是：</p>
<ul>
<li>简化函数命名规则</li>
<li>编译器只需要根据语句中的实参个数和类型判断应调用的函数</li>
</ul>
<h3 id="成员函数的重载"><a href="#成员函数的重载" class="headerlink" title="成员函数的重载"></a>成员函数的重载</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Location</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">int</span> y = <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">valueX</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">            x = val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">valueX</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>valueX()</code>为成员函数重载，使用时仍然可以参数缺省。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> Location::init(<span class="keyword">int</span> X, <span class="keyword">int</span> Y)&#123;</span><br><span class="line">    x = X;</span><br><span class="line">    y = Y</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> main()&#123;</span><br><span class="line">    Location A;</span><br><span class="line">    A.init(<span class="number">3</span>);    <span class="comment">// 将x的值初始化为3，y缺省为0</span></span><br><span class="line">    A.valueX(<span class="number">5</span>);  <span class="comment">// 调用赋值接口，将x的值变为5</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;A.valueX();  <span class="comment">// 调用get接口获取x的值，输出5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数缺省"><a href="#函数缺省" class="headerlink" title="函数缺省"></a>函数缺省</h2><p>C++中，定义函数时，可以让<strong>最右边的连续若干个参数</strong>有缺省值，调用函数时，若相应位置不写参数，参数就是缺省值。 如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> x2 = <span class="number">2</span>, <span class="keyword">int</span> x3 = <span class="number">3</span>)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">func(<span class="number">10</span>);                   <span class="comment">// 等效于func(10, 2, 3)</span></span><br><span class="line">func(<span class="number">10</span>, <span class="number">8</span>);                <span class="comment">// 等效于func(10, 8, 3)</span></span><br><span class="line">func(<span class="number">10</span>, , <span class="number">8</span>);              <span class="comment">// 编译错误，缺省参数只能是在最右边的连续参数</span></span><br></pre></td></tr></table></figure>
<p>其优点为：</p>
<ul>
<li>函数参数可缺省的目的在于提高程序的可扩充性。</li>
<li>如果某个写好的函数要添加新的参数，而原先那些调用该函数的语句，未必需要使用新增的参数，为了避免对原先那些函数调用语句的修改，就可以使用缺省参数。</li>
</ul>
<h3 id="成员函数缺省"><a href="#成员函数缺省" class="headerlink" title="成员函数缺省"></a>成员函数缺省</h3><p>使用缺省参数时，需要避免函数重载时的二义性。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Location</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">int</span> y = <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">valueX</span><span class="params">(<span class="keyword">int</span> val = <span class="number">0</span>)</span></span>&#123;</span><br><span class="line">            x = val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">valueX</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用时：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Location A;</span><br><span class="line">    A.valueX();    <span class="comment">// 此时会编译错误，报错为产生二义性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="程序设计方法"><a href="#程序设计方法" class="headerlink" title="程序设计方法"></a>程序设计方法</h1><h2 id="类基础"><a href="#类基础" class="headerlink" title="类基础"></a>类基础</h2><p>类定义变量的过程为实例化。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CRectangle</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> w, h;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> w_, <span class="keyword">int</span> h_)</span></span>&#123;</span><br><span class="line">            w = w_;</span><br><span class="line">            h = h_;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">area</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> w * h;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">perimeter</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span> * (w + h);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;               <span class="comment">// ;必须有</span></span><br></pre></td></tr></table></figure></p>
<p>对象之间可以用 ‘=’ 进行赋值 ，不能用 ‘==’, ‘!=’, ‘&gt;’, ‘&lt;’, ‘&gt;=’, ‘&lt;=’进行比较 ，除非运算符进行重载</p>
<h3 id="访问类成员变量"><a href="#访问类成员变量" class="headerlink" title="访问类成员变量"></a>访问类成员变量</h3><ol>
<li>对象名.成员名</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CRectangle r1, r2;</span><br><span class="line">r1.w = <span class="number">5</span>;            <span class="comment">// 每个对象有各自的存储空间</span></span><br><span class="line">r2.init(<span class="number">3</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>指针-&gt;成员名</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CRectangle r1, r2;</span><br><span class="line">CRectangle *p1 = &amp; r1;</span><br><span class="line">CRectangle *p2 = &amp; r2;</span><br><span class="line">p1-&gt;w = <span class="number">5</span>;</span><br><span class="line">p2-&gt;inti(<span class="number">3</span>, <span class="number">4</span>);    <span class="comment">// init作用在p2指向的对象上</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>引用名.成员名</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CRectangle r2;</span><br><span class="line">CRectangle &amp; rr = r2;</span><br><span class="line">rr.w = <span class="number">5</span>;</span><br><span class="line">rr.init(<span class="number">3</span>, <span class="number">4</span>)     <span class="comment">// /rr的值变了，r2的值也变</span></span><br></pre></td></tr></table></figure>
<h3 id="类的成员函数"><a href="#类的成员函数" class="headerlink" title="类的成员函数"></a>类的成员函数</h3><p>成员函数体和类的定义可以分开写：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CRectangle</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> w, t;</span><br><span class="line">        <span class="comment">// 成员函数在这里声明</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">area</span><span class="params">()</span></span>; </span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">perimeter</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> w_, <span class="keyword">int</span> h_)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义可以在类外</span></span><br><span class="line"><span class="keyword">int</span> CRectangle::area()&#123;</span><br><span class="line">    <span class="keyword">return</span> w * h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> CRectangle::perimeter()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * (w + h);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> CRectangle::init(<span class="keyword">int</span> w_, <span class="keyword">int</span> h_)&#123;</span><br><span class="line">    w = w_;</span><br><span class="line">    h = h_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="类的构造函数"><a href="#类的构造函数" class="headerlink" title="类的构造函数"></a>类的构造函数</h4><p>类的构造函数是成员函数的一种，但需要遵循特殊的规律：</p>
<ul>
<li>名字与类名相同，可以有参数，不能有返回值（void也不行）</li>
<li>其作用是初始化对象，比如给成员变量赋初始值<ul>
<li>对象生成时自动调用构造函数，对象一旦生成，就无法再执行构造函数</li>
<li>一个类可以有多个构造函数</li>
</ul>
</li>
<li>如果定义类时未写构造函数，编译器自动生成一个无参数的构造函数，不做任何操作；</li>
<li>如果定义类时定义了构造函数，编译器不生成无参数构造函数</li>
</ul>
<h5 id="构造函数作用"><a href="#构造函数作用" class="headerlink" title="构造函数作用"></a>构造函数作用</h5><ol>
<li>执行必要的初始化工作 </li>
<li>有时对象没被初始化就使用，会导致程序出错 </li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	doubel real, imag;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="keyword">void</span> <span class="title">Set</span><span class="params">(<span class="keyword">double</span> r, <span class="keyword">double</span> i)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 编译器自动生成默认构造函数 </span></span><br><span class="line"></span><br><span class="line">Complex c1;                  <span class="comment">// 默认构造函数被调用 </span></span><br><span class="line">Complex *pc = <span class="keyword">new</span> Complex;   <span class="comment">// 默认构造函数被调用</span></span><br></pre></td></tr></table></figure>
<p>编写构造函数时：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">double</span> real, imag;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Complex(<span class="keyword">double</span> r, <span class="keyword">double</span> i = <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Complex::Complex(<span class="keyword">double</span> r, <span class="keyword">double</span> i)&#123;</span><br><span class="line">    real = r;</span><br><span class="line">    imag = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Complex c1;                 <span class="comment">// error, 缺少构造函数的参数 </span></span><br><span class="line">Complex *pc = <span class="keyword">new</span> Complex;  <span class="comment">// error, 缺少构造函数的参数 </span></span><br><span class="line"></span><br><span class="line"><span class="function">Complex <span class="title">c2</span><span class="params">(<span class="number">2</span>)</span></span>;              <span class="comment">// 构造函数重载</span></span><br><span class="line">Complex c2(2, 4), c3(3, 7);</span><br><span class="line">Complex *pc = <span class="keyword">new</span> Complex(<span class="number">5</span>, <span class="number">9</span>);</span><br></pre></td></tr></table></figure>
<p>有多个构造函数的情况：多个构造函数重载</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span> </span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">    	<span class="keyword">double</span> real, imag; </span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    	<span class="function"><span class="keyword">void</span> <span class="title">Set</span><span class="params">( <span class="keyword">double</span> r, <span class="keyword">double</span> i )</span></span>;</span><br><span class="line">    	Complex(<span class="keyword">double</span> r, <span class="keyword">double</span> i ); </span><br><span class="line">    	Complex(<span class="keyword">double</span> r ); </span><br><span class="line">    	Complex(Complex c1,  Complex c2);  </span><br><span class="line">&#125;; </span><br><span class="line">Complex::Complex(<span class="keyword">double</span> r, <span class="keyword">double</span> i) &#123;  <span class="comment">// 构造函数1</span></span><br><span class="line">    real = r; </span><br><span class="line">    imag = i; </span><br><span class="line">&#125; </span><br><span class="line">Complex::Complex(<span class="keyword">double</span> r) &#123;   <span class="comment">// 构造函数2</span></span><br><span class="line">    real = r; </span><br><span class="line">    imag = <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line">Complex::Complex (Complex c1,  Complex c2)&#123;  <span class="comment">// 构造函数3</span></span><br><span class="line">    real = c1.real+c2.real; </span><br><span class="line">    imag = c1.imag+c2.imag; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实例化时：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">3</span>)</span></span>;         <span class="comment">// 调用构造函数2，整型可以自动转换为double类型</span></span><br><span class="line"><span class="function">Complex <span class="title">c2</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span></span>;      <span class="comment">// 调用构造函数1</span></span><br><span class="line"><span class="function">Complex <span class="title">c3</span><span class="params">(c1, c2)</span></span>;    <span class="comment">// 调用构造函数3</span></span><br></pre></td></tr></table></figure>
<p>构造函数最好是public的，private构造函数不能直接用来初始化对象。</p>
<h5 id="构造函数在数组中的使用"><a href="#构造函数在数组中的使用" class="headerlink" title="构造函数在数组中的使用"></a>构造函数在数组中的使用</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CSample</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x; </span><br><span class="line">    <span class="keyword">public</span>:   </span><br><span class="line">    	CSample()&#123; </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Constructor 1 Called"</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    	CSample(<span class="keyword">int</span> n) &#123; </span><br><span class="line">            x = n; </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Constructor 2 Called"</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">        &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>实例化时：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CSample array1[<span class="number">2</span>];          </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"step1"</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">    </span><br><span class="line">    CSample array2[<span class="number">2</span>] = &#123;<span class="number">4</span>,<span class="number">5</span>&#125;; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"step2"</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">    </span><br><span class="line">    CSample array3[<span class="number">2</span>] = &#123;<span class="number">3</span>&#125;; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"step3"</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">    </span><br><span class="line">    CSample * array4 =  <span class="keyword">new</span> CSample[<span class="number">2</span>]; </span><br><span class="line">    <span class="keyword">delete</span> []array4; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Constructor 1 Called</span><br><span class="line">Constructor 1 Called</span><br><span class="line">step1</span><br><span class="line">Constructor 2 Called</span><br><span class="line">Constructor 2 Called</span><br><span class="line">step2</span><br><span class="line">Constructor 2 Called</span><br><span class="line">Constructor 1 Called</span><br><span class="line">step3</span><br><span class="line">Constructor 1 Called</span><br><span class="line">Constructor 1 Called</span><br></pre></td></tr></table></figure>
<p>另一个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    	Test(<span class="keyword">int</span> n)&#123; &#125;             <span class="comment">// (1)</span></span><br><span class="line">    	Test(<span class="keyword">int</span> n, <span class="keyword">int</span> m)&#123; &#125;      <span class="comment">// (2)  </span></span><br><span class="line">    	Test()&#123; &#125;                   <span class="comment">// (3) </span></span><br><span class="line">&#125;; </span><br><span class="line">Test array1[<span class="number">3</span>] = &#123;<span class="number">1</span>, Test(<span class="number">1</span>,<span class="number">2</span>)&#125;; </span><br><span class="line"><span class="comment">// 三个元素分别用(1),(2),(3)初始化  </span></span><br><span class="line">Test array2[<span class="number">3</span>] = &#123;Test(<span class="number">2</span>,<span class="number">3</span>), Test(<span class="number">1</span>,<span class="number">2</span>), <span class="number">1</span>&#125;; </span><br><span class="line"><span class="comment">// 三个元素分别用(2),(2),(1)初始化  </span></span><br><span class="line">Test *pArray[<span class="number">3</span>] = &#123;<span class="keyword">new</span> Test(<span class="number">4</span>), <span class="keyword">new</span> Test(<span class="number">1</span>,<span class="number">2</span>)&#125;; </span><br><span class="line"><span class="comment">//两个元素分别用(1),(2) 初始化</span></span><br></pre></td></tr></table></figure>
<p>第三个定义了一个指针数组，不会引发Test构造函数被调用，因为其每个元素都是指针，并不是对象，因此没有进行实例化。对于这个指针数组，可以不进行初始化操作。当<code>new</code>出来两个对象后，<code>new</code>表达式的返回值为<code>Test *</code>类型的指针。该表达式只生成了两个对象，而不是三个。<code>pArray[2]</code>是一个未经初始化的指针。</p>
<h4 id="复制构造函数"><a href="#复制构造函数" class="headerlink" title="复制构造函数"></a>复制构造函数</h4><p>复制构造函数（copy constructor）只有一个参数，即对同类对象的<strong>引用</strong>，不能直接为同类的对象。</p>
<p>形如：</p>
<p><code>X::X(X &amp;)</code>或<code>X::X(const X &amp;)</code>,二者选一。后者能以常量对象作为参数。</p>
<p>若未定义复制构造函数，编译器生成默认复制构造函数，默认复制构造函数完成复制功能。</p>
<p>例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> real, imag;</span><br><span class="line">&#125;;</span><br><span class="line">Complex c1;             <span class="comment">// 调用缺省无参构造函数</span></span><br><span class="line"><span class="function">Complex <span class="title">c2</span><span class="params">(c1)</span></span>;         <span class="comment">// 调用缺省的复制构造函数，将c2初始化为和c1相同</span></span><br></pre></td></tr></table></figure>
<p>当定义了复制构造函数之后，编译器不会自动生成复制构造函数。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="keyword">double</span> real, imag;</span><br><span class="line">    Complex()&#123;&#125;</span><br><span class="line">    Complex(<span class="keyword">const</span> Complex &amp; c)&#123;</span><br><span class="line">        real = c.real;</span><br><span class="line">        imag = c.imag;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Copy constructor called"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Complex c1;          <span class="comment">// 直接调用第一个构造函数</span></span><br><span class="line"><span class="function">Complex <span class="title">c2</span><span class="params">(c1)</span></span>;      <span class="comment">// 初始化c2，调用自定义的复制构造函数</span></span><br></pre></td></tr></table></figure></p>
<h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ol>
<li>当用一个对象去初始化同类的另一个对象时。</li>
</ol>
<p>如上面例子中用c1初始化c2。其中<code>Complex c2 = c1</code>也是初始化语句，等价于<code>Complex c2(c1)</code>，是非赋值语句。</p>
<ol start="2">
<li>如果某函数有一个参数是类 A 的对象，该函数被调用时，类A的复制构造函数被调用</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    A()&#123;&#125;;</span><br><span class="line">    A(A &amp; a)&#123;               <span class="comment">// 自定义的复制构造函数，未进行复制工作</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Copy constructor called"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">(A a1)</span></span>&#123;&#125;           <span class="comment">// 形参a1使用自定义复制构造函数初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a2;</span><br><span class="line">    Func(a2);              <span class="comment">// 调用该函数时，调用A的复制构造函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时的形参a1和实参a2的值可能不相同，因为自定义的复制构造函数没有进行复制工作。当未自定义复制构造函数时，形参a1的值和实参a2的值是相等的，因为编译器自动生成的复制构造函数会进行复制工作。<br>输出结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Copy constructor called</span><br></pre></td></tr></table></figure></p>
<ol start="3">
<li>如果函数的返回值是类A的对象，则函数返回时，A的复制构造函数被调用<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    A(<span class="keyword">int</span> n)&#123;v = n;&#125;</span><br><span class="line">    A(<span class="keyword">const</span> A &amp; a)&#123;</span><br><span class="line">        v = a.v;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Copy constructor called"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">A <span class="title">Func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">b</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;Func().v&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>调用<code>Func()</code>函数时，首先需要生成临时返回值对象，调用复制构造函数，初始化临时返回对象，形参为b，因此输出“Copy constructor called”，且这里复制构造函数对v的值进行了复制操作，因此输出“4”。因此函数的返回值可能和b不是相等的，这取决于复制构造函数的写法。<br>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Copy constructor called</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<h4 id="类型转换构造函数"><a href="#类型转换构造函数" class="headerlink" title="类型转换构造函数"></a>类型转换构造函数</h4><p>类型转换构造函数的目的是实现类型的自动转化。<br>特点：</p>
<ul>
<li>只有一个参数</li>
<li>不是复制构造函数</li>
<li>编译系统自动调用转换构造函数同时创建临时变量</li>
</ul>
<p>例：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> real, imag;</span><br><span class="line">    Complex(<span class="keyword">int</span> i)&#123;           <span class="comment">// 类型转换构造函数</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"IntConstructor called"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        real = i;</span><br><span class="line">        imag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Complex(<span class="keyword">double</span> r, <span class="keyword">double</span> i)&#123;  <span class="comment">// 传统构造函数</span></span><br><span class="line">        real = r;</span><br><span class="line">        imag = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">7</span>, <span class="number">8</span>)</span></span>;            <span class="comment">// 调用传统构造函数初始化c1</span></span><br><span class="line">    Complex c2 = <span class="number">12</span>;             <span class="comment">// 初始化c2，调用类型转换构造函数</span></span><br><span class="line">    c1 = <span class="number">9</span>;                      <span class="comment">// 赋值语句，编译器自动调用类型转换构造函数，此时已9作为实参，调用类型转换构造函数，生成临时对象，赋值给c1</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;c1.real&lt;&lt;<span class="string">","</span>&lt;&lt;c1.imag&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IntConstructor called</span><br><span class="line">IntConstructor called</span><br><span class="line">9,0</span><br></pre></td></tr></table></figure></p>
<h4 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h4><ul>
<li>析构函数是成员函数的一种</li>
<li>名字与类名相同，形如<code>~X()</code></li>
<li>没有参数和返回值</li>
<li>一个类最多只有一个析构函数</li>
</ul>
<p>析构函数在对象消亡时会自动被调用，释放给类分配的对象空间。未定义析构函数时，编译器会自动生成缺省析构函数，但该析构函数不涉及释放用户申请的内存释放等清理工作。当自定义析构函数时，编译器不会生成缺省构造函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="keyword">char</span> * p;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	String()&#123;</span><br><span class="line">        	p = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>];</span><br><span class="line">   	 	&#125;</span><br><span class="line">    	~String();</span><br><span class="line">&#125;;</span><br><span class="line">String::~String()&#123;</span><br><span class="line">    <span class="keyword">delete</span> [] p;    <span class="comment">// 自定义析构函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在初始化构造函数时，new了一个char型数组，分配了一个空间。调用析构函数时，需要将new出来的空间delete掉。</p>
<h5 id="析构函数和数组"><a href="#析构函数和数组" class="headerlink" title="析构函数和数组"></a>析构函数和数组</h5><p>在对象数组生命周期结束时，对象数组的每一个元素的析构函数都会被调用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ctest</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	~Ctest()&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Destructor called"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Ctest <span class="built_in">array</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"End Main"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在程序结束之前，编译器会调用析构函数，因为是两个对象，因此会执行两次析构函数，最后输出为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">End Main</span><br><span class="line">Destructor called</span><br><span class="line">Destructor called</span><br></pre></td></tr></table></figure></p>
<h5 id="delete运算符"><a href="#delete运算符" class="headerlink" title="delete运算符"></a>delete运算符</h5><p><code>delete</code>运算符会导致析构函数的调用<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Ctest * pTest;</span><br><span class="line">pTest = <span class="keyword">new</span> Ctest;          <span class="comment">// 构造函数调用</span></span><br><span class="line"><span class="keyword">delete</span> pTest;               <span class="comment">// 析构函数调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组delete运算符</span></span><br><span class="line">pTest = <span class="keyword">new</span> Ctest[<span class="number">3</span>];      <span class="comment">// 构造函数调用3次</span></span><br><span class="line"><span class="keyword">delete</span> [] pTest;           <span class="comment">// 析构函数调用3次</span></span><br></pre></td></tr></table></figure></p>
<h4 id="构造函数和析构函数调用例子"><a href="#构造函数和析构函数调用例子" class="headerlink" title="构造函数和析构函数调用例子"></a>构造函数和析构函数调用例子</h4><p>定义一个Demo类，并定义构造函数和析构函数。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	Demo(<span class="keyword">int</span> i)&#123;</span><br><span class="line">            id = i;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"id="</span>&lt;&lt;id&lt;&lt;<span class="string">"Constructed"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	~Demo()&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"id="</span>&lt;&lt;id&lt;&lt;<span class="string">"Destructed"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Demo <span class="title">d1</span><span class="params">(<span class="number">1</span>)</span></span>;      <span class="comment">// 定义全局变量Demo对象，调用构造函数初始化输出“id=1 Constructed”</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Demo <span class="title">d2</span><span class="params">(<span class="number">2</span>)</span></span>;            <span class="comment">// 定义静态局部变量，调用构造函数初始化d2，输出“id=2 Constructed”，静态变量消亡是在程序结束时，因此出了Func函数后仍然不会调用d2的析构函数</span></span><br><span class="line">    <span class="function">Demo <span class="title">d3</span><span class="params">(<span class="number">3</span>)</span></span>;                  <span class="comment">// 定义d3局部变量，调用构造函数输出“id=3 Constructed”，在出Func函数，即其作用域时，调用析构函数，输出“id=3 Destructed”</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; “Func” &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Demo <span class="title">d4</span><span class="params">(<span class="number">4</span>)</span></span>;   <span class="comment">// 局部变量Demo对象，调用构造函数初始化输出“id=4 Constructed”</span></span><br><span class="line">    d4 = <span class="number">6</span>;       <span class="comment">// 调用类型转换构造函数，需要生成临时Demo对象，输出“id=6 Constructed”,赋值完成后需要调用析构函数销毁临时Demo对象，因此输出“id=6 Destructed”</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; “main” &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#123; <span class="function">Demo <span class="title">d5</span><span class="params">(<span class="number">5</span>)</span></span>;&#125;  <span class="comment">// 添加自身作用域，表示d5只在作用域中存在，因此需要调用构造函数，输出“id=5 Constructed”，在作用域结束时，调用析构函数，输出“id=5 Destructed”</span></span><br><span class="line">    Func();        <span class="comment">// 进入Func函数中</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; “main ends” &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在main函数结束后，会依次析构局部变量、局部静态变量、全局变量。<br>最终的输出结果为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id=1 Constructed</span><br><span class="line">id=4 Constructed</span><br><span class="line">id=6 Constructed</span><br><span class="line">id=6 Destructed</span><br><span class="line">main</span><br><span class="line">id=5 Constructed</span><br><span class="line">id=5 Destructed</span><br><span class="line">id=2 Constructed</span><br><span class="line">id=3 Constructed</span><br><span class="line">Func</span><br><span class="line">id=3 Destructed</span><br><span class="line">main ends</span><br><span class="line">id=6 Destructed</span><br><span class="line">id=2 Destructed</span><br><span class="line">id=1 Destructed</span><br></pre></td></tr></table></figure></p>
<h3 id="类成员的访问权限"><a href="#类成员的访问权限" class="headerlink" title="类成员的访问权限"></a>类成员的访问权限</h3><p>通过关键字，可以定义类成员在什么位置允许访问。关键字分为三种：</p>
<ul>
<li>private：私有成员，只能在成员函数内被访问到；缺省为私有成员</li>
<li>public：公有成员，在任意位置可以被访问</li>
<li>protected：保护成员，在被继承时使用</li>
</ul>
<p>根据当前位置的不同，访问到类的成员也不同</p>
<ul>
<li>在类成员函数的内部：当前对象的全部属性、函数；同类其他对象的全部属性、函数</li>
<li>在类的成员函数外部：只能访问该对象的公有成员</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CEmployee</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">char</span> szName[<span class="number">30</span>];</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> salary;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">char</span> *name)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">getName</span><span class="params">(<span class="keyword">char</span> *name)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">averageSalary</span><span class="params">(CEmployee e1, CEmployee e2)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CEmployee::setName(<span class="keyword">char</span> *name)&#123;</span><br><span class="line">    <span class="built_in">strcpy</span>(szName, name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> CEmployee::getName(<span class="keyword">char</span> *name)&#123;</span><br><span class="line">    <span class="built_in">strcpy</span>(name, szName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> CEmployee::averageSalary(CEmployee e1,CEmployee e2)&#123; </span><br><span class="line">    salary = (e1.salary + e2.salary )/<span class="number">2</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">    CEmployee e; </span><br><span class="line">    <span class="built_in">strcpy</span>(e.szName, <span class="string">"Tom1234567889"</span>);  <span class="comment">// 编译错误, 不能访问私有成员</span></span><br><span class="line">    e.setName( <span class="string">"Tom"</span>);                  <span class="comment">// 编译正确</span></span><br><span class="line">    e.salary = <span class="number">5000</span>;                    <span class="comment">// 编译正确 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置私有成员的目的是，强制对成员变量的访问一定要通过成员函数进行，可以将私有成员隐藏起来。 </p>
<hr>
<h1 id="第一周作业"><a href="#第一周作业" class="headerlink" title="第一周作业"></a>第一周作业</h1><h2 id="测验"><a href="#测验" class="headerlink" title="测验"></a>测验</h2><ol>
<li>以下说法正确的是：</li>
</ol>
<ul>
<li style="list-style: none"><input type="checkbox"> 每个对象内部都有成员函数的实现代码</li>
<li style="list-style: none"><input type="checkbox"> 类的成员函数之间可以互相调用</li>
<li>[X] 一个类的私有成员函数内部不能访问本类的私有成员变量</li>
<li style="list-style: none"><input type="checkbox"> 编写一个类时，至少要写一个成员函数</li>
</ul>
<ol start="2">
<li>以下对类A的定义，哪个是正确的？</li>
</ol>
<ul>
<li style="list-style: none"><input type="checkbox" checked> A</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> v;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">A::<span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">()</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li style="list-style: none"><input type="checkbox"> B                        // 缺少“；”</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">	<span class="keyword">private</span>: </span><br><span class="line">		<span class="keyword">int</span> v;</span><br><span class="line">	<span class="keyword">public</span> : </span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li style="list-style: none"><input type="checkbox"> C</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> v;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		A next;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li style="list-style: none"><input type="checkbox"> D</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> v;	</span><br><span class="line">	A *next;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>假设有以下类A:</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123; <span class="keyword">return</span> a * a; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以下程序片段，哪个是不正确的？</p>
<ul>
<li style="list-style: none"><input type="checkbox"> <code>A a; A &amp; r = a; r.func(5);</code></li>
<li style="list-style: none"><input type="checkbox"> <code>A *p = new A; p-&gt;func(5);</code></li>
<li style="list-style: none"><input type="checkbox"> <code>A a; a.func(5);</code></li>
<li style="list-style: none"><input type="checkbox" checked> <code>A a, b; if( a!= b ) a.func(5);</code></li>
</ul>
<ol start="4">
<li>以下程序，哪个是不正确的？</li>
</ol>
<ul>
<li style="list-style: none"><input type="checkbox"> A</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span> </span><br><span class="line">        <span class="keyword">public</span>: </span><br><span class="line">        	<span class="keyword">int</span> v; </span><br><span class="line">    &#125;;</span><br><span class="line">	A * p = <span class="keyword">new</span> A;</span><br><span class="line">	p-&gt;v = <span class="number">4</span>; </span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li style="list-style: none"><input type="checkbox"> B                        // 缺少“；”</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">        <span class="keyword">public</span>: </span><br><span class="line">        	<span class="keyword">int</span> v;</span><br><span class="line">        	A * p;	</span><br><span class="line">    &#125;;</span><br><span class="line">	A a; </span><br><span class="line">    a.p = <span class="keyword">new</span> A; </span><br><span class="line">    <span class="keyword">delete</span> a.p;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li style="list-style: none"><input type="checkbox" checked> C</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">        <span class="keyword">public</span>: </span><br><span class="line">        	<span class="keyword">int</span> v; </span><br><span class="line">        	A * p;	</span><br><span class="line">    &#125;;</span><br><span class="line">	A a; </span><br><span class="line">    a.p = &amp; a; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li style="list-style: none"><input type="checkbox"> D</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span> <span class="keyword">int</span> v; &#125;;</span><br><span class="line">	A a; </span><br><span class="line">    a.v = <span class="number">3</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>以下说法中正确的是：</li>
</ol>
<ul>
<li style="list-style: none"><input type="checkbox"> 构造函数的返回值类型是 void</li>
<li style="list-style: none"><input type="checkbox"> 一个类只能定义一个构造函数，但可以定义多个析构函数</li>
<li style="list-style: none"><input type="checkbox" checked> 一个类只能定义一个析构函数，但可以定义多个构造函数</li>
<li style="list-style: none"><input type="checkbox"> 一个类一定会有无参构造函数构造函数的返回值类型是 void</li>
</ul>
<ol start="6">
<li>对于通过 new 运算符生成的对象</li>
</ol>
<ul>
<li style="list-style: none"><input type="checkbox"> 在程序结束时自动析构</li>
<li style="list-style: none"><input type="checkbox" checked> 在执行 delete 操作时会析构，如果没有执行delete操作，则在程序结束时自动析构</li>
<li style="list-style: none"><input type="checkbox"> 执行 delete 操作时才能析构</li>
<li style="list-style: none"><input type="checkbox"> 在包含该 new 语句的函数返回时自动析构</li>
</ul>
<h2 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>在一个学生信息处理程序中，要求实现一个代表学生的类，并且所有成员变量都应该是私有的。</p>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>姓名，年龄，学号，第一学年平均成绩，第二学年平均成绩，第三学年平均成绩，第四学年平均成绩。</p>
<p>其中姓名、学号为字符串，不含空格和逗号；年龄为正整数；成绩为非负整数。</p>
<p>各部分内容之间均用单个英文逗号”,”隔开，无多余空格。</p>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>一行，按顺序输出：姓名，年龄，学号，四年平均成绩（向下取整）。</p>
<p>各部分内容之间均用单个英文逗号”,”隔开，无多余空格。</p>
<h3 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h3><p>输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Tom,18,7817,80,80,90,70</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Tom,18,7817,80</span><br></pre></td></tr></table></figure>
<h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">100</span>], number[<span class="number">100</span>];</span><br><span class="line">	<span class="keyword">int</span> age, grade1, grade2, grade3, grade4;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Student(<span class="keyword">char</span> pname[], <span class="keyword">int</span> page, <span class="keyword">char</span> pnumber[], <span class="keyword">int</span> pgrade1, <span class="keyword">int</span>  pgrade2, <span class="keyword">int</span> pgrade3, <span class="keyword">int</span> pgrade4)&#123;</span><br><span class="line">		<span class="built_in">strcpy</span>(name, pname);</span><br><span class="line">		age = page;</span><br><span class="line">		<span class="built_in">strcpy</span>(number, pnumber);</span><br><span class="line">		grade1 = pgrade1;</span><br><span class="line">		grade2 = pgrade2;</span><br><span class="line">		grade3 = pgrade3;</span><br><span class="line">		grade4 = pgrade4;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getAverageGrade</span><span class="params">()</span></span>&#123;</span><br><span class="line">	    <span class="keyword">return</span> ((grade1 + grade2 + grade3 + grade4) / <span class="number">4</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">char</span> * <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">	    <span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">char</span> * <span class="title">getNum</span><span class="params">()</span></span>&#123;</span><br><span class="line">	    <span class="keyword">return</span> number;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	    <span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">100</span>], number[<span class="number">100</span>];</span><br><span class="line">	<span class="keyword">int</span> age, grade1, grade2, grade3, grade4;</span><br><span class="line">	<span class="built_in">cin</span>.getline(name, <span class="number">100</span>, <span class="string">','</span>);</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; age;</span><br><span class="line">	<span class="keyword">char</span> a = getchar();</span><br><span class="line">	<span class="built_in">cin</span>.getline(number, <span class="number">100</span>, <span class="string">','</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; grade1 &gt;&gt; a &gt;&gt; grade2 &gt;&gt; a &gt;&gt; grade3 &gt;&gt; a &gt;&gt; grade4;</span><br><span class="line">	<span class="function">Student <span class="title">s</span><span class="params">(name, age, number, grade1, grade2, grade3, grade4)</span></span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; s.getName() &lt;&lt; <span class="string">","</span> &lt;&lt; s.getAge() &lt;&lt; <span class="string">","</span> &lt;&lt; s.getNum() &lt;&lt; <span class="string">","</span> &lt;&lt; s.getAverageGrade();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Tom,22,2017110,99,98,89,95</span><br><span class="line">Tom,22,2017110,95</span><br></pre></td></tr></table></figure>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">NYY</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2018/08/06/c++/c-1-2/">http://yoursite.com/2018/08/06/c++/c-1-2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a><a class="post-meta__tags" href="/tags/北大课程/">北大课程</a></div><div class="social-share"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2018/08/21/c++/c-2-1/"><i class="fa fa-chevron-left">  </i><span>类成员变量</span></a></div><div class="next-post pull-right"><a href="/2018/08/01/c++/c-1-1/"><span>C++函数指针、引用、位运算</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'http://yoursite.com/2018/08/06/c++/c-1-2/';
  this.page.identifier = '2018/08/06/c++/c-1-2/';
  this.page.title = 'c++类和函数';
}
var d = document, s = d.createElement('script');
s.src = "https://" + 'niuyuanyuan' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-src" src="https://niuyuanyuan.disqus.com/count.js" async></script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 By NYY</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.6"></script><script src="/js/fancybox.js?version=1.5.6"></script><script src="/js/sidebar.js?version=1.5.6"></script><script src="/js/copy.js?version=1.5.6"></script><script src="/js/fireworks.js?version=1.5.6"></script><script src="/js/transition.js?version=1.5.6"></script><script src="/js/scroll.js?version=1.5.6"></script><script src="/js/head.js?version=1.5.6"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>