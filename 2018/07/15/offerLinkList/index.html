<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="剑指offer刷题总结（链表）"><meta name="keywords" content="java,剑指offer,python,链表"><meta name="author" content="NYY,undefined"><meta name="copyright" content="NYY"><title>剑指offer刷题总结（链表） | NYY's blog</title><link rel="shortcut icon" href="/icon1.png"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.1"><script>var GLOBAL = { 
  root: '/',
  algolia: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  localSearch: undefined
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#剑指offer总结——链表"><span class="toc-number">1.</span> <span class="toc-text">剑指offer总结——链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题6：从尾到头打印链表"><span class="toc-number">1.0.1.</span> <span class="toc-text">面试题6：从尾到头打印链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#题目描述"><span class="toc-number">1.0.1.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解决方案"><span class="toc-number">1.0.1.2.</span> <span class="toc-text">解决方案</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题18：删除链表的节点"><span class="toc-number">1.0.2.</span> <span class="toc-text">面试题18：删除链表的节点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#题目描述-1"><span class="toc-number">1.0.2.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解决方案-1"><span class="toc-number">1.0.2.2.</span> <span class="toc-text">解决方案</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#链表中倒数第k个节点"><span class="toc-number">1.0.3.</span> <span class="toc-text">链表中倒数第k个节点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#题目描述-2"><span class="toc-number">1.0.3.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解决方案-2"><span class="toc-number">1.0.3.2.</span> <span class="toc-text">解决方案</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题23：链表中环的入口节点"><span class="toc-number">1.0.4.</span> <span class="toc-text">面试题23：链表中环的入口节点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#题目描述-3"><span class="toc-number">1.0.4.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解决方案-3"><span class="toc-number">1.0.4.2.</span> <span class="toc-text">解决方案</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题24：反转链表"><span class="toc-number">1.0.5.</span> <span class="toc-text">面试题24：反转链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#题目描述-4"><span class="toc-number">1.0.5.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解决方案-4"><span class="toc-number">1.0.5.2.</span> <span class="toc-text">解决方案</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题25：合并两个排序的链表"><span class="toc-number">1.0.6.</span> <span class="toc-text">面试题25：合并两个排序的链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#题目描述-5"><span class="toc-number">1.0.6.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解决方案-5"><span class="toc-number">1.0.6.2.</span> <span class="toc-text">解决方案</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题35：复杂链表的复制"><span class="toc-number">1.0.7.</span> <span class="toc-text">面试题35：复杂链表的复制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#题目描述-6"><span class="toc-number">1.0.7.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解决方案-6"><span class="toc-number">1.0.7.2.</span> <span class="toc-text">解决方案</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题52：两个链表的第一个公共节点"><span class="toc-number">1.0.8.</span> <span class="toc-text">面试题52：两个链表的第一个公共节点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#题目描述-7"><span class="toc-number">1.0.8.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解决方案-7"><span class="toc-number">1.0.8.2.</span> <span class="toc-text">解决方案</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试题62：圆圈中最后剩下的数字"><span class="toc-number">1.0.9.</span> <span class="toc-text">面试题62：圆圈中最后剩下的数字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#题目描述-8"><span class="toc-number">1.0.9.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解决方案-8"><span class="toc-number">1.0.9.2.</span> <span class="toc-text">解决方案</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://i.loli.net/2018/04/05/5ac5c474e8082.jpg"></div><div class="author-info__name text-center">NYY</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">15</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">13</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">3</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(http://p6um59a45.bkt.clouddn.com/18-7-15/99353472.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">NYY's blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">剑指offer刷题总结（链表）</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-07-15</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Algorithm/">Algorithm</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2018/07/15/offerLinkList/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2018/07/15/offerLinkList/"></span></a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">2,782</span><span class="post-meta__separator">|</span><span>Reading time: 11 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div id="post-content"><h1 id="剑指offer总结——链表"><a href="#剑指offer总结——链表" class="headerlink" title="剑指offer总结——链表"></a><center>剑指offer总结——链表</center></h1><h3 id="面试题6：从尾到头打印链表"><a href="#面试题6：从尾到头打印链表" class="headerlink" title="面试题6：从尾到头打印链表"></a>面试题6：从尾到头打印链表</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。 </p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>解法一：使用栈的形式，将链表从头到尾入栈，最后依次出栈，时间复杂度及空间复杂度均为$O(n)$<br>解法二：递归</p>
<ul>
<li>java解法一：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span></span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (listNode == <span class="keyword">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (listNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">        stack.push(listNode.val);</span><br><span class="line">        listNode = listNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">        ans.add(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>java解法二：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">if</span>(listNode == <span class="keyword">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line">    ListNode pHead = listNode;</span><br><span class="line">    <span class="keyword">if</span>(pHead != <span class="keyword">null</span>)&#123;</span><br><span class="line">        ans = printList(pHead, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printList</span><span class="params">(ListNode pHead, ArrayList&lt;Integer&gt; ans)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pHead.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        ans = printList(pHead.next, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    ans.add(pHead.val);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>python解法：使用python insert函数</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printListFromTailToHead</span><span class="params">(self, listNode)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> listNode:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    arr = []</span><br><span class="line">    head = listNode</span><br><span class="line">    <span class="keyword">while</span> head:</span><br><span class="line">        arr.insert(<span class="number">0</span>, head.val)</span><br><span class="line">        head = head.next</span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>
<h3 id="面试题18：删除链表的节点"><a href="#面试题18：删除链表的节点" class="headerlink" title="面试题18：删除链表的节点"></a>面试题18：删除链表的节点</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个单向链表的头指针的一个节点指针，实现一个函数在$O(1)$时间删除该节点</p>
<h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><p>常用的做法是遍历链表，找到目标节点，其时间复杂度为$O(n)$，不满足要求。要删除该节点，不一定非要找到目标节点的上一节点，只需要找到目标节点的下一节点，将其赋值给目标节点就可以了。</p>
<ul>
<li>链表有多个节点，要删除的不是尾节点需要$O(1)$的时间；</li>
<li>链表只有一个结点，删除头结点（也是尾结点）需要$O(1)$的时间；</li>
<li>链表有多个节点，要删除的是尾节点需要$O(n)$的时间</li>
</ul>
<p>并且在删除操作前，需要判断target节点是否确实在链表中，这样的查找需要$O(n)$的时间，但此处因为时间复杂度的要求，不加以判断。</p>
<ul>
<li>java解法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode pHead, ListNode target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span> || target == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(target.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        ListNode temp = target.next;</span><br><span class="line">        target.val = temp.val;</span><br><span class="line">        target.next = temp.next;</span><br><span class="line">        temp = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pHead == target)&#123;</span><br><span class="line">        pHead = <span class="keyword">null</span>;</span><br><span class="line">        target = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        ListNode head = pHead;</span><br><span class="line">        <span class="keyword">while</span>(head.next != target)</span><br><span class="line">            head = head.next;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        target = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="链表中倒数第k个节点"><a href="#链表中倒数第k个节点" class="headerlink" title="链表中倒数第k个节点"></a>链表中倒数第k个节点</h3><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个链表，输出该链表中倒数第k个结点。 </p>
<h4 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h4><p>类似于滑动窗的做法，使用两个指针，让第一个指针先走k-1步，再让第一第二个指针同时走，当第一个指针走到链表尾部的时候，第二个指针正好指向倒数第K个结点。其时间复杂度为$O(n)$,空间复杂度为$O(1)$</p>
<ul>
<li>java解法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span><span class="params">(ListNode head,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    ListNode first = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || k &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> first.next;</span><br><span class="line">    &#125;</span><br><span class="line">    first = head;</span><br><span class="line">    ListNode second = head;</span><br><span class="line">    <span class="keyword">while</span>(--k &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        first = first.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (first == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(first.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        first = first.next;</span><br><span class="line">        second = second.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="面试题23：链表中环的入口节点"><a href="#面试题23：链表中环的入口节点" class="headerlink" title="面试题23：链表中环的入口节点"></a>面试题23：链表中环的入口节点</h3><h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><p>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。</p>
<h4 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h4><p>使用一个快指针，步长为2，慢指针，步长为1。如果链表中有环，两个指针在更新的过程中都不可能为null，当快慢指针第一次相遇时，根据其更新次数是相等的，然后快指针的路程是慢指针的2倍的关系，列出等式，然后让快指针从头结点开始走，慢指针从当前位置以相同的步长开始走。当他们相遇时，相遇的节点就是环的入口节点。时间复杂度为$O(n)$，空间复杂度为$O(1)$</p>
<ul>
<li>java解法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(pHead == <span class="keyword">null</span> || pHead.next == <span class="keyword">null</span> || pHead.next.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      ListNode slow = pHead.next, fast = slow.next;</span><br><span class="line">      <span class="keyword">while</span>(fast != slow)&#123;</span><br><span class="line">          slow = slow.next;</span><br><span class="line">          fast = fast.next.next;</span><br><span class="line">          <span class="keyword">if</span>(fast == <span class="keyword">null</span> || slow == <span class="keyword">null</span>)&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      fast = pHead;</span><br><span class="line">      <span class="keyword">while</span>(fast != slow)&#123;</span><br><span class="line">          fast = fast.next;</span><br><span class="line">          slow = slow.next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> fast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="面试题24：反转链表"><a href="#面试题24：反转链表" class="headerlink" title="面试题24：反转链表"></a>面试题24：反转链表</h3><h4 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个链表，反转链表后，输出新链表的表头。 </p>
<h4 id="解决方案-4"><a href="#解决方案-4" class="headerlink" title="解决方案"></a>解决方案</h4><p>使用两个指针更新链表，在循环内部使用一个temp Node保存当前结点的next结点，然后将head节点的next指向pre节点，此时完成了head节点的断链以及指向新链。然后将pre指向当前节点head， head指向其下一个节点temp。时间复杂度为$O(n)$，空间复杂度为$O(1)$</p>
<ul>
<li>java解法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">        ListNode temp = head.next;</span><br><span class="line">        head.next = pre;</span><br><span class="line">        pre = head;</span><br><span class="line">        head = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="面试题25：合并两个排序的链表"><a href="#面试题25：合并两个排序的链表" class="headerlink" title="面试题25：合并两个排序的链表"></a>面试题25：合并两个排序的链表</h3><h4 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 </p>
<h4 id="解决方案-5"><a href="#解决方案-5" class="headerlink" title="解决方案"></a>解决方案</h4><p>创建一个头节点，使用while循环，遍历两个list，进行判断：</p>
<p>当头结点的下一个节点为list1的节点时，需要满足的条件为list2此时为null或（list1不为null且list1的小于list2的值）充分利用逻辑语句的短路性质，list2的判断方法相同。时间复杂度为$O(n)$,空间复杂度为$O(1)$</p>
<ul>
<li>java解法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(list1 == <span class="keyword">null</span>) <span class="keyword">return</span> list2;</span><br><span class="line">    <span class="keyword">if</span>(list2 == <span class="keyword">null</span>) <span class="keyword">return</span> list1;</span><br><span class="line"></span><br><span class="line">    ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode ans = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(list1 != <span class="keyword">null</span> || list2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(list2 == <span class="keyword">null</span> || (list1 != <span class="keyword">null</span> &amp;&amp; list1.val &lt; list2.val))&#123;</span><br><span class="line">            ans.next = list1;</span><br><span class="line">            list1 = list1.next;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(list1 == <span class="keyword">null</span> || (list2 != <span class="keyword">null</span> &amp;&amp; list1.val &gt;= list2.val))&#123;</span><br><span class="line">            ans.next = list2;</span><br><span class="line">            list2 = list2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = ans.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="面试题35：复杂链表的复制"><a href="#面试题35：复杂链表的复制" class="headerlink" title="面试题35：复杂链表的复制"></a>面试题35：复杂链表的复制</h3><h4 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> label;</span><br><span class="line">    RandomListNode next = <span class="keyword">null</span>;</span><br><span class="line">    RandomListNode random = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    RandomListNode(<span class="keyword">int</span> label) &#123;</span><br><span class="line">        <span class="keyword">this</span>.label = label;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂链表示例：</p>
<center><br><img src="http://p6um59a45.bkt.clouddn.com/18-7-15/16284466.jpg" width="50%/"><br></center>

<h4 id="解决方案-6"><a href="#解决方案-6" class="headerlink" title="解决方案"></a>解决方案</h4><p>有一个巧妙的方法，使用链表结构本身来记录其sbiling指针的位置，分成三个步骤 </p>
<ul>
<li>根据原始链表的每个结点N创建对应的N’，并把N’连在N的后面。  如下图： </li>
</ul>
<p><img src="http://p6um59a45.bkt.clouddn.com/18-7-15/94457924.jpg" width="75%/"></p>
<ul>
<li>根据原来的记录，N节点的random指向S节点，因此将复制出来的节点N’的random指向其对应的S’节点，如图所示</li>
</ul>
<p><img src="http://p6um59a45.bkt.clouddn.com/18-7-15/53273982.jpg" width="75%/"></p>
<ul>
<li>将长链表拆分为两个短链表，将奇数位置的节点连接起来就是原链表，偶数位置的链表连接起来就是复制的链表。如图所示</li>
</ul>
<p><img src="http://p6um59a45.bkt.clouddn.com/18-7-15/27881386.jpg" width="75%/"></p>
<p>这种方法的总体时间复杂度为$O(n)$,空间复杂度也为$O(n)$</p>
<ul>
<li>java解法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RandomListNode <span class="title">Clone</span><span class="params">(RandomListNode pHead)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pHead == <span class="keyword">null</span>) <span class="keyword">return</span> pHead;</span><br><span class="line">    RandomListNode p = pHead, q = pHead, g = pHead;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="keyword">null</span>)&#123;</span><br><span class="line">        RandomListNode copy = <span class="keyword">new</span> RandomListNode(p.label);</span><br><span class="line">        copy.next = p.next;</span><br><span class="line">        p.next = copy;</span><br><span class="line">        p = copy.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(q.random != <span class="keyword">null</span>)&#123;</span><br><span class="line">            q.next.random = q.random.next;</span><br><span class="line">        &#125;</span><br><span class="line">        q = q.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    RandomListNode ans = <span class="keyword">new</span> RandomListNode(<span class="number">0</span>);</span><br><span class="line">    RandomListNode f = ans;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(g != <span class="keyword">null</span>)&#123;                         <span class="comment">//注意最后分开两个链表的方式，用局部变量</span></span><br><span class="line">        RandomListNode temp = g.next;</span><br><span class="line">        g.next = temp.next;</span><br><span class="line">        temp.next = f.next;</span><br><span class="line">        f.next = temp;</span><br><span class="line">        f = f.next;</span><br><span class="line">        g = g.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="面试题52：两个链表的第一个公共节点"><a href="#面试题52：两个链表的第一个公共节点" class="headerlink" title="面试题52：两个链表的第一个公共节点"></a>面试题52：两个链表的第一个公共节点</h3><h4 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入两个链表，找出它们的第一个公共结点。</p>
<h4 id="解决方案-7"><a href="#解决方案-7" class="headerlink" title="解决方案"></a>解决方案</h4><p>首先找到两个链表的长度，其长度的差值d+1就是链表公共节点的个数，然后然长的链表先走d步，然后短链表和长链表一起走，直到两个链表相遇，第一次相遇的节点就是他们相等的节点。时间复杂度$O(n)$,空间复杂度$O(1)$</p>
<ul>
<li>java解法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pHead1 == <span class="keyword">null</span> || pHead2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> count1 = <span class="number">0</span>, count2 = <span class="number">0</span>;</span><br><span class="line">    ListNode p = pHead1, q = pHead2, p1 = p, q1 = q;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="keyword">null</span> || q != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p != <span class="keyword">null</span>)&#123;</span><br><span class="line">            count1++;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(q != <span class="keyword">null</span>)&#123;</span><br><span class="line">            count2++;</span><br><span class="line">            q = q.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count1 &gt; count2) <span class="keyword">return</span> findFirstNode(p1, q1, count1, count2);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> findFirstNode(q1, p1, count2, count1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">findFirstNode</span><span class="params">(ListNode p, ListNode q, <span class="keyword">int</span> count1, <span class="keyword">int</span> count2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> diff = count1 - count2;</span><br><span class="line">    <span class="keyword">while</span>(--diff &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == q) <span class="keyword">return</span> p;</span><br><span class="line">        p = p.next;</span><br><span class="line">        q = q.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="面试题62：圆圈中最后剩下的数字"><a href="#面试题62：圆圈中最后剩下的数字" class="headerlink" title="面试题62：圆圈中最后剩下的数字"></a>面试题62：圆圈中最后剩下的数字</h3><h4 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h4><p>击鼓传花，所有人围成一个圈，编号为0~n-1，共n人，指定一个数字m，每次循环喊数从0~m-1，喊到m-1的淘汰，直到剩下最后一个，返回这个人的编号。</p>
<h4 id="解决方案-8"><a href="#解决方案-8" class="headerlink" title="解决方案"></a>解决方案</h4><p>这是Josephuse环问题，可以用经典的解法：使用环形链表模拟圆圈，创建有m个节点的环形链表，然后每次在链表中删除第n个节点，但总体的时间复杂度为$O(m*n)$,空间复杂度为$O(n)$</p>
<p>一种创新性解法是使用根据题目本身的数学关系，用数学归纳法，建立公式求解，最终实现时间复杂度为$O(n)$，空间复杂度为$O(1)$</p>
<p>问题描述：n个人（编号0~(n-1))，从0开始报数，报到(m-1)的退出，剩下的人 继续从0开始报数。求胜利者的编号。<br>我们知道第一个人(编号一定是m%n-1)出列之后，剩下的n-1个人组成了一个新的约瑟夫环（以编号为k=m%n的人开始）:<br>$$<br>k , k+1,  k+2,  … n-2, n-1, 0, 1, 2, … k-2并且从k开始报0。<br>$$<br>现在我们把他们的编号做一下转换：</p>
<p>$$<br>\begin{equation}<br>\begin{aligned}<br>&amp;k     –&gt; 0 \<br>&amp;k+1   –&gt; 1 \<br>&amp;k+2   –&gt; 2 \<br>&amp;… \<br>&amp;… \<br>&amp;k-2   –&gt; n-2 \<br>&amp;k-1   –&gt; n-1<br> \end{aligned}<br>\end{equation}<br>$$</p>
<p>变换后成为了(n-1)个人报数的子问题，假如知道这个子问题的解：如$x$是最终的胜利者，根据上面的表把$x$变回去刚好就是$n$个人情况的解。变回去的公式为：<br>$$<br>x’=(x+k)%n<br>$$<br>令$f[i]$表示$i$个人玩游戏报$m$退出最后胜利者的编号，最后的结果是$f[n]$。</p>
<p>递推公式<br>$$<br>\begin{equation}<br>f[1]=0;\<br>…\<br>f[i] = f([i-1] + m) \%i;  (i&gt;1)<br>\end{equation}<br>$$<br>有了这个公式，我们要做的就是从1-n顺序算出f[i]的数值，最后结果是f[n]。 因为实际生活中编号总是从1开始，我们输出f[n]+1。</p>
<ul>
<li>java解法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(unsigned <span class="keyword">int</span> n, unsigned <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> (LastRemaining_Solution(n-<span class="number">1</span>,m)+m)%n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">NYY</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2018/07/15/offerLinkList/">http://yoursite.com/2018/07/15/offerLinkList/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java</a><a class="post-meta__tags" href="/tags/剑指offer/">剑指offer</a><a class="post-meta__tags" href="/tags/python/">python</a><a class="post-meta__tags" href="/tags/链表/">链表</a></div><div class="social-share"></div><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2018/07/16/offerTree/"><i class="fa fa-chevron-left">  </i><span>剑指offer刷题总结（树）</span></a></div><div class="next-post pull-right"><a href="/2018/07/12/imgProcession/"><span>图像处理基本方法</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var disqus_shortname = 'niuyuanyuan'
var disqus_config = function () {
  this.page.url = 'http://yoursite.com/2018/07/15/offerLinkList/';
  this.page.identifier = '2018/07/15/offerLinkList/';
  this.page.title = '剑指offer刷题总结（链表）';
}
var d = document, s = d.createElement('script');
s.src = "https://" + disqus_shortname +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-src" src="https://niuyuanyuan.disqus.com/count.js" async></script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2017 - 2018 By NYY</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.1"></script><script src="/js/fancybox.js?version=1.5.1"></script><script src="/js/sidebar.js?version=1.5.1"></script><script src="/js/copy.js?version=1.5.1"></script><script src="/js/fireworks.js?version=1.5.1"></script><script src="/js/transition.js?version=1.5.1"></script><script src="/js/scroll.js?version=1.5.1"></script><script src="/js/head.js?version=1.5.1"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>