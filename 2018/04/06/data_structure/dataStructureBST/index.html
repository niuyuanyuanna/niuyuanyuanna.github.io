<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="数据结构之二叉搜索树"><meta name="keywords" content="C++,数据结构"><meta name="author" content="NYY"><meta name="copyright" content="NYY"><title>数据结构之二叉搜索树 | NYY's blog</title><link rel="shortcut icon" href="/img/my_icon.jpg"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script><!-- hexo-inject:begin --><!-- hexo-inject:end -->var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><!-- hexo-inject:begin --><!-- hexo-inject:end --></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#二叉搜索树"><span class="toc-number">1.</span> <span class="toc-text"> 二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#概念"><span class="toc-number">1.1.</span> <span class="toc-text"> 概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#循关键码访问"><span class="toc-number">1.1.1.</span> <span class="toc-text"> 循关键码访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bst"><span class="toc-number">1.1.2.</span> <span class="toc-text"> BST</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#bst模板"><span class="toc-number">1.1.2.1.</span> <span class="toc-text"> BST模板</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#算法实现"><span class="toc-number">1.2.</span> <span class="toc-text"> 算法实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#查找"><span class="toc-number">1.2.1.</span> <span class="toc-text"> 查找</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方法一"><span class="toc-number">1.2.1.1.</span> <span class="toc-text"> 实现方法一：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#查找接口语义"><span class="toc-number">1.2.1.2.</span> <span class="toc-text"> 查找接口语义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#插入"><span class="toc-number">1.2.2.</span> <span class="toc-text"> 插入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#过程"><span class="toc-number">1.2.2.1.</span> <span class="toc-text"> 过程：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现"><span class="toc-number">1.2.2.2.</span> <span class="toc-text"> 实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#删除"><span class="toc-number">1.2.3.</span> <span class="toc-text"> 删除</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#情况一"><span class="toc-number">1.2.3.1.</span> <span class="toc-text"> 情况一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#情况二"><span class="toc-number">1.2.3.2.</span> <span class="toc-text"> 情况二</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#平衡等价"><span class="toc-number">1.3.</span> <span class="toc-text"> 平衡等价</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#两种口径"><span class="toc-number">1.3.1.</span> <span class="toc-text"> 两种口径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#两种平衡"><span class="toc-number">1.3.2.</span> <span class="toc-text"> 两种平衡</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#等价bst"><span class="toc-number">1.3.3.</span> <span class="toc-text"> 等价BST</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#avl树"><span class="toc-number">1.4.</span> <span class="toc-text"> AVL树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#接口"><span class="toc-number">1.4.1.</span> <span class="toc-text"> 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#插入操作"><span class="toc-number">1.4.1.1.</span> <span class="toc-text"> 插入操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#实现-2"><span class="toc-number">1.4.1.1.1.</span> <span class="toc-text"> 实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#删除操作"><span class="toc-number">1.4.1.2.</span> <span class="toc-text"> 删除操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#实现-3"><span class="toc-number">1.4.1.2.1.</span> <span class="toc-text"> 实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34重构"><span class="toc-number">1.4.2.</span> <span class="toc-text"> 3+4重构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#实现-4"><span class="toc-number">1.4.2.1.</span> <span class="toc-text"> 实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#avl树性能"><span class="toc-number">1.4.3.</span> <span class="toc-text"> AVL树性能</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.jpg"></div><div class="author-info__name text-center">NYY</div><div class="author-info__description text-center"></div><div class="follow-button"><a href="https://github.com/niuyuanyuanna">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">48</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">37</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">10</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://www.ouyangsong.com">欧阳松的博客</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://github.com/niuyuanyuanna/BlogImages/raw/master/background/data_structure.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">NYY's blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">数据结构之二叉搜索树</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-04-06</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Data-Structure/">Data Structure</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2018/04/06/data_structure/dataStructureBST/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2018/04/06/data_structure/dataStructureBST/"></span></a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">3,743</span><span class="post-meta__separator">|</span><span>Reading time: 14 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="二叉搜索树"><a class="markdownIt-Anchor" href="#二叉搜索树"></a> 二叉搜索树</h1>
<!-- hexo-inject:begin --><!-- hexo-inject:end --><h2 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h2>
<h3 id="循关键码访问"><a class="markdownIt-Anchor" href="#循关键码访问"></a> 循关键码访问</h3>
<p>数据各项之间，依照各自的关键码彼此区分。其中关键码需要满足以下条件</p>
<ul>
<li>大小比较</li>
<li>相等比对</li>
</ul>
<p>数据集合中的数据项统一表示和实现为词条（entry）形式<br>
词条：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt; <span class="class"><span class="keyword">struct</span> <span class="title">Entry</span>&#123;</span></span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry(K k=K(), V v=V()):key(k), value(v)&#123;&#125;;   <span class="comment">//默认构造函数</span></span><br><span class="line">    Entry(Entry&lt;K, V&gt; <span class="keyword">const</span> &amp; e):key(e.key), value(e.value)&#123;&#125;;  <span class="comment">// 克隆比较器、判断器</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (Entry&lt;K, V&gt; <span class="keyword">const</span> &amp; e)&#123;<span class="keyword">return</span> key &lt; e.key&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt; (Entry&lt;K, V&gt; <span class="keyword">const</span> &amp; e)&#123;<span class="keyword">return</span> key &gt; e.key&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>== (Entry&lt;K, V&gt; <span class="keyword">const</span> &amp; e)&#123;<span class="keyword">return</span> key == e.key&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!= (Entry&lt;K, V&gt; <span class="keyword">const</span> &amp; e)&#123;<span class="keyword">return</span> key != e.key&#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="bst"><a class="markdownIt-Anchor" href="#bst"></a> BST</h3>
<p>二叉搜索树（Binary Search Tree）首先是一颗二叉树，其次处处满足顺序性，即它的任一节点不小于其左后代或任一节点不大于其右后代。</p>
<ul>
<li>顺序性：为局部的特征，但考察BST的中序遍历时可以发现它必然是单调非降的。</li>
<li>这一性质是BST的充要条件</li>
</ul>
<p>例如下面的一颗BST</p>
<center>
<img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/dataStructure/48098822.jpg" width="75%/">
</center>
<p>根据中序遍历的顺序，列出访问的节点，可以看出其值为单调递增的。</p>
<h4 id="bst模板"><a class="markdownIt-Anchor" href="#bst模板"></a> BST模板</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">BST</span>:</span><span class="keyword">public</span> BinTree&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span>:          <span class="comment">// virtual修饰，便于派生类重写</span></span><br><span class="line">    	<span class="function"><span class="keyword">virtual</span> <span class="title">BinNodePosi</span><span class="params">(T)</span> &amp; <span class="title">search</span><span class="params">(<span class="keyword">const</span> T &amp;)</span></span>;  <span class="comment">// 查找</span></span><br><span class="line">    	<span class="function"><span class="keyword">virtual</span> <span class="title">BinNodePosi</span><span class="params">(T)</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> T &amp;)</span></span>;    <span class="comment">// 插入</span></span><br><span class="line">    	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> T &amp;)</span></span>;              <span class="comment">// 删除</span></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    	BinNodePosi(T) _hot;                         <span class="comment">// 命中节点的父亲</span></span><br><span class="line">    	BinNodePosi(T) connect34(                    <span class="comment">// 3+4重构</span></span><br><span class="line">    		BinNodePosi(T), BinNodePosi(T), BinNodePosi(T),</span><br><span class="line">    		BinNodePosi(T), BinNodePosi(T), BinNodePosi(T), BinNodePosi(T));</span><br><span class="line">    	BinNodePosi(T) rotateAt(BinNodePosi(T));     <span class="comment">// 旋转调整    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="算法实现"><a class="markdownIt-Anchor" href="#算法实现"></a> 算法实现</h2>
<h3 id="查找"><a class="markdownIt-Anchor" href="#查找"></a> 查找</h3>
<p>使用减而治之的方法，从根节点出发，逐步缩小查找范围，直到发现目标，或查找到空树，查找失败。</p>
<center>
<img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/dataStructure/73352075.jpg" width="75%/">
</center>
<p>上面的例子需要查找到23，箭头方向表明了查找的路径，最后查找到了叶节点22，因此查找失败。整个过程可以视为在仿效有序向量的二分查找。</p>
<h4 id="实现方法一"><a class="markdownIt-Anchor" href="#实现方法一"></a> 实现方法一：</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">BinNodePosi(T) &amp; BST&lt;T&gt;::search(<span class="keyword">const</span> T &amp; e)&#123;</span><br><span class="line">    <span class="keyword">return</span> searchIn(_root, e, _hot = <span class="literal">NULL</span>);          <span class="comment">// 从根节点启动查找</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 尾递归，可以更改为迭代操作</span></span><br><span class="line"><span class="comment">// v是当前树根节点</span></span><br><span class="line"><span class="comment">// e是目标关键码</span></span><br><span class="line"><span class="comment">// hot为记忆热点</span></span><br><span class="line">static BinNodePosi(T) &amp; searchIn(BinNodePosi(T) &amp; v, const T &amp; e, BinNodePosi(T) &amp; hot)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!v || (e == v-&gt;data))      <span class="comment">// 当前子树已经为空则返回失败</span></span><br><span class="line">    	<span class="keyword">return</span> v;</span><br><span class="line">    hot = v;</span><br><span class="line">    <span class="keyword">return</span> searchIn((e &lt; v-&gt;data ? v-&gt;lChild : v-&gt;rChild), e, hot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>算法每递归一次，子树都会下降一层，因此其运行的时间正比于返回节点v的深度，但不超过树高，则耗时为：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>h</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mclose">)</span></span></span></span></p>
<h4 id="查找接口语义"><a class="markdownIt-Anchor" href="#查找接口语义"></a> 查找接口语义</h4>
<ul>
<li>返回值引用
<ul>
<li>成功时：指向一个关键码为e且真实存在的节点，<code>_hot</code>指向返回命中节点的父亲</li>
<li>失败时：指向最后一次试图转向空节点NULL，<code>_hot</code>指向最后一次转向的真实节点</li>
</ul>
</li>
</ul>
<p>空节点意思是其数值为NULL</p>
<ul>
<li>在失败时，可以假象那个空节点为哨兵节点，并将其关键值假象为目标关键码</li>
<li>引入假象哨兵后，相当于返回值总是等效于命中节点，<code>_hot</code>总是指向命中节点的父亲</li>
</ul>
<h3 id="插入"><a class="markdownIt-Anchor" href="#插入"></a> 插入</h3>
<h4 id="过程"><a class="markdownIt-Anchor" href="#过程"></a> 过程：</h4>
<ul>
<li>借助<code>search(e)</code>确定插入位置和方向，再将新节点作为叶子插入</li>
<li>若e不存在
<ul>
<li><code>_hot</code>为新节点的父亲</li>
<li><code>v = search(e)</code>为<code>_hot</code>对新孩子的引用</li>
</ul>
</li>
<li>令<code>_hot</code>通过v指向新节点</li>
</ul>
<h4 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; BinNodePosi(T) BST&lt;T&gt;::insert(<span class="keyword">const</span> T &amp; e)&#123;</span><br><span class="line">    BinNodePosi(T) &amp; x = search(e);      <span class="comment">// 查找目标</span></span><br><span class="line">    <span class="keyword">if</span>(!x)&#123;                              <span class="comment">// 查找目标为空，即查找失败</span></span><br><span class="line">        x = <span class="keyword">new</span> BinNode&lt;T&gt;(e, _hot);     <span class="comment">// 在x处创建新节点，并以_hot为父亲</span></span><br><span class="line">        _size++;                         <span class="comment">// 更新全树规模</span></span><br><span class="line">        updateHeightAbouve(x);           <span class="comment">// 更新x及历代祖先的高度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此算法主要的时间消耗在于<code>search(e)</code>和<code>updateHeightAbove(x)</code>两个函数都线性正比于返回节点x的深度，不超过树高<code>O(h)</code>。</p>
<h3 id="删除"><a class="markdownIt-Anchor" href="#删除"></a> 删除</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">bool</span> BST&lt;T&gt;::remove(<span class="keyword">const</span> T &amp; e)&#123;</span><br><span class="line">    BinNodePosi(T) &amp; x = search(e);      <span class="comment">// 定位目标节点</span></span><br><span class="line">    <span class="keyword">if</span>(!x)                               <span class="comment">// 忽略元素尚不存在的情况</span></span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    removeAt(x, _hot);</span><br><span class="line">    _size--;</span><br><span class="line">    updateHeightAbove(_hot);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此算法在不考虑<code>removeAt(x, _hot)</code>时，时间主要消耗仍然在于<code>search(e)</code>和<code>updateHeightAbove(x)</code>，累计的时间消耗也是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>h</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mclose">)</span></span></span></span>。接下来考虑<code>removeAt(x, _hot)</code>的情况</p>
<h4 id="情况一"><a class="markdownIt-Anchor" href="#情况一"></a> 情况一</h4>
<p>如果删除的节点还有左孩子或者右孩子，只需要将对象删除，并且以它的子节点作为新进节点替代被删除的节点。这样可以保持BST的拓扑结构，也满足顺序性。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">static</span> <span class="title">BinNodePosi</span><span class="params">(T)</span></span></span><br><span class="line">removeAt(BinNodePosi(T) &amp; x, BinNodePosi(T) &amp; hot)&#123;</span><br><span class="line">    BinNodePosi(T) w = x;                   <span class="comment">// 实际被删除的节点</span></span><br><span class="line">    BinNodePosi(T) succ = <span class="literal">NULL</span>:             <span class="comment">// 被删除节点的替代</span></span><br><span class="line">    <span class="keyword">if</span>(!HasLChild(*x))                      <span class="comment">// 左子树为空</span></span><br><span class="line">    	succ = x = x-&gt;rChild;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!HasRChild(*x))                 <span class="comment">// 右子树为空</span></span><br><span class="line">    	succ = x = x-&gt;lChild;</span><br><span class="line">    <span class="keyword">else</span>&#123;                                   </span><br><span class="line">        <span class="comment">/******左右子树并存**********/</span></span><br><span class="line">    &#125;</span><br><span class="line">    hot = w-&gt;parent;                        <span class="comment">// 被删除节点的父亲</span></span><br><span class="line">    <span class="keyword">if</span>(succ)</span><br><span class="line">    	succ-&gt;parent = hot;</span><br><span class="line">    release(w-&gt;data);                       <span class="comment">// 释放别删除节点</span></span><br><span class="line">    release(w);</span><br><span class="line">    <span class="keyword">return</span> succ;                            <span class="comment">// 返回替代节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这种情况下，只需要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>的时间。当左右孩子都为空时，<code>succ</code>指向<code>NULL</code>，上面的代码仍然正确。</p>
<h4 id="情况二"><a class="markdownIt-Anchor" href="#情况二"></a> 情况二</h4>
<p>当左右孩子并存的时候，需要化繁为简。此处需要用到在二叉树中实现的一个接口<code>BinNode::succ()</code>该接口的作用是返回当前节点在中序遍历下的直接后继。找到之后将当前需要删除的节点和其直接后继调换位置，这时是一个中间状态，已经不再是一颗BST了。最后删除在直接后继位置处的目标节点，完成节点删除，重新变成一颗BST。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">static</span> <span class="title">BinNodePosi</span><span class="params">(T)</span></span></span><br><span class="line">removeAt(BinNodePosi(T) &amp; x, BinNodePosi(T) &amp; hot)&#123;</span><br><span class="line">    <span class="comment">/*.........*/</span></span><br><span class="line">    <span class="keyword">else</span>&#123;     <span class="comment">// 左右子树均存在</span></span><br><span class="line">        w = w-&gt;succ();</span><br><span class="line">        swap(x-&gt;data, w-&gt;data);           <span class="comment">// *x与其直接后继*w互换数据   </span></span><br><span class="line">        BinNodePosi(T) u = w-&gt;parent;     <span class="comment">// 原问题转换为 摘除直接后继</span></span><br><span class="line">        (u == x ? u-&gt;rChild : u-&gt;lChild) = succ = w-&gt;rChild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*.........*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其直接后继至多只有一个右孩子，因为作为直接后继，它一定是某条分支的左侧末端 。此时的时间消耗主要在于<code>succ()</code>其正比于x的高度，因此<code>search()</code>和<code>succ()</code>共不超过<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>h</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mclose">)</span></span></span></span> 。</p>
<h2 id="平衡等价"><a class="markdownIt-Anchor" href="#平衡等价"></a> 平衡等价</h2>
<ul>
<li>
<p>BST主要接口的运行时间在最坏的情况下，线性正比于树高<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>h</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mclose">)</span></span></span></span></p>
</li>
<li>
<p>在最坏的情况下，BST可能退化为一个列表，此时的查找效率会降为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，线性正比于列表的规模</p>
</li>
</ul>
<h3 id="两种口径"><a class="markdownIt-Anchor" href="#两种口径"></a> 两种口径</h3>
<ol>
<li>随机生成</li>
</ol>
<p>对于n个互异的词条<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">{</mo><msub><mi>e</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>e</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>e</mi><mi>n</mi></msub><mo fence="true">}</mo></mrow><annotation encoding="application/x-tex">\left \{ e_{1},e_{2}, ....., e_{n} \right \}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">{</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">}</span></span></span></span></span>对任一排列<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>σ</mi><mo>=</mo><mrow><mo fence="true">{</mo><msub><mi>e</mi><mrow><mi>i</mi><mn>1</mn></mrow></msub><mo separator="true">,</mo><msub><mi>e</mi><mrow><mi>i</mi><mn>2</mn></mrow></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>e</mi><mrow><mi>i</mi><mi>n</mi></mrow></msub><mo fence="true">}</mo></mrow></mrow><annotation encoding="application/x-tex">\sigma = \left \{ e_{i1},e_{i2}, ....., e_{in} \right \}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">{</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">}</span></span></span></span></span>，从空树开始，反复调用<code>insert()</code>接口将各词条依次插入，得到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>(</mo><mi>σ</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">T(\sigma)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="mclose">)</span></span></span></span>，与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span></span></span></span>对应的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>(</mo><mi>σ</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">T(\sigma)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="mclose">)</span></span></span></span>称为由<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span></span></span></span>随机生成的BST。</p>
<ul>
<li>任一排列作为输入的概率均等，为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>1</mn><mrow><mi>n</mi><mo>!</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{n!}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mclose mtight">!</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li>
<li>由n个互异词条随机生成的BST平均高度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Θ</mi><mrow><mo fence="true">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\Theta \left ( logn \right )</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span>。</li>
</ul>
<ol start="2">
<li>随机组成</li>
</ol>
<p>对于n个互异的词条，在遵循顺序性的前提下，可随机确定拓扑连接关系。由此所得的BST称为这组词条的随机组成。</p>
<ul>
<li>由n个互异词条随机组成的BST，若共计<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">T(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>棵，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>c</mi><mi>a</mi><mi>t</mi><mi>a</mi><mi>l</mi><mi>a</mi><mi>n</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mi>S</mi><mi>P</mi><mo>(</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>⋅</mo><mi>S</mi><mi>P</mi><mo>(</mo><mi>n</mi><mo>−</mo><mi>k</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">T(n)=catalan(n)=\sum_{k=1}^{n}SP(k-1)\cdot SP(n-k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.104002em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>。</li>
<li>所有BST等概论出现，其平均高度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Θ</mi><mo>(</mo><msqrt><mi>n</mi></msqrt><mo>)</mo></mrow><annotation encoding="application/x-tex">\Theta(\sqrt{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.05028em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault">n</span></span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width="400em" height="1.08em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</li>
</ul>
<p>按照两种口径的平均性能，随机组成更为可信。因为在随机生成的过程中，不同的随机序列可能生成同一棵BST</p>
<h3 id="两种平衡"><a class="markdownIt-Anchor" href="#两种平衡"></a> 两种平衡</h3>
<ol>
<li>理想平衡</li>
</ol>
<ul>
<li>节点数目相对固定时，兄弟子树高度越接近平衡，全树也将倾向于更低。</li>
<li>由n个节点组成的二叉树，高度不低于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">log_{2}n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span></span></span></span>，当正好等于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">log_{2}n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span></span></span></span>时为理想平衡</li>
<li>理想平衡时相当于完全树甚至满树，此时条件太苛刻</li>
</ul>
<ol start="2">
<li>适度平衡</li>
</ol>
<ul>
<li>理想平衡出现概率极低，且维护成本过高，需要适当放松标准</li>
<li>高度渐进，不超过<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，称为适度平衡</li>
<li>适度平衡BST称为平衡二叉搜索树（BBST)</li>
</ul>
<h3 id="等价bst"><a class="markdownIt-Anchor" href="#等价bst"></a> 等价BST</h3>
<ul>
<li>上下可变：连接关系不尽相同，承袭关系可能颠倒</li>
<li>左右不乱：中序遍历序列完全一致，全局单调非降</li>
</ul>
<center>
<img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/dataStructure/21182931.jpg" width="75%/">
</center>
<p>如图这个例子可以看出其中序遍历序列完全相同，但其部分子序列拓扑结构并不相同。这样一对BST称为等价的BST。</p>
<p>对于各种BBST，将BST转换为BBST时，需要限制1. 单次动态修改操作后，至多<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>处局部不再满足限制条件，2. 可以在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>时间内，使得这些局部满足更新。</p>
<h2 id="avl树"><a class="markdownIt-Anchor" href="#avl树"></a> AVL树</h2>
<ul>
<li>AVL树是一种BBST，在AVL的标准下的平衡因子为<code>balFac(v) = height(lc(v)) - height(rc(v))</code></li>
<li>AVL树即是对任意的节点，其平衡因子都不超过1也不小于-1的BST。</li>
<li>AVL树是适度平衡的，其高度不超过<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li>
</ul>
<h3 id="接口"><a class="markdownIt-Anchor" href="#接口"></a> 接口</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># define Balanced(x) (stature((x).lChild) == stature((x).rChild))  // 理想平衡</span><br><span class="line"># define BalFac(x) (stature((x).lChild) - stature((x).rChild))     // 平衡因子</span><br><span class="line"># define AvlBalabced(x) ((-2 &lt; BalFac(x)) &amp;&amp; (BalFac(x) &lt; 2))      // AVL平衡条件</span><br><span class="line">template &lt;typename T&gt; class AVL:public BST&lt;T&gt; &#123;                    // 继承自BST</span><br><span class="line">    public:                                                        // 沿用BSF::search()接口</span><br><span class="line">    	BinNodePosi(T) insert(const T &amp;);                          // 插入重写</span><br><span class="line">    	bool remove(const T &amp;);                                    // 删除重写</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>
<p>在按照BST规则插入或删除节点后，AVL的平衡性会被破坏，因此需要借助等价变换</p>
<ul>
<li>局部性：所有旋转都在局部进行 （每次仅需要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>时间）</li>
<li>快速性：在每一深度只需检查并旋转至多一次 （共<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>次）</li>
</ul>
<h4 id="插入操作"><a class="markdownIt-Anchor" href="#插入操作"></a> 插入操作</h4>
<ol>
<li>单旋插入</li>
</ol>
<center>
<img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/dataStructure/85915049.jpg" width="75%/">
</center>
<p>如上图所示，如果需要在v下面插入左孩子或者右孩子，则需要让g单旋调整，具体过程为：</p>
<ul>
<li>引入临时引用，指向节点p</li>
<li>令p的左子树T1变为g的右子树</li>
<li>令g为p的左孩子</li>
<li>局部子树的根g替换为p</li>
</ul>
<p>操作完成之后，局部子树的高度恢复，其更高的祖先也必然是平衡的，使得全树复衡。</p>
<ol start="2">
<li>双旋插入</li>
</ol>
<center>
<img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/dataStructure/7993033.jpg" width="75%/">
</center>
<p>同时可有多个失衡及诶单，最低者g不低于x的祖父，g经过双旋调整后复衡，子树高度复原，其更高的祖先也必然是平衡的，使得全树复衡。</p>
<p>其过程为：</p>
<ul>
<li>围绕p顺时针旋转，<code>zig(p)</code>
<ul>
<li>引入临时变量，指向节点v</li>
<li>令v的右子树变为p的左子树</li>
<li>令p为v的右孩子</li>
<li>令g的右孩子为v</li>
</ul>
</li>
<li>围绕节点g做一次逆时针旋转，<code>zag(g)</code>
<ul>
<li>将临时变量指向节点v</li>
<li>令v的左子树变为g的右子树</li>
<li>令g为v的左孩子</li>
<li>局部子树的根由g替换为v</li>
</ul>
</li>
</ul>
<h5 id="实现-2"><a class="markdownIt-Anchor" href="#实现-2"></a> 实现</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; BinNodePosi(T) AVL&lt;T&gt;::insert(<span class="keyword">const</span> T &amp; e)&#123;</span><br><span class="line">    BinNodePosi(T) &amp; x = search(e);</span><br><span class="line">    <span class="keyword">if</span> (x)</span><br><span class="line">    	<span class="keyword">return</span> x;</span><br><span class="line">    BinNodePosi(T) xx = x = <span class="keyword">new</span> BinNode&lt;T&gt;(e, _hot);     <span class="comment">// 目标不存在则创建新节点</span></span><br><span class="line">    _size++;</span><br><span class="line">    <span class="comment">// 从x的父亲_hot出发，逐层向上，依次检查各代祖先g</span></span><br><span class="line">    <span class="keyword">for</span> (BinNodePosi(T) g = _hot; g; g = g-&gt;parent)&#123;</span><br><span class="line">        <span class="keyword">if</span> (! AvlBalanced(*g))&#123;                          <span class="comment">// 一旦失衡就进行调整</span></span><br><span class="line">            FromParentTo(*g) = rotateAt(tallerChild(tallerChild(g)));</span><br><span class="line">            <span class="keyword">break</span>;                                       <span class="comment">// 完成对v，p，g的调整后就退出循环</span></span><br><span class="line">        &#125;<span class="keyword">else</span>                                            <span class="comment">// 未失衡，就更新其高度</span></span><br><span class="line">        	updateHeight(g);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> xx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="删除操作"><a class="markdownIt-Anchor" href="#删除操作"></a> 删除操作</h4>
<ol>
<li>
<p>单旋删除</p>
<p>在图中这种情况下，g、p、v是朝同一个方向排列。将T3的一个叶节点删除，会引起g点失衡。因此需要围绕点g进行一次zig操作。</p>
</li>
</ol>
<center>
<img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/dataStructure/85320993.jpg" width="70%/">
</center>
<p>当T2最后的那个节点不存在，即调整后的子树高缩减了1，因此有可能引起更上一层的失衡，称为失衡传播现象，可能需要做<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>次调整。</p>
<ol start="2">
<li>
<p>双旋删除</p>
<p>在此图中，g、p、v并不是朝着同一个方向排列，此时删除T3的一个节点。</p>
</li>
</ol>
<center>
<img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/dataStructure/69399379.jpg" width="75%/">
</center>
<p>这种情况下首先要围绕p做一次zag旋转，再围绕g做一次zig旋转。</p>
<p>旋转完成后，情况和单旋类似，T1和T2这两棵子树可能其中一个会存在一个叶节点，那么旋转之后子树的高度缩减1，仍可能引起失衡，可能需要做<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>次调整。</p>
<h5 id="实现-3"><a class="markdownIt-Anchor" href="#实现-3"></a> 实现</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">bool</span> AVL&lt;T&gt;::remove(<span class="keyword">const</span> T &amp; e)&#123;</span><br><span class="line">    BinNodePosi(T) &amp; x = search(e);</span><br><span class="line">    <span class="keyword">if</span>(!x)</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    removeAt(x, _hot);                         <span class="comment">// x存在则删除x</span></span><br><span class="line">    size--;</span><br><span class="line">    <span class="comment">// 从_hot出发逐层向上，依次检查各代祖先</span></span><br><span class="line">    <span class="keyword">for</span> (BinNodePosi(T) g = _hot; g; g = g-&gt;parent)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!AvlBalanced(*g))</span><br><span class="line">        	g = FromParentTo(*g) = rotateAt(tallerChild(tallerChild(g)));</span><br><span class="line">        updateHeight(g);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中for循环可能要做<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Ω</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\Omega(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Ω</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>次调整</p>
<h3 id="34重构"><a class="markdownIt-Anchor" href="#34重构"></a> 3+4重构</h3>
<p>设g(x)为最低的失衡节点，考察祖孙三代：g、p、v，按照中序遍历次序，将其重命名为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>&lt;</mo><mi>b</mi><mo>&lt;</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a &lt; b &lt; c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>。则他们共拥有互不相交的四棵（可能为空）的子树，按照中序遍历次序命名为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mn>0</mn></msub><mo>&lt;</mo><msub><mi>T</mi><mn>1</mn></msub><mo>&lt;</mo><msub><mi>T</mi><mn>2</mn></msub><mo>&lt;</mo><msub><mi>T</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">T_{0}&lt; T_{1} &lt; T_{2} &lt; T_{3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。将原来以g为根的子树替换为一颗新的子树<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>S</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">S&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>。</p>
<center>
<img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/dataStructure/64989590.jpg" width="30%/">
</center>
<h4 id="实现-4"><a class="markdownIt-Anchor" href="#实现-4"></a> 实现</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; BinNodePosi(T) BST&lt;T&gt;::connect34(</span><br><span class="line">	BinNodePosi(T) a, BinNodePosi(T) b, BinNodePosi(T) c,</span><br><span class="line">	BinNodePosi(T) T0, BinNodePosi(T) T1, BinNodePosi(T) T2, BinNodePosi(T) T3,)&#123;</span><br><span class="line">        a-&gt;lChild = T0;</span><br><span class="line">        <span class="keyword">if</span> (T0) </span><br><span class="line">        	T0-&gt;parent = a;</span><br><span class="line">        a-&gt;rChild = T1;</span><br><span class="line">        <span class="keyword">if</span> (T1)&#123;</span><br><span class="line">            T1-&gt;parent = a;</span><br><span class="line">            updateHeight(a);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        c-&gt;lChild = T2;</span><br><span class="line">        <span class="keyword">if</span> (T2) </span><br><span class="line">        	T2-&gt;parent = c;</span><br><span class="line">        c-&gt;rChild = T3;</span><br><span class="line">        <span class="keyword">if</span> (T3)&#123;</span><br><span class="line">            T3-&gt;parent = c;</span><br><span class="line">            updateHeight(c);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        b-&gt;lChild = a;</span><br><span class="line">        a-&gt;parent = b;</span><br><span class="line">        b-&gt;rChild = c;</span><br><span class="line">        c-&gt;parent = b;</span><br><span class="line">        updateHeight(b);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> b;                  <span class="comment">//返回子树新的根节点</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>将<code>rotateAt()</code>完整化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;typenmae T&gt; BinNodePosi(T) BST&lt;T&gt;::rotateAt(BinNodePosi(T) v)&#123;</span><br><span class="line">    BinNodePosi(T) p = v-&gt;parent;</span><br><span class="line">    g = p-&gt;parent;</span><br><span class="line">    <span class="keyword">if</span>(IsLChild(*p))&#123;                    <span class="comment">// zig</span></span><br><span class="line">        <span class="keyword">if</span>(IsLChild(*v))&#123;                <span class="comment">// zig-zig</span></span><br><span class="line">            p-&gt;parent = g-&gt;parent;</span><br><span class="line">            <span class="keyword">return</span> connect34(v, p, g, v-&gt;lChild, v-&gt;rChild, p-&gt;rChild, g-&gt;rChild);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;                           <span class="comment">// zig-zag</span></span><br><span class="line">            v-&gt;parent = g-&gt;parent;</span><br><span class="line">            <span class="keyword">return</span> connect34(p, v, g, p-&gt;lChild, v-&gt;lChild, v-&gt;rChild, g-&gt;rChild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;                               <span class="comment">// zag</span></span><br><span class="line">        <span class="keyword">if</span>(IsRChild(*v))&#123;                <span class="comment">// zag-zag</span></span><br><span class="line">            p-&gt;parent = g-&gt;parent;</span><br><span class="line">            <span class="keyword">return</span> connect34(g, p, v, g-&gt;lChild, p-&gt;lChild, v-&gt;lChild, v-&gt;rChild);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;                           <span class="comment">// zag-zig</span></span><br><span class="line">            v-&gt;parent = g-&gt;parent;</span><br><span class="line">            <span class="keyword">return</span> connect34(g, v, p, g-&gt;lChild, v-&gt;lChild, v-&gt;rChild, p-&gt;rChild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>zig-zig 和zig-zag分别对应于：</p>
<center>
<img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/dataStructure/88247417.jpg" width="30%/">
</center>
<p>剩下两种情况恰好与之相反。</p>
<h3 id="avl树性能"><a class="markdownIt-Anchor" href="#avl树性能"></a> AVL树性能</h3>
<p>优点：</p>
<ul>
<li>无论查找、插入或删除，最坏情况下的复杂度均为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，存储空间为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li>
</ul>
<p>缺点：</p>
<ul>
<li>
<p>引入平衡因子，需要改造元素结构或者进行额外封装</p>
</li>
<li>
<p>其实测性能和理论性能差距较大</p>
<ul>
<li>
<p>插入删除时的zig，zag成本高</p>
</li>
<li>
<p>删除操作最多需要旋转<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Ω</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\Omega(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Ω</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>次，若频繁插入或删除成本过高。、</p>
</li>
</ul>
</li>
<li>
<p>单次动态调整后，全树拓扑结构变化量可能达到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Ω</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\Omega(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Ω</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
</li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">NYY</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2018/04/06/data_structure/dataStructureBST/">http://yoursite.com/2018/04/06/data_structure/dataStructureBST/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a><a class="post-meta__tags" href="/tags/数据结构/">数据结构</a></div><div class="social-share"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2018/04/18/data_structure/dataStructureGraph/"><i class="fa fa-chevron-left">  </i><span>数据结构之图</span></a></div><div class="next-post pull-right"><a href="/2018/04/06/data_structure/dataStructureBinaryTree/"><span>数据结构之二叉树</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'http://yoursite.com/2018/04/06/data_structure/dataStructureBST/';
  this.page.identifier = '2018/04/06/data_structure/dataStructureBST/';
  this.page.title = '数据结构之二叉搜索树';
}
var d = document, s = d.createElement('script');
s.src = "https://" + 'niuyuanyuan' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://niuyuanyuan.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://github.com/niuyuanyuanna/BlogImages/raw/master/background/data_structure.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2019 By NYY</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end --></body></html>