<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="数据结构之二叉树"><meta name="keywords" content="数据结构,C++"><meta name="author" content="NYY,undefined"><meta name="copyright" content="NYY"><title>数据结构之二叉树 | NYY's blog</title><link rel="shortcut icon" href="/icon1.png"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.1"><script>var GLOBAL = { 
  root: '/',
  algolia: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  localSearch: undefined
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#二叉树"><span class="toc-number">1.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#树"><span class="toc-number">1.1.</span> <span class="toc-text">树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#树的基本概念"><span class="toc-number">1.1.1.</span> <span class="toc-text">树的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#树结构特性"><span class="toc-number">1.1.2.</span> <span class="toc-text">树结构特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#连通性"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">连通性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#无环性"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">无环性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#树特性"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">树特性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#树的表示"><span class="toc-number">1.1.3.</span> <span class="toc-text">树的表示</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二叉树-1"><span class="toc-number">1.2.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本特性"><span class="toc-number">1.2.1.</span> <span class="toc-text">基本特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉树的实现"><span class="toc-number">1.2.2.</span> <span class="toc-text">二叉树的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉树相关算法"><span class="toc-number">1.2.3.</span> <span class="toc-text">二叉树相关算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#遍历"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#重构"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">重构</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://i.loli.net/2018/04/05/5ac5c474e8082.jpg"></div><div class="author-info__name text-center">NYY</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">8</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">4</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">1</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://i.loli.net/2018/04/06/5ac71e2919b53.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">NYY's blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">数据结构之二叉树</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-04-06</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Algorithm/">Algorithm</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2018/04/06/dataStructureBinaryTree/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2018/04/06/dataStructureBinaryTree/"></span></a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">2,835</span><span class="post-meta__separator">|</span><span>Reading time: 11 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div id="post-content"><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><ul>
<li>向量的search操作效率较高，如二分查找，其效率可以达到$log(n)$，但其动态操作，无论是插入和删除，其效率都较低，需要线性的时间。</li>
<li>列表的search操作，其效率较低，需要线性的时间，但由于其循位置访问的方式，一旦给定具体的操作位置，对于列表的动态操作就只需要在局部进行，时间损耗为$O(1)$。</li>
<li>二叉树结合了向量和列表的优点，可以理解为二维的列表。将树形结构称为半线性结构。</li>
</ul>
<h3 id="树的基本概念"><a href="#树的基本概念" class="headerlink" title="树的基本概念"></a>树的基本概念</h3><ol>
<li>树： 在树型结构中，彼此元素之间的关系为edge，顶点为vertex，区别于列表中的node。需要为每一棵树指定一个特殊的顶点，称为根(root)。</li>
<li>有根树：指定了其中一个顶点作为根的树。通过彼此的嵌套，小型的有根树可以逐步地整合为规模更大的有根树。</li>
<li>兄弟树(sibling)：同一棵树的子树，它们之间根据度（degree）来度量。</li>
<li>度数、顶点、边数间的关系：顶点的度数之和 = 边数 = 顶点总数-1。度数和顶点数同阶，因此在考虑算法时间复杂度时，以顶点数n作为参照。</li>
<li>有序树：对有同一个父顶点的兄弟树编号，此时的这些兄弟树都是有序树。</li>
</ol>
<h3 id="树结构特性"><a href="#树结构特性" class="headerlink" title="树结构特性"></a>树结构特性</h3><h4 id="连通性"><a href="#连通性" class="headerlink" title="连通性"></a>连通性</h4><p>k+1个节点通过k条边依次相连，构成一条路径。其路径长度=边数。<br>连通图（connected）：节点之间均有路径</p>
<h4 id="无环性"><a href="#无环性" class="headerlink" title="无环性"></a>无环性</h4><p>当第1个节点和第k+1个节点相连时，构成一个环路（loop）<br>无环图（acyclic）：不含环路的图</p>
<h4 id="树特性"><a href="#树特性" class="headerlink" title="树特性"></a>树特性</h4><ul>
<li>无环连通图</li>
<li>极小连通图</li>
<li>极大无环图</li>
</ul>
<p>任一节点v与根之间存在唯一路径。因此一旦确定了根之后，所有的节点都可以根据这条唯一的路径定义一个参数depth，即v在这颗树中的深度。定义在path(v)上的节点为v的祖先（ancestor），v是它们的后代（descendent）。</p>
<ul>
<li>半线性：在任意深度v的祖先 / 后代存在，则必然 / 未必唯一。</li>
</ul>
<p>没有后代的节点称为叶子（leaf），所有叶子中深度最大的为树的高度，子树的高度也就是其根节点的深度。</p>
<h3 id="树的表示"><a href="#树的表示" class="headerlink" title="树的表示"></a>树的表示</h3><p>树结构的接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root()           根节点</span><br><span class="line">parent()         父节点</span><br><span class="line">firstChild()     长子</span><br><span class="line">nextSibling()    兄弟</span><br><span class="line">insert(i, e)     将e作为第i个孩子插入</span><br><span class="line">remove(i)        删除第i个孩子（及其后代）</span><br><span class="line">traverse()       遍历</span><br></pre></td></tr></table></figure></p>
<p>由于每个节点只有一个父节的特性，在向上查询时，可以取得很好的效果，但在向下查询时需要遍历所有节点。在表格中增加子节点的信息，使得向下查找只需遍历当前节点的子节点。</p>
<p><img src="http://p6um59a45.bkt.clouddn.com/18-4-8/65826164.jpg" alt=""></p>
<p>但是这样操作对于子节点仍然有些多余，因此考虑将子节点查找的结构变为：</p>
<p><img src="http://p6um59a45.bkt.clouddn.com/18-4-8/70722176.jpg" alt=""></p>
<p>每个节点均设置两个引用，横纵坐标方向为firstChild()，纵坐标方向为nextSibling()。</p>
<h2 id="二叉树-1"><a href="#二叉树-1" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树是节点度数不超过2的树，同一节点的孩子和子树用左右进行区分表示为：</p>
<ul>
<li>lChild()     ——   lSubtree()</li>
<li>rChiled()  ——   rSubtree()<br>这里已经隐含了树的有序性。</li>
</ul>
<h3 id="基本特性"><a href="#基本特性" class="headerlink" title="基本特性"></a>基本特性</h3><ul>
<li>所有深度为k的节点最多不超过$2^{k}$个</li>
<li>含有n个节点，高度为h的二叉树中，其数量关系为：$h&lt;n&lt;2^{h+1}$<ul>
<li>当$n=h+1$时，二叉树退化为一条单链</li>
<li>当$n=2^{h+1}-1$时，得到满二叉树(full binary tree)即所有节点的度数都是2</li>
</ul>
</li>
</ul>
<p>对于二叉树而言，其宽度随高度呈指数增长，称为涨宽。</p>
<ul>
<li>真二叉树：对于只有单分支或者叶子节点添加一个或2个对应数据为0的孩子，将这个二叉树变为一个满二叉树。<br><img src="http://p6um59a45.bkt.clouddn.com/18-4-8/51267035.jpg" alt=""></li>
</ul>
<p>二叉树可以描述任意一颗树，将任意一棵树用长子-兄弟法表示。多出的兄弟节点可以用兄弟节点的子节点表示。<br><img src="http://p6um59a45.bkt.clouddn.com/18-4-8/13837723.jpg" alt=""></p>
<h3 id="二叉树的实现"><a href="#二叉树的实现" class="headerlink" title="二叉树的实现"></a>二叉树的实现</h3><p>二叉树的基本组成单位是binary node。<br>BinNode模板类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># define BinNodePosi(T) BinNode&lt;T&gt;*   //节点位置</span><br><span class="line">template &lt;typename T&gt; struct BinNode&#123;</span><br><span class="line">    BinNodePosi(T) parent, lChild, rChild;</span><br><span class="line">    T data;</span><br><span class="line">    int height;  //高度</span><br><span class="line">    int size();  //子树规模</span><br><span class="line">    BinNodePosi(T) insertAsLC(T const &amp;);                 //作为左孩子插入</span><br><span class="line">    BinNodePosi(T) insertAsRC(T const &amp;);                 //作为右孩子插入</span><br><span class="line">    BinNodePosi(T) succ();                                //当前节点的直接后继</span><br><span class="line">    template &lt;typename VST&gt; void travLevel(VST &amp;);        //子树层次遍历</span><br><span class="line">    template &lt;typename VST&gt; void travPre(VST &amp;);          //子树先序遍历</span><br><span class="line">    template &lt;typename VST&gt; void travIn(VST &amp;);           //子树中序遍历</span><br><span class="line">    template &lt;typename VST&gt; void travPost(VST &amp;);        //子树后序遍历</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BinNode接口实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">BinNodePosi(T) BinNode&lt;T&gt;::insertAsLC(T const &amp; e)&#123;</span><br><span class="line">    return lChild = new BinNode(e, this);   // this.lChild = null</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">BinNodePosi(T) BinNode&lt;T&gt;::insertAsRC(T const &amp; e)&#123;  //只需要常数时间</span><br><span class="line">    return rChild = new BinNode(e, this);   // this.rChild = null</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;   </span><br><span class="line">int BinNode&lt;T&gt;::size()&#123;          //后代的总数是其根的子树之和。递归统计子树规模，需要线性时间</span><br><span class="line">    int s = 1;</span><br><span class="line">    if(lChild)&#123;</span><br><span class="line">        s += lChild-&gt;size();</span><br><span class="line">    &#125;</span><br><span class="line">    if(rChild)&#123;</span><br><span class="line">        s += rChild-&gt;size();</span><br><span class="line">    &#125;</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>BinTree模板：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt; class BinTree&#123;</span><br><span class="line">    protected:</span><br><span class="line">        int _size;</span><br><span class="line">        BinNodePosi(T) _root; //根节点</span><br><span class="line">        virtual int updateHeight(BinNodePosi(T) x);  //更新节点x高度</span><br><span class="line">        void updateHeightAbove(BinNodePosi(T) x);    //更新x及祖先高度</span><br><span class="line">    public:</span><br><span class="line">        int size() const&#123;return _size;&#125;              //国模</span><br><span class="line">        bool empty() const&#123;return !_root;&#125;           //判断是否为空树</span><br><span class="line">        BinNodePosi(T) root() const&#123;return _root;&#125;   //返回树根</span><br><span class="line">        /*子树接入、删除、分离接口*/</span><br><span class="line">        /*遍历接口  */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以高度更新接口为例：通过宏定义的封装方式高度，因为根据树的退化情况，其高度均不同。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># define stature(p) ((p) ? (p)-&gt;height : -1)</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">int BinTree&lt;T&gt;::updateHeight(BinNodePosi(T) x)&#123;</span><br><span class="line">    return x-&gt;height = 1 + max(stature(x-&gt;lChild), stature(x-&gt;rChild));   //采用常规二叉树规则，其时间复杂度为O(1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">void BinTree&lt;T&gt;::udateHeightAbouve(BinNodePosi(T) x)&#123;//向上更新节点高度，其时间复杂度正比于树的深度。</span><br><span class="line">    while(x)&#123;</span><br><span class="line">        updateHeight(x);</span><br><span class="line">        x = x-&gt;parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>节点插入：<br>在一个已有的树节点中，该节点原本没有右孩子。将新生成的一个节点插入到该节点的右侧，将其变为该节点的右孩子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt; </span><br><span class="line">BinNodePosi(T)BinTree&lt;T&gt;::insertAsRC(BinNoidePosi(T) x)&#123;</span><br><span class="line">    _size++;</span><br><span class="line">    x-&gt;insertAsRC(e);</span><br><span class="line">    updateHeightAbove(x);</span><br><span class="line">    return x-&gt;rChild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="二叉树相关算法"><a href="#二叉树相关算法" class="headerlink" title="二叉树相关算法"></a>二叉树相关算法</h3><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><p>按照某种次序访问数中的各个节点，使得每个节点被访问恰好一次。遍历分为先序、中序、后序，按照当前节点与其左右孩子节点的访问次序来划分。<br><img src="http://p6um59a45.bkt.clouddn.com/18-4-8/10018835.jpg" alt=""></p>
<ol>
<li>先序遍历，时间复杂度为$O(n)$<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T, typename VST&gt;</span><br><span class="line">void traverse(BinNodePosi(T) x, VST &amp; visit)&#123;</span><br><span class="line">    if(!x) return;  //先把树根节点取出访问再递归访问左右子节点</span><br><span class="line">    visit(x-&gt;data);</span><br><span class="line">    traverse(x-&gt;lChild, visit);</span><br><span class="line">    traverse(x-&gt;rChild, visit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>可以将尾递归的形式化简为迭代的形式，引入一个栈存储节点的位置。<br>第一种迭代方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T, typename VST&gt;</span><br><span class="line">void travPre_I1(BinNodePosi(T) x, VST &amp; visit)&#123;</span><br><span class="line">    Stack &lt;BinNodePosi(T)&gt; S;</span><br><span class="line">    if(x) S.push(x);</span><br><span class="line">    while(!S.empty())&#123;</span><br><span class="line">        x = S.pop();</span><br><span class="line">        visit(x-&gt;data);</span><br><span class="line">        if(HasRChild(*x)) S.push(x-&gt;rChild); //右孩子先入后出</span><br><span class="line">        if(HasLChild(*x)) S.push(x-&gt;lChild); //左孩子后入先出</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第一种迭代方法较难理解，不便于判断子节点的遍历次序，引入第二种迭代方法：<br><img src="http://p6um59a45.bkt.clouddn.com/18-4-8/51411613.jpg" alt=""><br>这种方法自上而下对做侧分支进行访问然后自下而上对右子树遍历。不同的右子树相互独立且自成一个子任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T, typename VST&gt;</span><br><span class="line">static void visitAlongLeftBranch(BinNodePosi(T) x, VST &amp; visit, Stack &lt;BinNodePosi(T)&gt; &amp; S)&#123;</span><br><span class="line">    while(x)&#123;</span><br><span class="line">        visit(x-&gt;rChild);   //访问当前节点</span><br><span class="line">        S.push(x-&gt;rChild);  //右孩子入栈</span><br><span class="line">        x = x-&gt;lChild;      //沿左侧链下行</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T, typename VST&gt;</span><br><span class="line">void travPre_I2(BinNodePosi(T) x, VST &amp; visit)&#123;</span><br><span class="line">    Stack &lt;BinNodePosi(T)&gt; S;</span><br><span class="line">    while(true)&#123;</span><br><span class="line">        visitAlongLeftBranch(x, visit, S);</span><br><span class="line">        if(S.empty()) break;</span><br><span class="line">        x = S.pop();      //弹出下一子树根</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>visitAlongLeftBranch()这个函数会从当前节点一直访问左侧链，并自下而上的将右子节点存入栈中。主循环只需要重复执行这个函数直到栈为空退出。</p>
<ol start="2">
<li>中序遍历<br>递归算法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T, typename VST&gt;</span><br><span class="line">void traverse(BinNodePosi(T) x, VST &amp; visit)&#123;</span><br><span class="line">    if(!x) return;  </span><br><span class="line">    traverse(x-&gt;lChild, visit);</span><br><span class="line">    visit(x-&gt;data);</span><br><span class="line">    traverse(x-&gt;rChild, visit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>根据观察可以发现中序遍历是从根节点开始沿左侧分支向下，直到找到最后一个左孩子，访问左孩子后再访问上层节点，最后访问该上层节点的右孩子。<br><img src="http://p6um59a45.bkt.clouddn.com/18-4-8/99511231.jpg" alt=""><br>迭代算法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">static void goAlongLeftBranch(BinNodePosi(T) x, Stack &lt;BinNodePosi(T)&gt; &amp; S)&#123;</span><br><span class="line">    while(x)&#123;</span><br><span class="line">        //visit(x-&gt;rChild);   //访问当前节点</span><br><span class="line">        //S.push(x-&gt;rChild);  //右孩子入栈</span><br><span class="line">        S.push(x);</span><br><span class="line">        x = x-&gt;lChild;      //沿左侧链下行</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T, typename VST&gt;</span><br><span class="line">void trav_I1(BinNodePosi(T) x, VST &amp; visit)&#123;</span><br><span class="line">    Stack &lt;BinNodePosi(T)&gt; S;</span><br><span class="line">    while(true)&#123;</span><br><span class="line">        goAlongLeftBranch(x, S);</span><br><span class="line">        if(S.empty()) break;</span><br><span class="line">        x = S.pop();      //左侧节点访问</span><br><span class="line">        visit(x-&gt;data);</span><br><span class="line">        x = x-&gt;rChild;    //转向右子树，当右子树为空时进行处理。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>goAlongLeftBranch（）函数从当前节点出发，逐批将左侧节点逆序入栈，直到找到最左侧节点。在主函数中弹出栈顶节点，进行访问后再转向右子树。最终主程序的时间复杂度为$O(n)$。</p>
<ol start="3">
<li>后续遍历<br>递归算法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T, typename VST&gt;</span><br><span class="line">void traverse(BinNodePosi(T) x, VST &amp; visit)&#123;</span><br><span class="line">    if(!x) return;  </span><br><span class="line">    traverse(x-&gt;lChild, visit);</span><br><span class="line">    traverse(x-&gt;rChild, visit);</span><br><span class="line">    visit(x-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="http://p6um59a45.bkt.clouddn.com/18-4-8/66214575.jpg" alt=""><br>在后序遍历的过程中，从左侧链最后一个节点开始，再访问其右子节点，再自下而上访问其父节点。<br>迭代算法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">static void gotoHLVFL(Stack &lt;BinNodePosi(T)&gt; &amp; S)&#123;</span><br><span class="line">    while(BinNodePosi(T) x= S.top())&#123;</span><br><span class="line">        if(HasLChild(*x))&#123;</span><br><span class="line">            if(HasRChild(*x)) S.push(x-&gt;rChild);</span><br><span class="line">            S.push(x-&gt;lChild);</span><br><span class="line">        &#125;else</span><br><span class="line">            S.push(x-&gt;rChild);</span><br><span class="line">    S.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T, typename VST&gt;</span><br><span class="line">void travPost_I(BinNodePosi(T) x, VST &amp; visit)&#123;</span><br><span class="line">    Stack &lt;BinNodePosi(T)&gt; S;</span><br><span class="line">    if(x) S.push(x);</span><br><span class="line">    while(!S.empth())&#123;</span><br><span class="line">        if(S.top()!=x-&gt;parent) gotoHLVFL(S);</span><br><span class="line">        x = S.pop();      //左侧节点访问</span><br><span class="line">        visit(x-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol start="4">
<li>层次遍历<br>上面的三种遍历方式都存在子节点先于父节点接受访问的逆序情况，因此使用栈进行存储。对于层次遍历而言，所有子节点都应严格的后于父节点接受访问，即为顺序对每层访问，需要用到队列。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T, typename VST&gt;</span><br><span class="line">void BinNode&lt;T&gt;::travPost_I( VST &amp; visit)&#123;</span><br><span class="line">    Queue&lt;BinNodePosi(T)&gt; Q;</span><br><span class="line">    Q.enqueue(this);</span><br><span class="line">    while(!Q.empty())&#123;</span><br><span class="line">        BinNodePosi(T) x = Q.dequeue();          //取出队首节点并访问</span><br><span class="line">        visit(x-&gt;data);</span><br><span class="line">        if(HasLChild(*x) Q.enqueue(x-&gt;lChild));  //左孩子入队</span><br><span class="line">        if(HasRChild(*x) Q.enqueue(x-&gt;rChild));  //右孩子入队</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>每个节点入队、出队的操作恰好为1次，整体的时间复杂度为$O(n)$</p>
<h4 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h4><p>已知二叉树的排列序列，还原出二叉树。<br>已知树的中序 + 先序/后序 即可还原出原始的二叉树。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">NYY</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2018/04/06/dataStructureBinaryTree/">http://yoursite.com/2018/04/06/dataStructureBinaryTree/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/数据结构/">数据结构</a><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="social-share"></div><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2018/04/06/binary_search_tree/"><i class="fa fa-chevron-left">  </i><span>数据结构之二叉搜索树</span></a></div><div class="next-post pull-right"><a href="/2018/04/06/dataStructureStackAndQueue/"><span>数据结构之栈和队列</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var disqus_shortname = 'niuyuanyuan'
var disqus_config = function () {
  this.page.url = 'http://yoursite.com/2018/04/06/dataStructureBinaryTree/';
  this.page.identifier = '2018/04/06/dataStructureBinaryTree/';
  this.page.title = '数据结构之二叉树';
}
var d = document, s = d.createElement('script');
s.src = "https://" + disqus_shortname +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-src" src="https://niuyuanyuan.disqus.com/count.js" async></script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2017 - 2018 By NYY</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.1"></script><script src="/js/fancybox.js?version=1.5.1"></script><script src="/js/sidebar.js?version=1.5.1"></script><script src="/js/copy.js?version=1.5.1"></script><script src="/js/fireworks.js?version=1.5.1"></script><script src="/js/transition.js?version=1.5.1"></script><script src="/js/scroll.js?version=1.5.1"></script><script src="/js/head.js?version=1.5.1"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>