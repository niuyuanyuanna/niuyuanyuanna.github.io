<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="数据结构之二叉搜索树"><meta name="keywords" content="数据结构,C++"><meta name="author" content="NYY,undefined"><meta name="copyright" content="NYY"><title>数据结构之二叉搜索树 | NYY's blog</title><link rel="shortcut icon" href="/icon1.png"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.1"><script>var GLOBAL = { 
  root: '/',
  algolia: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  localSearch: undefined
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#二叉搜索树"><span class="toc-number">1.</span> <span class="toc-text">二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#概念"><span class="toc-number">1.1.</span> <span class="toc-text">概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#循关键码访问"><span class="toc-number">1.1.1.</span> <span class="toc-text">循关键码访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BST"><span class="toc-number">1.1.2.</span> <span class="toc-text">BST</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BST模板"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">BST模板</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#算法实现"><span class="toc-number">1.2.</span> <span class="toc-text">算法实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#查找"><span class="toc-number">1.2.1.</span> <span class="toc-text">查找</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#实现方法一："><span class="toc-number">1.2.1.1.</span> <span class="toc-text">实现方法一：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#查找接口语义"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">查找接口语义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#插入"><span class="toc-number">1.2.2.</span> <span class="toc-text">插入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#过程："><span class="toc-number">1.2.2.1.</span> <span class="toc-text">过程：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#删除"><span class="toc-number">1.2.3.</span> <span class="toc-text">删除</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#情况一"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">情况一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#情况二"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">情况二</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#平衡等价"><span class="toc-number">1.3.</span> <span class="toc-text">平衡等价</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#两种口径"><span class="toc-number">1.3.1.</span> <span class="toc-text">两种口径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#两种平衡"><span class="toc-number">1.3.2.</span> <span class="toc-text">两种平衡</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#等价BST"><span class="toc-number">1.3.3.</span> <span class="toc-text">等价BST</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AVL树"><span class="toc-number">1.4.</span> <span class="toc-text">AVL树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#接口"><span class="toc-number">1.4.1.</span> <span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#插入操作"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">插入操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#实现-1"><span class="toc-number">1.4.1.1.1.</span> <span class="toc-text">实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#删除操作"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">删除操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#实现-2"><span class="toc-number">1.4.1.2.1.</span> <span class="toc-text">实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4重构"><span class="toc-number">1.4.2.</span> <span class="toc-text">3+4重构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#实现-3"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AVL树性能"><span class="toc-number">1.4.3.</span> <span class="toc-text">AVL树性能</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://i.loli.net/2018/04/05/5ac5c474e8082.jpg"></div><div class="author-info__name text-center">NYY</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">15</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">13</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">3</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(http://p6um59a45.bkt.clouddn.com/18-5-11/8282401.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">NYY's blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">数据结构之二叉搜索树</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-04-06</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Algorithm/">Algorithm</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2018/04/06/binary_search_tree/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2018/04/06/binary_search_tree/"></span></a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">3,766</span><span class="post-meta__separator">|</span><span>Reading time: 15 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div id="post-content"><h1 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="循关键码访问"><a href="#循关键码访问" class="headerlink" title="循关键码访问"></a>循关键码访问</h3><p>数据各项之间，依照各自的关键码彼此区分。其中关键码需要满足以下条件</p>
<ul>
<li>大小比较</li>
<li>相等比对</li>
</ul>
<p>数据集合中的数据项统一表示和实现为词条（entry）形式<br>词条：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt; <span class="class"><span class="keyword">struct</span> <span class="title">Entry</span>&#123;</span></span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry(K k=K(), V v=V()):key(k), value(v)&#123;&#125;;   <span class="comment">//默认构造函数</span></span><br><span class="line">    Entry(Entry&lt;K, V&gt; <span class="keyword">const</span> &amp; e):key(e.key), value(e.value)&#123;&#125;;  <span class="comment">// 克隆比较器、判断器</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (Entry&lt;K, V&gt; <span class="keyword">const</span> &amp; e)&#123;<span class="keyword">return</span> key &lt; e.key&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt; (Entry&lt;K, V&gt; <span class="keyword">const</span> &amp; e)&#123;<span class="keyword">return</span> key &gt; e.key&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>== (Entry&lt;K, V&gt; <span class="keyword">const</span> &amp; e)&#123;<span class="keyword">return</span> key == e.key&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!= (Entry&lt;K, V&gt; <span class="keyword">const</span> &amp; e)&#123;<span class="keyword">return</span> key != e.key&#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="BST"><a href="#BST" class="headerlink" title="BST"></a>BST</h3><p>二叉搜索树（Binary Search Tree）首先是一颗二叉树，其次处处满足顺序性，即它的任一节点不小于其左后代或任一节点不大于其右后代。</p>
<ul>
<li>顺序性：为局部的特征，但考察BST的中序遍历时可以发现它必然是单调非降的。</li>
<li>这一性质是BST的充要条件</li>
</ul>
<p>例如下面的一颗BST<br><img src="http://p6um59a45.bkt.clouddn.com/18-5-9/48098822.jpg" alt=""></p>
<p>根据中序遍历的顺序，列出访问的节点，可以看出其值为单调递增的。</p>
<h4 id="BST模板"><a href="#BST模板" class="headerlink" title="BST模板"></a>BST模板</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">BST</span>:</span><span class="keyword">public</span> BinTree&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span>:          <span class="comment">// virtual修饰，便于派生类重写</span></span><br><span class="line">    	<span class="function"><span class="keyword">virtual</span> <span class="title">BinNodePosi</span><span class="params">(T)</span> &amp; <span class="title">search</span><span class="params">(<span class="keyword">const</span> T &amp;)</span></span>;  <span class="comment">// 查找</span></span><br><span class="line">    	<span class="function"><span class="keyword">virtual</span> <span class="title">BinNodePosi</span><span class="params">(T)</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> T &amp;)</span></span>;    <span class="comment">// 插入</span></span><br><span class="line">    	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> T &amp;)</span></span>;              <span class="comment">// 删除</span></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    	BinNodePosi(T) _hot;                         <span class="comment">// 命中节点的父亲</span></span><br><span class="line">    	BinNodePosi(T) connect34(                    <span class="comment">// 3+4重构</span></span><br><span class="line">    		BinNodePosi(T), BinNodePosi(T), BinNodePosi(T),</span><br><span class="line">    		BinNodePosi(T), BinNodePosi(T), BinNodePosi(T), BinNodePosi(T));</span><br><span class="line">    	BinNodePosi(T) rotateAt(BinNodePosi(T));     <span class="comment">// 旋转调整    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>使用减而治之的方法，从根节点出发，逐步缩小查找范围，直到发现目标，或查找到空树，查找失败。<br><img src="http://p6um59a45.bkt.clouddn.com/18-5-9/73352075.jpg" alt=""></p>
<p>上面的例子需要查找到23，箭头方向表明了查找的路径，最后查找到了叶节点22，因此查找失败。整个过程可以视为在仿效有序向量的二分查找。</p>
<h4 id="实现方法一："><a href="#实现方法一：" class="headerlink" title="实现方法一："></a>实现方法一：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">BinNodePosi(T) &amp; BST&lt;T&gt;::search(<span class="keyword">const</span> T &amp; e)&#123;</span><br><span class="line">    <span class="keyword">return</span> searchIn(_root, e, _hot = <span class="literal">NULL</span>);          <span class="comment">// 从根节点启动查找</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 尾递归，可以更改为迭代操作</span></span><br><span class="line"><span class="comment">// v是当前树根节点</span></span><br><span class="line"><span class="comment">// e是目标关键码</span></span><br><span class="line"><span class="comment">// hot为记忆热点</span></span><br><span class="line">static BinNodePosi(T) &amp; searchIn(BinNodePosi(T) &amp; v, const T &amp; e, BinNodePosi(T) &amp; hot)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!v || (e == v-&gt;data))      <span class="comment">// 当前子树已经为空则返回失败</span></span><br><span class="line">    	<span class="keyword">return</span> v;</span><br><span class="line">    hot = v;</span><br><span class="line">    <span class="keyword">return</span> searchIn((e &lt; v-&gt;data ? v-&gt;lChild : v-&gt;rChild), e, hot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>算法每递归一次，子树都会下降一层，因此其运行的时间正比于返回节点v的深度，但不超过树高，则耗时为：$O(h)$</p>
<h4 id="查找接口语义"><a href="#查找接口语义" class="headerlink" title="查找接口语义"></a>查找接口语义</h4><ul>
<li>返回值引用<ul>
<li>成功时：指向一个关键码为e且真实存在的节点，<code>_hot</code>指向返回命中节点的父亲</li>
<li>失败时：指向最后一次试图转向空节点NULL，<code>_hot</code>指向最后一次转向的真实节点</li>
</ul>
</li>
</ul>
<p>空节点意思是其数值为NULL</p>
<ul>
<li>在失败时，可以假象那个空节点为哨兵节点，并将其关键值假象为目标关键码</li>
<li>引入假象哨兵后，相当于返回值总是等效于命中节点，<code>_hot</code>总是指向命中节点的父亲</li>
</ul>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><h4 id="过程："><a href="#过程：" class="headerlink" title="过程："></a>过程：</h4><ul>
<li>借助<code>search(e)</code>确定插入位置和方向，再将新节点作为叶子插入</li>
<li>若e不存在<ul>
<li><code>_hot</code>为新节点的父亲</li>
<li><code>v = search(e)</code>为<code>_hot</code>对新孩子的引用</li>
</ul>
</li>
<li>令<code>_hot</code>通过v指向新节点</li>
</ul>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; BinNodePosi(T) BST&lt;T&gt;::insert(<span class="keyword">const</span> T &amp; e)&#123;</span><br><span class="line">    BinNodePosi(T) &amp; x = search(e);      <span class="comment">// 查找目标</span></span><br><span class="line">    <span class="keyword">if</span>(!x)&#123;                              <span class="comment">// 查找目标为空，即查找失败</span></span><br><span class="line">        x = <span class="keyword">new</span> BinNode&lt;T&gt;(e, _hot);     <span class="comment">// 在x处创建新节点，并以_hot为父亲</span></span><br><span class="line">        _size++;                         <span class="comment">// 更新全树规模</span></span><br><span class="line">        updateHeightAbouve(x);           <span class="comment">// 更新x及历代祖先的高度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此算法主要的时间消耗在于<code>search(e)</code>和<code>updateHeightAbove(x)</code>两个函数都线性正比于返回节点x的深度，不超过树高<code>O(h)</code>。</p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">bool</span> BST&lt;T&gt;::remove(<span class="keyword">const</span> T &amp; e)&#123;</span><br><span class="line">    BinNodePosi(T) &amp; x = search(e);      <span class="comment">// 定位目标节点</span></span><br><span class="line">    <span class="keyword">if</span>(!x)                               <span class="comment">// 忽略元素尚不存在的情况</span></span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    removeAt(x, _hot);</span><br><span class="line">    _size--;</span><br><span class="line">    updateHeightAbove(_hot);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此算法在不考虑<code>removeAt(x, _hot)</code>时，时间主要消耗仍然在于<code>search(e)</code>和<code>updateHeightAbove(x)</code>，累计的时间消耗也是$O(h)$。接下来考虑<code>removeAt(x, _hot)</code>的情况</p>
<h4 id="情况一"><a href="#情况一" class="headerlink" title="情况一"></a>情况一</h4><p>如果删除的节点还有左孩子或者右孩子，只需要将对象删除，并且以它的子节点作为新进节点替代被删除的节点。这样可以保持BST的拓扑结构，也满足顺序性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">static</span> <span class="title">BinNodePosi</span><span class="params">(T)</span></span></span><br><span class="line">removeAt(BinNodePosi(T) &amp; x, BinNodePosi(T) &amp; hot)&#123;</span><br><span class="line">    BinNodePosi(T) w = x;                   <span class="comment">// 实际被删除的节点</span></span><br><span class="line">    BinNodePosi(T) succ = <span class="literal">NULL</span>:             <span class="comment">// 被删除节点的替代</span></span><br><span class="line">    <span class="keyword">if</span>(!HasLChild(*x))                      <span class="comment">// 左子树为空</span></span><br><span class="line">    	succ = x = x-&gt;rChild;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!HasRChild(*x))                 <span class="comment">// 右子树为空</span></span><br><span class="line">    	succ = x = x-&gt;lChild;</span><br><span class="line">    <span class="keyword">else</span>&#123;                                   </span><br><span class="line">        <span class="comment">/******左右子树并存**********/</span></span><br><span class="line">    &#125;</span><br><span class="line">    hot = w-&gt;parent;                        <span class="comment">// 被删除节点的父亲</span></span><br><span class="line">    <span class="keyword">if</span>(succ)</span><br><span class="line">    	succ-&gt;parent = hot;</span><br><span class="line">    release(w-&gt;data);                       <span class="comment">// 释放别删除节点</span></span><br><span class="line">    release(w);</span><br><span class="line">    <span class="keyword">return</span> succ;                            <span class="comment">// 返回替代节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这种情况下，只需要$O(1)$的时间。当左右孩子都为空时，<code>succ</code>指向<code>NULL</code>，上面的代码仍然正确。</p>
<h4 id="情况二"><a href="#情况二" class="headerlink" title="情况二"></a>情况二</h4><p>当左右孩子并存的时候，需要化繁为简。此处需要用到在二叉树中实现的一个接口<code>BinNode::succ()</code>该接口的作用是返回当前节点在中序遍历下的直接后继。找到之后将当前需要删除的节点和其直接后继调换位置，这时是一个中间状态，已经不再是一颗BST了。最后删除在直接后继位置处的目标节点，完成节点删除，重新变成一颗BST。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">static</span> <span class="title">BinNodePosi</span><span class="params">(T)</span></span></span><br><span class="line">removeAt(BinNodePosi(T) &amp; x, BinNodePosi(T) &amp; hot)&#123;</span><br><span class="line">    <span class="comment">/*.........*/</span></span><br><span class="line">    <span class="keyword">else</span>&#123;     <span class="comment">// 左右子树均存在</span></span><br><span class="line">        w = w-&gt;succ();</span><br><span class="line">        swap(x-&gt;data, w-&gt;data);           <span class="comment">// *x与其直接后继*w互换数据   </span></span><br><span class="line">        BinNodePosi(T) u = w-&gt;parent;     <span class="comment">// 原问题转换为 摘除直接后继</span></span><br><span class="line">        (u == x ? u-&gt;rChild : u-&gt;lChild) = succ = w-&gt;rChild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*.........*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其直接后继至多只有一个右孩子，因为作为直接后继，它一定是某条分支的左侧末端 。此时的时间消耗主要在于<code>succ()</code>其正比于x的高度，因此<code>search()</code>和<code>succ()</code>共不超过$O(h)$ 。</p>
<h2 id="平衡等价"><a href="#平衡等价" class="headerlink" title="平衡等价"></a>平衡等价</h2><ul>
<li><p>BST主要接口的运行时间在最坏的情况下，线性正比于树高$O(h)$</p>
</li>
<li><p>在最坏的情况下，BST可能退化为一个列表，此时的查找效率会降为$O(n)$，线性正比于列表的规模</p>
</li>
</ul>
<h3 id="两种口径"><a href="#两种口径" class="headerlink" title="两种口径"></a>两种口径</h3><ol>
<li>随机生成</li>
</ol>
<p>对于n个互异的词条$\left { e_{1},e_{2}, ….., e_{n} \right }$对任一排列$\sigma = \left { e_{i1},e_{i2}, ….., e_{in} \right }$，从空树开始，反复调用<code>insert()</code>接口将各词条依次插入，得到$T(\sigma)$，与$\sigma$对应的$T(\sigma)$称为由$\sigma$随机生成的BST。</p>
<ul>
<li>任一排列作为输入的概率均等，为$\frac{1}{n!}$</li>
<li>由n个互异词条随机生成的BST平均高度为$\Theta \left ( logn \right )$。</li>
</ul>
<ol start="2">
<li>随机组成</li>
</ol>
<p>对于n个互异的词条，在遵循顺序性的前提下，可随机确定拓扑连接关系。由此所得的BST称为这组词条的随机组成。</p>
<ul>
<li>由n个互异词条随机组成的BST，若共计$T(n)$棵，$T(n)=catalan(n)=\sum_{k=1}^{n}SP(k-1)\cdot SP(n-k)$。</li>
<li>所有BST等概论出现，其平均高度为$\Theta(\sqrt{n})$。</li>
</ul>
<p>按照两种口径的平均性能，随机组成更为可信。因为在随机生成的过程中，不同的随机序列可能生成同一棵BST</p>
<h3 id="两种平衡"><a href="#两种平衡" class="headerlink" title="两种平衡"></a>两种平衡</h3><ol>
<li>理想平衡</li>
</ol>
<ul>
<li>节点数目相对固定时，兄弟子树高度越接近平衡，全树也将倾向于更低。</li>
<li>由n个节点组成的二叉树，高度不低于$log_{2}n$，当正好等于$log_{2}n$时为理想平衡</li>
<li>理想平衡时相当于完全树甚至满树，此时条件太苛刻</li>
</ul>
<ol start="2">
<li>适度平衡</li>
</ol>
<ul>
<li>理想平衡出现概率极低，且维护成本过高，需要适当放松标准</li>
<li>高度渐进，不超过$O(logn)$，称为适度平衡</li>
<li>适度平衡BST称为平衡二叉搜索树（BBST)</li>
</ul>
<h3 id="等价BST"><a href="#等价BST" class="headerlink" title="等价BST"></a>等价BST</h3><ul>
<li>上下可变：连接关系不尽相同，承袭关系可能颠倒</li>
<li>左右不乱：中序遍历序列完全一致，全局单调非降</li>
</ul>
<p><img src="http://p6um59a45.bkt.clouddn.com/18-5-10/21182931.jpg" alt=""></p>
<p>如图这个例子可以看出其中序遍历序列完全相同，但其部分子序列拓扑结构并不相同。这样一对BST称为等价的BST。</p>
<p>对于各种BBST，将BST转换为BBST时，需要限制1. 单次动态修改操作后，至多$O(1)$处局部不再满足限制条件，2. 可以在$O(logn)$时间内，使得这些局部满足更新。</p>
<h2 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h2><ul>
<li>AVL树是一种BBST，在AVL的标准下的平衡因子为<code>balFac(v) = height(lc(v)) - height(rc(v))</code></li>
<li>AVL树即是对任意的节点，其平衡因子都不超过1也不小于-1的BST。</li>
<li>AVL树是适度平衡的，其高度不超过$O(logn)$</li>
</ul>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># define Balanced(x) (stature((x).lChild) == stature((x).rChild))  // 理想平衡</span><br><span class="line"># define BalFac(x) (stature((x).lChild) - stature((x).rChild))     // 平衡因子</span><br><span class="line"># define AvlBalabced(x) ((-2 &lt; BalFac(x)) &amp;&amp; (BalFac(x) &lt; 2))      // AVL平衡条件</span><br><span class="line">template &lt;typename T&gt; class AVL:public BST&lt;T&gt; &#123;                    // 继承自BST</span><br><span class="line">    public:                                                        // 沿用BSF::search()接口</span><br><span class="line">    	BinNodePosi(T) insert(const T &amp;);                          // 插入重写</span><br><span class="line">    	bool remove(const T &amp;);                                    // 删除重写</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>
<p>在按照BST规则插入或删除节点后，AVL的平衡性会被破坏，因此需要借助等价变换</p>
<ul>
<li>局部性：所有旋转都在局部进行 （每次仅需要$O(1)$时间）</li>
<li>快速性：在每一深度只需检查并旋转至多一次 （共$O(logn)$次）</li>
</ul>
<h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><ol>
<li><p>单旋插入</p>
<p><img src="http://p6um59a45.bkt.clouddn.com/18-5-10/85915049.jpg" alt=""></p>
<p>如上图所示，如果需要在v下面插入左孩子或者右孩子，则需要让g单旋调整，具体过程为：</p>
<ul>
<li>引入临时引用，指向节点p</li>
<li>令p的左子树T1变为g的右子树</li>
<li>令g为p的左孩子</li>
<li>局部子树的根g替换为p</li>
</ul>
</li>
</ol>
<p>操作完成之后，局部子树的高度恢复，其更高的祖先也必然是平衡的，使得全树复衡。</p>
<ol start="2">
<li><p>双旋插入</p>
<p><img src="http://p6um59a45.bkt.clouddn.com/18-5-10/7993033.jpg" alt=""></p>
</li>
</ol>
<p>同时可有多个失衡及诶单，最低者g不低于x的祖父，g经过双旋调整后复衡，子树高度复原，其更高的祖先也必然是平衡的，使得全树复衡。</p>
<p>其过程为：    </p>
<ul>
<li>围绕p顺时针旋转，<code>zig(p)</code><ul>
<li>引入临时变量，指向节点v</li>
<li>令v的右子树变为p的左子树</li>
<li>令p为v的右孩子</li>
<li>令g的右孩子为v<ul>
<li>围绕节点g做一次逆时针旋转，<code>zag(g)</code></li>
</ul>
</li>
</ul>
</li>
<li>将临时变量指向节点v</li>
<li>令v的左子树变为g的右子树</li>
<li>令g为v的左孩子</li>
<li>局部子树的根由g替换为v</li>
</ul>
<h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; BinNodePosi(T) AVL&lt;T&gt;::insert(<span class="keyword">const</span> T &amp; e)&#123;</span><br><span class="line">    BinNodePosi(T) &amp; x = search(e);</span><br><span class="line">    <span class="keyword">if</span> (x)</span><br><span class="line">    	<span class="keyword">return</span> x;</span><br><span class="line">    BinNodePosi(T) xx = x = <span class="keyword">new</span> BinNode&lt;T&gt;(e, _hot);     <span class="comment">// 目标不存在则创建新节点</span></span><br><span class="line">    _size++;</span><br><span class="line">    <span class="comment">// 从x的父亲_hot出发，逐层向上，依次检查各代祖先g</span></span><br><span class="line">    <span class="keyword">for</span> (BinNodePosi(T) g = _hot; g; g = g-&gt;parent)&#123;</span><br><span class="line">        <span class="keyword">if</span> (! AvlBalanced(*g))&#123;                          <span class="comment">// 一旦失衡就进行调整</span></span><br><span class="line">            FromParentTo(*g) = rotateAt(tallerChild(tallerChild(g)));</span><br><span class="line">            <span class="keyword">break</span>;                                       <span class="comment">// 完成对v，p，g的调整后就退出循环</span></span><br><span class="line">        &#125;<span class="keyword">else</span>                                            <span class="comment">// 未失衡，就更新其高度</span></span><br><span class="line">        	updateHeight(g);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> xx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><ol>
<li><p>单旋删除</p>
<p>在图中这种情况下，g、p、v是朝同一个方向排列。将T3的一个叶节点删除，会引起g点失衡。因此需要围绕点g进行一次zig操作。</p>
<p><img src="http://p6um59a45.bkt.clouddn.com/18-5-10/85320993.jpg" alt=""></p>
<p>当T2最后的那个节点不存在，即调整后的子树高缩减了1，因此有可能引起更上一层的失衡，称为失衡传播现象，可能需要做$O(logn)$次调整。</p>
</li>
<li><p>双旋删除</p>
<p>在此图中，g、p、v并不是朝着同一个方向排列，此时删除T3的一个节点。</p>
<p><img src="http://p6um59a45.bkt.clouddn.com/18-5-10/69399379.jpg" alt=""></p>
<p>这种情况下首先要围绕p做一次zag旋转，再围绕g做一次zig旋转。</p>
<p>旋转完成后，情况和单旋类似，T1和T2这两棵子树可能其中一个会存在一个叶节点，那么旋转之后子树的高度缩减1，仍可能引起失衡，可能需要做$O(logn)$次调整。</p>
</li>
</ol>
<h5 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">bool</span> AVL&lt;T&gt;::remove(<span class="keyword">const</span> T &amp; e)&#123;</span><br><span class="line">    BinNodePosi(T) &amp; x = search(e);</span><br><span class="line">    <span class="keyword">if</span>(!x)</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    removeAt(x, _hot);                         <span class="comment">// x存在则删除x</span></span><br><span class="line">    size--;</span><br><span class="line">    <span class="comment">// 从_hot出发逐层向上，依次检查各代祖先</span></span><br><span class="line">    <span class="keyword">for</span> (BinNodePosi(T) g = _hot; g; g = g-&gt;parent)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!AvlBalanced(*g))</span><br><span class="line">        	g = FromParentTo(*g) = rotateAt(tallerChild(tallerChild(g)));</span><br><span class="line">        updateHeight(g);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中for循环可能要做$\Omega(logn)$次调整</p>
<h3 id="3-4重构"><a href="#3-4重构" class="headerlink" title="3+4重构"></a>3+4重构</h3><p>设g(x)为最低的失衡节点，考察祖孙三代：g、p、v，按照中序遍历次序，将其重命名为$a &lt; b &lt; c$。则他们共拥有互不相交的四棵（可能为空）的子树，按照中序遍历次序命名为$T_{0}&lt; T_{1} &lt; T_{2} &lt; T_{3}$。将原来以g为根的子树替换为一颗新的子树$S’$。</p>
<p><img src="http://p6um59a45.bkt.clouddn.com/18-5-11/64989590.jpg" alt=""></p>
<h4 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; BinNodePosi(T) BST&lt;T&gt;::connect34(</span><br><span class="line">	BinNodePosi(T) a, BinNodePosi(T) b, BinNodePosi(T) c,</span><br><span class="line">	BinNodePosi(T) T0, BinNodePosi(T) T1, BinNodePosi(T) T2, BinNodePosi(T) T3,)&#123;</span><br><span class="line">        a-&gt;lChild = T0;</span><br><span class="line">        <span class="keyword">if</span> (T0) </span><br><span class="line">        	T0-&gt;parent = a;</span><br><span class="line">        a-&gt;rChild = T1;</span><br><span class="line">        <span class="keyword">if</span> (T1)&#123;</span><br><span class="line">            T1-&gt;parent = a;</span><br><span class="line">            updateHeight(a);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        c-&gt;lChild = T2;</span><br><span class="line">        <span class="keyword">if</span> (T2) </span><br><span class="line">        	T2-&gt;parent = c;</span><br><span class="line">        c-&gt;rChild = T3;</span><br><span class="line">        <span class="keyword">if</span> (T3)&#123;</span><br><span class="line">            T3-&gt;parent = c;</span><br><span class="line">            updateHeight(c);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        b-&gt;lChild = a;</span><br><span class="line">        a-&gt;parent = b;</span><br><span class="line">        b-&gt;rChild = c;</span><br><span class="line">        c-&gt;parent = b;</span><br><span class="line">        updateHeight(b);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> b;                  <span class="comment">//返回子树新的根节点</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>将<code>rotateAt()</code>完整化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;typenmae T&gt; BinNodePosi(T) BST&lt;T&gt;::rotateAt(BinNodePosi(T) v)&#123;</span><br><span class="line">    BinNodePosi(T) p = v-&gt;parent;</span><br><span class="line">    g = p-&gt;parent;</span><br><span class="line">    <span class="keyword">if</span>(IsLChild(*p))&#123;                    <span class="comment">// zig</span></span><br><span class="line">        <span class="keyword">if</span>(IsLChild(*v))&#123;                <span class="comment">// zig-zig</span></span><br><span class="line">            p-&gt;parent = g-&gt;parent;</span><br><span class="line">            <span class="keyword">return</span> connect34(v, p, g, v-&gt;lChild, v-&gt;rChild, p-&gt;rChild, g-&gt;rChild);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;                           <span class="comment">// zig-zag</span></span><br><span class="line">            v-&gt;parent = g-&gt;parent;</span><br><span class="line">            <span class="keyword">return</span> connect34(p, v, g, p-&gt;lChild, v-&gt;lChild, v-&gt;rChild, g-&gt;rChild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;                               <span class="comment">// zag</span></span><br><span class="line">        <span class="keyword">if</span>(IsRChild(*v))&#123;                <span class="comment">// zag-zag</span></span><br><span class="line">            p-&gt;parent = g-&gt;parent;</span><br><span class="line">            <span class="keyword">return</span> connect34(g, p, v, g-&gt;lChild, p-&gt;lChild, v-&gt;lChild, v-&gt;rChild);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;                           <span class="comment">// zag-zig</span></span><br><span class="line">            v-&gt;parent = g-&gt;parent;</span><br><span class="line">            <span class="keyword">return</span> connect34(g, v, p, g-&gt;lChild, v-&gt;lChild, v-&gt;rChild, p-&gt;rChild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>zig-zig 和zig-zag分别对应于：</p>
<p><img src="http://p6um59a45.bkt.clouddn.com/18-5-11/88247417.jpg" alt=""></p>
<p>剩下两种情况恰好与之相反。</p>
<h3 id="AVL树性能"><a href="#AVL树性能" class="headerlink" title="AVL树性能"></a>AVL树性能</h3><p>优点： </p>
<ul>
<li>无论查找、插入或删除，最坏情况下的复杂度均为$O(logn)$，存储空间为$O(n)$</li>
</ul>
<p>缺点：</p>
<ul>
<li><p>引入平衡因子，需要改造元素结构或者进行额外封装</p>
</li>
<li><p>其实测性能和理论性能差距较大</p>
<ul>
<li><p>插入删除时的zig，zag成本高</p>
</li>
<li><p>删除操作最多需要旋转$\Omega(logn)$次，若频繁插入或删除成本过高。、</p>
</li>
</ul>
</li>
<li><p>单次动态调整后，全树拓扑结构变化量可能达到$\Omega(logn)$</p>
</li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">NYY</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2018/04/06/binary_search_tree/">http://yoursite.com/2018/04/06/binary_search_tree/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/数据结构/">数据结构</a><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="social-share"></div><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2018/04/06/dataStructureBinaryTree/"><i class="fa fa-chevron-left">  </i><span>数据结构之二叉树</span></a></div><div class="next-post pull-right"><a href="/2018/04/06/dataStructureStackAndQueue/"><span>数据结构之栈和队列</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var disqus_shortname = 'niuyuanyuan'
var disqus_config = function () {
  this.page.url = 'http://yoursite.com/2018/04/06/binary_search_tree/';
  this.page.identifier = '2018/04/06/binary_search_tree/';
  this.page.title = '数据结构之二叉搜索树';
}
var d = document, s = d.createElement('script');
s.src = "https://" + disqus_shortname +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-src" src="https://niuyuanyuan.disqus.com/count.js" async></script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2017 - 2018 By NYY</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.1"></script><script src="/js/fancybox.js?version=1.5.1"></script><script src="/js/sidebar.js?version=1.5.1"></script><script src="/js/copy.js?version=1.5.1"></script><script src="/js/fireworks.js?version=1.5.1"></script><script src="/js/transition.js?version=1.5.1"></script><script src="/js/scroll.js?version=1.5.1"></script><script src="/js/head.js?version=1.5.1"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>