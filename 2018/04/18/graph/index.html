<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="数据结构之图"><meta name="keywords" content="数据结构,C++"><meta name="author" content="NYY,undefined"><meta name="copyright" content="NYY"><title>数据结构之图 | NYY's blog</title><link rel="shortcut icon" href="/icon1.png"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.1"><script>var GLOBAL = { 
  root: '/',
  algolia: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  localSearch: undefined
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#图"><span class="toc-number">1.</span> <span class="toc-text">图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#基本术语"><span class="toc-number">1.1.</span> <span class="toc-text">基本术语</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#图的存储"><span class="toc-number">1.2.</span> <span class="toc-text">图的存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#邻接矩阵"><span class="toc-number">1.2.1.</span> <span class="toc-text">邻接矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关联矩阵"><span class="toc-number">1.2.2.</span> <span class="toc-text">关联矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#顶点类"><span class="toc-number">1.2.3.</span> <span class="toc-text">顶点类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#顶点操作"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">顶点操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#顶点插入"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">顶点插入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#顶点删除"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">顶点删除</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#边类"><span class="toc-number">1.2.4.</span> <span class="toc-text">边类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#边操作"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">边操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#边插入"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">边插入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#边删除"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">边删除</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GraphMatrix"><span class="toc-number">1.2.5.</span> <span class="toc-text">GraphMatrix</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#邻接矩阵表示优缺点"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">邻接矩阵表示优缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#算法"><span class="toc-number">1.3.</span> <span class="toc-text">算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#广度优先遍历"><span class="toc-number">1.3.1.</span> <span class="toc-text">广度优先遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#过程"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#算法-1"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#最短路径性"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">最短路径性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#深度优先遍历"><span class="toc-number">1.3.2.</span> <span class="toc-text">深度优先遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#过程："><span class="toc-number">1.3.2.1.</span> <span class="toc-text">过程：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#算法："><span class="toc-number">1.3.2.2.</span> <span class="toc-text">算法：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#无向图例子"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">无向图例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#括号引理"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">括号引理</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://i.loli.net/2018/04/05/5ac5c474e8082.jpg"></div><div class="author-info__name text-center">NYY</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">6</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">2</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">1</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(http://p6um59a45.bkt.clouddn.com/18-4-18/44975288.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">NYY's blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">数据结构之图</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-04-18</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Algorithm/">Algorithm</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2018/04/18/graph/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2018/04/18/graph/"></span></a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">3,329</span><span class="post-meta__separator">|</span><span>Reading time: 13 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div id="post-content"><h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h2><p>图G由两个集合V和E组成，记为$G = (V, E)$，V代表图中顶点的集合，E代表顶点之间的关系。将顶点的规模记为$n = |V|$，边集的规模记做$e = |E|$。</p>
<ul>
<li>邻接（adjacency）顶点与顶点间的关系</li>
<li><p>关联（incidence）顶点与边的关系</p>
</li>
<li><p>无向图（undigraph）：邻接顶点u和v的次序无关系，则（u，v）为无向边。若图中都为无向边则为无向图。</p>
</li>
<li>有向图（digraph）：邻接顶点u和v的有头有尾，且u为尾（tail），v为头（head），则（u，v）为有向边。若图中都为有向边，则为有向图。</li>
<li>混合图（mixed graph）：一个图中既有有向边，又有无向边。<br>无向图可以用有向图表示。</li>
</ul>
<p>路径：连续的边的端点构成的顶点序列。</p>
<ul>
<li>简单路径：路径中不含重复的顶点</li>
<li>简单环路：除了起点和终点，其余顶点都不相同的环路。</li>
<li>欧拉环路：经过所有的边一次且恰好一次的环路</li>
<li>哈密尔顿环路：经过每一个顶点一次且恰好一次的环路</li>
</ul>
<h2 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h2><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>使用二维数组表示顶点之间的相邻关系。设$G=(V, E)$是有n个顶点的图，顶点序号依次为0,1,···，n-1，则邻接矩阵可以表示为：<br>$arc\left [ i,j \right ]=\left{\begin{matrix} 1 &amp; \left ( v_{i},v_{j} \right ) \in E\cup \left \langle v_{i},v_{j} \right \rangle \in E\ 0 &amp; others \end{matrix}\right.$</p>
<h3 id="关联矩阵"><a href="#关联矩阵" class="headerlink" title="关联矩阵"></a>关联矩阵</h3><p>使用二位数字表示顶点和边的关系。设$G=(V, E)$是有n个顶点，e条边的图</p>
<h3 id="顶点类"><a href="#顶点类" class="headerlink" title="顶点类"></a>顶点类</h3><p>给出顶点类的一种实现方法，并未进行严格封装。其中<code>status</code>、<code>dTime</code>、<code>fTime</code>、<code>parent</code>、<code>priority</code>要进行重点分析。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">typedef enum &#123;UNDISCOVERED, DISCOVERED, VISITED&#125; VStatus;</span><br><span class="line">template &lt;typename Tv&gt; struct Vertex&#123;   //顶点对象</span><br><span class="line">    Tv data;                            //数据</span><br><span class="line">    int inDegree, outDegree;            //入度，出度</span><br><span class="line">    VStatus status;                     //状态</span><br><span class="line">    int dTime, fTime;                   //时间标签</span><br><span class="line">    int parent;                         //遍历树中的父节点</span><br><span class="line">    int priority;                       //遍历树中的优先级</span><br><span class="line">    Vertex(Tv const &amp; d):               //构造新节点</span><br><span class="line">        data(d),</span><br><span class="line">        inDegree(0),outDegree(0),</span><br><span class="line">        ststus(UNDISCOVERED),</span><br><span class="line">        dTime(-1), fTime(-1),</span><br><span class="line">        parent(-1),</span><br><span class="line">        priority(INT_MAX)&#123;&#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="顶点操作"><a href="#顶点操作" class="headerlink" title="顶点操作"></a>顶点操作</h4><p>对于任意的顶点i，枚举出其所有的邻接顶点neighbor：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int nextNbr(int i, int j)&#123;             //表示若已经枚举到邻居j，则转向下一个邻居。采用逆序查找的方式，时间复杂度为O(n)</span><br><span class="line">    while((-1&lt;j)&amp;&amp;!exists(i,--j));     //短路求值，当j越界时跳出循环</span><br><span class="line">    return j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int firstNbr(int i)&#123;return nextNbr(i, n)&#125; //返回首个邻居的索引，将n假想成一个尾哨兵。</span><br></pre></td></tr></table></figure></p>
<p>如果改用邻接矩阵来查找，耗时将会降低到degree+1</p>
<h4 id="顶点插入"><a href="#顶点插入" class="headerlink" title="顶点插入"></a>顶点插入</h4><p>在邻接矩阵中，顶点插入对应于增加一列和一行，并且在对应的边集中增加其关联的边，在顶点集中增加该顶点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int insert(Tv const &amp; vertex)&#123;</span><br><span class="line">    for(int i=0; j&lt;n; j++)&#123;</span><br><span class="line">        E[j].insert(NULL);                         //为每个列向量的末尾增加一个单元</span><br><span class="line">    &#125;</span><br><span class="line">    n++;</span><br><span class="line">    E.insert(Vector&lt;Edge&lt;Te&gt;*&gt;(n, n, NULL));       //边集增加边</span><br><span class="line">    return V.insert(Vertex&lt;Tv&gt;(vertex));           //顶点集增加顶点</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>在每个列向量的尾部增加一个单元，初始化为NULL；</li>
<li>生成一个新的行向量，每个元素为一个边记录，总数为n，所有边引用都初始化为NULL。此处行向量的长度在原来的基础上增加1。</li>
<li>顶点集增加一个顶点元素。<br>这里未对新的边进行实质性操作。</li>
</ul>
<h4 id="顶点删除"><a href="#顶点删除" class="headerlink" title="顶点删除"></a>顶点删除</h4><p>与顶点插入类似，需要删除顶点及其关联边，并返回该顶点信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Tv remove(int i)&#123;</span><br><span class="line">    for(int j=0; j&lt;n; j++)&#123;                      //删除所有出边</span><br><span class="line">        if(exists(i, j))&#123;</span><br><span class="line">            delete E[i][j];</span><br><span class="line">            V[j].inDegree--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    E.remove(i);                                 //删除第i行</span><br><span class="line">    n--;   </span><br><span class="line">    for(int j=0; j&lt;n; j++)&#123;                      //删除所有入边和第i列</span><br><span class="line">        if(exists(j, i))&#123;</span><br><span class="line">            delete E[j].remove(i);</span><br><span class="line">            V[j].outDegree--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Tv vBak = vertex(i);                         //备份顶点信息</span><br><span class="line">    V.remove(i);                                 //删除顶点</span><br><span class="line">    return vBak;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="边类"><a href="#边类" class="headerlink" title="边类"></a>边类</h3><p>对于Edge类也没有进行严格封装。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef enum &#123;UNDTERMINED, TREE, CROSS, FORWARD, BACKWARD&#125; EStatus;</span><br><span class="line">template &lt;typename Te&gt; struct Edge&#123;</span><br><span class="line">    Te data;</span><br><span class="line">    int weight;</span><br><span class="line">    EStatus status;</span><br><span class="line">    Edge(Te const &amp; d, int w):</span><br><span class="line">        data(d),</span><br><span class="line">        weight(w),</span><br><span class="line">        status(UNDTERMINED)&#123;&#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="边操作"><a href="#边操作" class="headerlink" title="边操作"></a>边操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bool exists(int i, int j)&#123;</span><br><span class="line">    return (0&lt;=i)&amp;&amp;(i&lt;n)&amp;&amp;(0&lt;=j)&amp;&amp;(j&lt;n)&amp;&amp;E[i][j] != NULL;  //短路求值</span><br><span class="line">&#125;</span><br><span class="line">Te &amp; edge(int i, int j)&#123;</span><br><span class="line">    return E[i][j]-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line">Estatus &amp; status(int i, int j)&#123;</span><br><span class="line">    return E[i][j]-&gt;status;</span><br><span class="line">&#125;</span><br><span class="line">int &amp; weight(int i, int j)&#123;</span><br><span class="line">    return E[i][j]-&gt;weight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断边是否合法，如果合法可以将该边对应的数据取出，且该边的其他状态也可以直接返回，其时间复杂度为$O(1)$。</p>
<h4 id="边插入"><a href="#边插入" class="headerlink" title="边插入"></a>边插入</h4><p>使用邻接矩阵，将需要插入的边封装成一个边信息，再将地址链接到邻接矩阵对应的地方即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void insert(Te const &amp; edge, int w, int i, int j)&#123;</span><br><span class="line">    if(exists(i, j)) return;           //忽略已有的边</span><br><span class="line">    E[i][j] = new Edge&lt;Te&gt;(edge, w);   //创建新的边并赋值给E[i][j]</span><br><span class="line">    e++;                               //更新边数</span><br><span class="line">    V[i].outDegree++;                  //更新关联顶点i的出度</span><br><span class="line">    V[j].inDegree++;                   //更新关联顶点j的入度</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="边删除"><a href="#边删除" class="headerlink" title="边删除"></a>边删除</h4><p>在邻接矩阵中删除一条边只需要将边插入的过程反过来。查询邻接矩阵，对应到一条边记录，删除边记录，使其查询时对应为空，返回删除边的信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Te remove(int i, int j)&#123;</span><br><span class="line">    if(!exists(i, j)) return;           //忽略不存在的边</span><br><span class="line">    Te eBak = edge(i, j);               //备份要删除的边</span><br><span class="line">    delete E[i][j];</span><br><span class="line">    E[i][j] = NULL;</span><br><span class="line">    e--;</span><br><span class="line">    V[i].outDegree--;</span><br><span class="line">    V[j].inDegree--;</span><br><span class="line">    return eBak;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="GraphMatrix"><a href="#GraphMatrix" class="headerlink" title="GraphMatrix"></a>GraphMatrix</h3><p>GraphMatrix派生于Graph类。首先构造顶点集和边集，其中顶点集是顶点构成的向量；边集相当于由边向量构成的矩阵，每个边向量长度为n，因此恰好构成邻接矩阵<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename Tv, typename Te&gt; class GraphMatrix : public Graph&lt;Tv, Te&gt;&#123;</span><br><span class="line">    private:</span><br><span class="line">        Vector&lt;Vertex&lt;Tv&gt;&gt; V;           //顶点集</span><br><span class="line">        Vector&lt;Vector&lt;Edge&lt;Te&gt;*&gt;&gt; E;    //边集</span><br><span class="line">    public:</span><br><span class="line">        GraphMatrix()&#123;                  //构造函数</span><br><span class="line">            n = e = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        ~GraphMatrix()&#123;                 //析构</span><br><span class="line">            for (int j=0; j&lt;n; j++)&#123;</span><br><span class="line">                for (int k=0; k&lt;n; k++)</span><br><span class="line">                    delete E[j][k]</span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="邻接矩阵表示优缺点"><a href="#邻接矩阵表示优缺点" class="headerlink" title="邻接矩阵表示优缺点"></a>邻接矩阵表示优缺点</h4><ul>
<li>优点：<ul>
<li>直观，易于理解和实现</li>
<li>适用范围广泛，尤其适用于稠密图（dense graph）</li>
<li>判断两点之间是否存在联边只需要$O(1)$的时间</li>
<li>获取顶点（出/入）度数只需要$O(1)$的时间</li>
<li>添加或删除边后更新度数也只需$O(1)$的时间</li>
<li>良好的扩展性（scalability）：<ul>
<li>Vector良好的空间控制策略</li>
<li>可“透明处理”空间溢出的情况</li>
</ul>
</li>
</ul>
</li>
<li>缺点：<ul>
<li>消耗空间数与边数无关，总是会消耗$\Theta \left ( n^{2} \right )$的空间<ul>
<li>如平面图，其边数$e &lt;&lt; n^{2}$，此时空间利用率约为$\frac{1}{n}$ </li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h3><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ol>
<li>访问顶点s</li>
<li>依次访问s所有尚未访问的邻接顶点</li>
<li>依次访问2步骤中的顶点的尚未访问的邻接顶点</li>
<li>……</li>
<li>直达没有尚未访问的邻接顶点</li>
</ol>
<p>此算法会逐层访问顶点，灰色线条表示各邻接顶点之间可能会有的关系，但此算法会忽略这种关系。这种广度遍历是树的层次遍历的推广。<br><img src="http://p6um59a45.bkt.clouddn.com/18-5-4/17577110.jpg" alt=""></p>
<h4 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">template &lt;Typename Tv, TypenameTe&gt;</span><br><span class="line">void Graph&lt;Tv, Te&gt;::BFS(int v, int &amp; clock)&#123;</span><br><span class="line">    Queue&lt;int&gt; Q;</span><br><span class="line">    status(v) = DISCPVERED;</span><br><span class="line">    Q.enqueue(v);</span><br><span class="line">    while(!Q.empty())&#123;</span><br><span class="line">        int v = Q.dequeue();   // 取出队首顶点v</span><br><span class="line">        dTime(v) = ++clock;</span><br><span class="line">        for(int u = firdtNbr(v); -1 &lt; u; u = nextNbr(v, u))&#123;  // 考察v的每个邻居u</span><br><span class="line">            dealWithUforBFS(u, v)</span><br><span class="line">            /***  视u的状态分别处理  ***/</span><br><span class="line">        &#125;</span><br><span class="line">        status(v) = VISITED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遍历的起点是某个预先指定的顶点v。每个顶点都会经历从UNDISCOVERED状态到DISCOVERED状态，最后到VISITED状态，由此构成其生命周期。每个顶点都会入队和出队一次且仅一次，因此外层while循环的时间复杂度为$O(n)$，内层for循环是对顶点邻居的扫描，时间复杂度为$O(n)$，因此总体的时间消耗为$n^{2} + e$，时间复杂度为$O(n^{2})$，但在实际操作中，内层for循环的n很小，所以总体的时间消耗接近于$n + e$。对于邻居u的处理方式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">template &lt;Typename Tv, TypenameTe&gt;</span><br><span class="line">void dealWithUforBFS (Tv u, Tv v)&#123;</span><br><span class="line">    if (UNDISCOVERD == status(u))&#123;   // 若u尚未被发现，则发现该顶点</span><br><span class="line">        status(u) = DISCOVERD;</span><br><span class="line">        Q.enqueue(u);</span><br><span class="line">        status(v, u) = TREE;         // 引入树边</span><br><span class="line">        parent(u) = v;</span><br><span class="line">    &#125;else                            // 若u已经被发现（正在队列中）或已经访问完毕（已出队）</span><br><span class="line">        status(v, u) = CROSS;        // 将（v,u）归类为跨边</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并不是没幅图都只包含一个联通域，在有多个连通域的时候，从任何一个起点s出发，未必能够抵达其它的连通域，要使得bfs搜索足以覆盖整幅图而不是其中一个特定的连通域，需要使用while循环对BFS进行封装。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">template &lt;Typename Tv, TypenameTe&gt;</span><br><span class="line">void Graph&lt;Tv, Te&gt;::bfs(int s)&#123;            // s为起点</span><br><span class="line">    reset();</span><br><span class="line">    int clock = 0;</span><br><span class="line">    int v = s;                             // 初始化，时间占用为θ（n + e）</span><br><span class="line">    do                                     // 逐一检查所有顶点，一旦遇到尚未发现的顶点</span><br><span class="line">        if(UNDISCOVERED == status(v))</span><br><span class="line">            BFS(v, clock);                 // 从该顶点出发启动一次BFS</span><br><span class="line">    while(s != (v = (++v % n)) );          // 按照序号访问，可不漏不重</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="最短路径性"><a href="#最短路径性" class="headerlink" title="最短路径性"></a>最短路径性</h4><p>在树的结构中，相对于树根节点，任何一个节点v都对应于一条唯一的通路，这条路径的长度称作顶点v的深度，于是我们可以进而对所有的顶点自上而下按照它们的深度进行等价类划分，在每一个等价类中的所有顶点，所具有的深度指标都是彼此相等的。而树的层次遍历也相当于按照这一指标非降的次序，将所有的顶点逐一枚举出来，这样一个遍历的过程也可以转换为图结构的遍历。</p>
<p>图与树不同之处在于，从起始顶点s出发可能有多条路径都最后通往同一个顶点而且可能出现分叉。实际上只需考察顶点之间的最短通路，并且将这两个顶点之间的距离取作这条最短通路的长度。而在起始顶点相对固定的情况下，可以将s在这个记号中省掉，直接简称之为顶点v所对应的距离。</p>
<h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><h4 id="过程："><a href="#过程：" class="headerlink" title="过程："></a>过程：</h4><ul>
<li>访问顶点s</li>
<li>if s的邻居尚未被访问，访问s尚未被访问的邻居，任取其一，递归执行DFS（u）</li>
<li>else 返回</li>
</ul>
<p>此过程等效于树的先序遍历，DFS会构造出原图的一颗支撑树。其过程为：</p>
<p><img src="http://p6um59a45.bkt.clouddn.com/18-5-8/54619684.jpg" alt=""></p>
<p>按照图中的箭头方向，从红色到白色到黄色到蓝色，每次改变颜色都是因为处于else语句中。</p>
<h4 id="算法："><a href="#算法：" class="headerlink" title="算法："></a>算法：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename Tv, typename Te&gt;</span><br><span class="line">void Graph&lt;Tv, Te&gt;::DFS(int v, int &amp; clock)&#123;</span><br><span class="line">    dTime(v) = ++clock;</span><br><span class="line">    status(v) = DISCOVERED;                                // 发现当前顶点</span><br><span class="line">    for(int u = firstNbr(v); -1 &lt; u; u = nextNbr(v, u))&#123;   // 枚举v的每个邻居</span><br><span class="line">        /*  视u的状态分别处理  */</span><br><span class="line">        /* 与BFS不同，含有递归 */</span><br><span class="line">        dealwithUforDFS(v, u)</span><br><span class="line">    &#125;</span><br><span class="line">    status(v) = VISITED;</span><br><span class="line">    fTime(v) = ++clock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在内部对u进行处理时，没有使用队列的方式，而是涉及到递归调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename Tv, typename Te&gt;</span><br><span class="line">void dealwithUforDFS(Tv v, Tv u)&#123;</span><br><span class="line">    switch(status(u))&#123;</span><br><span class="line">        case UNDISCOVERED:                      // u尚未被发现，支撑树可以在此基础上扩展</span><br><span class="line">            status(v, u) = TREE;</span><br><span class="line">            parent(u) = v;</span><br><span class="line">            DFS(u, clock);</span><br><span class="line">            break;</span><br><span class="line">        case DISCOVERED:                       // u已被发现但尚未访问完毕</span><br><span class="line">            status(v, u) = BACKWARD;</span><br><span class="line">            break;</span><br><span class="line">        default:                               // u已被访问完，视承袭关系分为前向边或跨边</span><br><span class="line">            status(v, u) = dTime(v) &lt; dTime(u) ? FORWARD : CROSS;</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="无向图例子"><a href="#无向图例子" class="headerlink" title="无向图例子"></a>无向图例子</h4><p>例如对当前的无向图：</p>
<p><img src="http://p6um59a45.bkt.clouddn.com/18-5-8/85305440.jpg" alt=""></p>
<p>最终会得到一个支撑树：</p>
<p><img src="http://p6um59a45.bkt.clouddn.com/18-5-8/27991522.jpg" alt=""></p>
<p>与BFS（v）类似，在有多个连通域的时候，需要将DFS（v）用while循环封装起来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename Tv, typename Te&gt;</span><br><span class="line">void Graph&lt;Tv, Te&gt;::dfs(int s)&#123;</span><br><span class="line">    reset();                               // 初始化</span><br><span class="line">    int clock = 0;</span><br><span class="line">    int v = s;</span><br><span class="line">    do                                    // 逐一检查所有顶点</span><br><span class="line">        if(UNDISCOVERD = status(v))       // 一旦有尚未发现的顶点就从该点出发启动一次DFS      </span><br><span class="line">            DFS(v, clock);</span><br><span class="line">    while(s != (v = ++v % n));            // 按序号访问，不重不漏</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在有向图中，情况更为复杂。一旦出现BACKWARD边，则表明图中出现了环路。</p>
<h4 id="括号引理"><a href="#括号引理" class="headerlink" title="括号引理"></a>括号引理</h4><p>顶点活动期：<code>active[u] = (dTime[u], fTime[u])</code><br>嵌套引理：给定有向图$G = (V, E)$及其任一DS森林，则</p>
<ul>
<li>u是v的后代，if and only if active[u]$\subseteq $active[v]</li>
<li>u是v的祖先，if and only if activate[u]$\supseteq $activate[v]</li>
<li>u与v无关，if and only if actiavte[u]$\cap$active[v] = $\varnothing$</li>
</ul>
<p>祖先的活跃期必定包含后代的活跃期。借助时间标签可以在$O(1)$的时间内得出两个节点之间的祖先关系，若没有时间标签则需要从起点一直追溯到终点。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">NYY</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2018/04/18/graph/">http://yoursite.com/2018/04/18/graph/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/数据结构/">数据结构</a><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="social-share"></div><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script><nav id="pagination"><div class="next-post pull-right"><a href="/2018/04/06/binary_search_tree/"><span>数据结构之二叉搜索树</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var disqus_shortname = 'niuyuanyuan'
var disqus_config = function () {
  this.page.url = 'http://yoursite.com/2018/04/18/graph/';
  this.page.identifier = '2018/04/18/graph/';
  this.page.title = '数据结构之图';
}
var d = document, s = d.createElement('script');
s.src = "https://" + disqus_shortname +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-src" src="https://niuyuanyuan.disqus.com/count.js" async></script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2017 - 2018 By NYY</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.1"></script><script src="/js/fancybox.js?version=1.5.1"></script><script src="/js/sidebar.js?version=1.5.1"></script><script src="/js/copy.js?version=1.5.1"></script><script src="/js/fireworks.js?version=1.5.1"></script><script src="/js/transition.js?version=1.5.1"></script><script src="/js/scroll.js?version=1.5.1"></script><script src="/js/head.js?version=1.5.1"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>