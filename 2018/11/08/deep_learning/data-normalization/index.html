<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="data-normalization"><meta name="keywords" content="神经网络,数据预处理"><meta name="author" content="NYY,undefined"><meta name="copyright" content="NYY"><title>data-normalization | NYY's blog</title><link rel="shortcut icon" href="/img/my_icon.jpg"><link rel="stylesheet" href="/css/index.css?version=1.5.6"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css?version=1.5.6"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#深度学习中数据预处理方法"><span class="toc-number">1.</span> <span class="toc-text">深度学习中数据预处理方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#数据归一化（Normalization）"><span class="toc-number">1.1.</span> <span class="toc-text">数据归一化（Normalization）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#简单缩放（Simple-Rescaling）"><span class="toc-number">1.1.1.</span> <span class="toc-text">简单缩放（Simple Rescaling）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#逐样本均值消减（Per-example-mean-subtraction）"><span class="toc-number">1.1.2.</span> <span class="toc-text">逐样本均值消减（Per-example mean subtraction）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#特征标准化（Feature-Standardization）"><span class="toc-number">1.1.3.</span> <span class="toc-text">特征标准化（Feature Standardization）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PCA-ZCA白化"><span class="toc-number">1.2.</span> <span class="toc-text">PCA/ZCA白化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基于重构的模型"><span class="toc-number">1.2.1.</span> <span class="toc-text">基于重构的模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基于正交化ICA的模型"><span class="toc-number">1.2.2.</span> <span class="toc-text">基于正交化ICA的模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#具体应用"><span class="toc-number">1.3.</span> <span class="toc-text">具体应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#自然灰度图像"><span class="toc-number">1.3.1.</span> <span class="toc-text">自然灰度图像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自然彩色图像"><span class="toc-number">1.3.2.</span> <span class="toc-text">自然彩色图像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MINIS手写数据集"><span class="toc-number">1.3.3.</span> <span class="toc-text">MINIS手写数据集</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.jpg"></div><div class="author-info__name text-center">NYY</div><div class="author-info__description text-center"></div><div class="follow-button"><a href="https://github.com/niuyuanyuanna" target="_blank">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">28</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">21</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">5</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://www.ouyangsong.com" target="_blank">欧阳松的博客</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(http://p6um59a45.bkt.clouddn.com/18-11-8/62648403.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">NYY's blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">data-normalization</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-11-08</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Deep-Learning/">Deep Learning</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2018/11/08/deep_learning/data-normalization/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2018/11/08/deep_learning/data-normalization/"></span></a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">2,487</span><span class="post-meta__separator">|</span><span>Reading time: 8 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="深度学习中数据预处理方法"><a href="#深度学习中数据预处理方法" class="headerlink" title="深度学习中数据预处理方法"></a>深度学习中数据预处理方法</h1><p>数据预处理在众多深度学习算法中都起着重要作用，通常预处理包括数据归一化和白化。</p>
<h2 id="数据归一化（Normalization）"><a href="#数据归一化（Normalization）" class="headerlink" title="数据归一化（Normalization）"></a>数据归一化（Normalization）</h2><p>数据归一化（Data Normalization）是数据预处理的第一步，有很多方法，如常见的高斯归一化、最大最小值归一化等，而在深度学习中常用的是以下几种：</p>
<h3 id="简单缩放（Simple-Rescaling）"><a href="#简单缩放（Simple-Rescaling）" class="headerlink" title="简单缩放（Simple Rescaling）"></a>简单缩放（Simple Rescaling）</h3><p>简单缩放，对数据的每一个维度的值重新调节（这些维度可能是相互独立的），使得最终的数据向量落在 [0,1]或[ − 1,1] 的区间内（根据数据情况而定），以满足应用需求。</p>
<p>例如，在sparse auto-encoder中，由于网络的输出和输入是近似相等的，而隐含层和输出层神经元通常采用的是sigmoid函数作为激活函数，该函数值域为[0,1]，因此为了保证输出等于输入，通常需要将输入缩放至[0,1]这个范围，然后再进行训练。在处理自然图像时，我们获得的像素值在 [0,255] 区间中，常用的处理是将这些像素值除以 255，使它们缩放到 [0,1] 中。</p>
<p>使用Tensorflow可以进行如下处理：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">image = tf.cast(image, tf.float32) * (<span class="number">1.</span> / <span class="number">255</span>) - <span class="number">0.5</span></span><br><span class="line"><span class="comment"># image 参数表示一个三维的张量(tensor) 分别对应图像高、宽、通道数目(height, width, channels)</span></span><br></pre></td></tr></table></figure></p>
<h3 id="逐样本均值消减（Per-example-mean-subtraction）"><a href="#逐样本均值消减（Per-example-mean-subtraction）" class="headerlink" title="逐样本均值消减（Per-example mean subtraction）"></a>逐样本均值消减（Per-example mean subtraction）</h3><p>逐样本均值消减，也称为移除直流分量（remove DC），当数据平稳（stationary），即数据每一个维度的统计都服从相同分布，可以考虑在每个样本上减去数据的统计平均值(逐样本计算，即分别计算各样本的均值，然后各样本减去其对应的均值)。</p>
<p>自然图像具有平稳的性质，所以这种归一化方法也是比较常用的。这种归一化可以移除图像的平均亮度值 (intensity)。很多情况下我们对图像的照度并不感兴趣，而更多地关注其内容，这时对每个数据点移除像素的均值是有意义的。若图像是自然灰度图像，由于灰度图像具有平稳特性，通常可选择这种方法，即移除直流分量（逐样本移除直流分量后还可以继续逐样本除以各样本的标准差，不过这一步通常不做,因为其平稳特性）。</p>
<p>注意：虽然该方法广泛地应用于图像，但在处理彩色图像时需要格外小心，具体来说，是因为不同色彩通道中的像素并不都存在平稳特性</p>
<p>对自然图像应用PCA算法时候，通常也会这样处理。在深度学习图像预处理时，可以使用如下代码：<br>使用Tensorflow框架<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tf.image.per_image_standardization(image)</span><br><span class="line"><span class="comment"># image 参数表示一个三维的张量(tensor) 分别对应图像高、宽、通道数目(height, width, channels)</span></span><br></pre></td></tr></table></figure></p>
<p>使用opencv：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">img_dir=<span class="string">'/image/path'</span></span><br><span class="line">img_list=os.listdir(img_dir)</span><br><span class="line">img_size=<span class="number">224</span></span><br><span class="line">sum_r=<span class="number">0</span></span><br><span class="line">sum_g=<span class="number">0</span></span><br><span class="line">sum_b=<span class="number">0</span></span><br><span class="line">count=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> img_name <span class="keyword">in</span> img_list:</span><br><span class="line">    img_path=os.path.join(img_dir,img_name)</span><br><span class="line">    img=cv2.imread(img_path)</span><br><span class="line">    img=cv2.cvtColor(img,cv2.COLOR_BGR2RGB)</span><br><span class="line">    img=cv2.resize(img,(img_size,img_size))</span><br><span class="line">    sum_r=sum_r+img[:,:,<span class="number">0</span>].mean()</span><br><span class="line">    sum_g=sum_g+img[:,:,<span class="number">1</span>].mean()</span><br><span class="line">    sum_b=sum_b+img[:,:,<span class="number">2</span>].mean()</span><br><span class="line">    count=count+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">sum_r=sum_r/count</span><br><span class="line">sum_g=sum_g/count</span><br><span class="line">sum_b=sum_b/count</span><br><span class="line">img_mean=[sum_r,sum_g,sum_b]</span><br><span class="line"><span class="keyword">print</span> img_mean</span><br></pre></td></tr></table></figure></p>
<h3 id="特征标准化（Feature-Standardization）"><a href="#特征标准化（Feature-Standardization）" class="headerlink" title="特征标准化（Feature Standardization）"></a>特征标准化（Feature Standardization）</h3><p>特征标准化的目的是使数据集中所有特征都具有零均值和单位方差，即数据的每一个维度具有零均值和单位方差，这也是比较常见的一种归一化方法，比如使用SVM时候也要进行类似处理。在实际应用中，特征标准化的具体做法是：首先计算每一个维度上数据的均值（使用全体数据计算），之后在每一个维度上都减去该均值。下一步便是在数据的每一维度上除以该维度上数据的标准差。</p>
<p>例如$X$是一个训练样本集，包含m个训练样本且每个训练样本的维数是n。应用特征标准化时先计算各行数据的均值，然后样本集$X$减去该均值得到零均值化后的样本集$X^{‘}$。之后$X^{‘}$的各行除以该行数据的标准差就会得到特征标准化后的样本。</p>
<p>若输入是自然彩色图像，由于色彩通道间并不存在平稳特性，因此通常对数据进行特征缩放（使像素值位于 [0,1] 区间）。然后再进行PCA/ZCA白化等操作，在白化前需进行特征分量均值归零（即使特征的每一个维度具有零均值，通常不需要除以各维度数据的标准差，因为各维度标准差很接近）。在UFLDL教程的练习中（linear decoder）采用的是这种方法，而在有些论文中，也会采用第二种方法（逐样本去均值和除以标准差），如论文“An Analysis of Single-Layer Networks in Unsupervised Feature Learning”，这样在后续白化处理时是不是还需要再对各维度进行零均值化（因为计算协方差矩阵时需要这一步）。</p>
<h2 id="PCA-ZCA白化"><a href="#PCA-ZCA白化" class="headerlink" title="PCA/ZCA白化"></a>PCA/ZCA白化</h2><p>在做完简单的归一化后，白化通常会被用来作为接下来的预处理步骤，它会使我们的算法工作得更好。实际上许多深度学习算法都依赖于白化来获得好的特征。</p>
<p>在进行 PCA/ZCA 白化时，首先使特征零均值化是很有必要的，这保证了$ \frac{1}{m} \sum_i x^{(i)} = 0$。特别地，这一步需要在计算协方差矩阵前完成。（唯一例外的情况是已经进行了逐样本均值消减，并且数据在各维度上或像素上是平稳的。）接下来在 PCA/ZCA 白化中我们需要选择合适的 <code>epsilon</code>（回忆一下，这是规则化项，对数据有低通滤波作用）。 选取合适的 <code>epsilon</code> 值对特征学习起着很大作用，下面讨论在两种不同场合下如何选取 <code>epsilon</code>：</p>
<h3 id="基于重构的模型"><a href="#基于重构的模型" class="headerlink" title="基于重构的模型"></a>基于重构的模型</h3><p>在基于重构的模型中(包括自编码器，稀疏编码，受限 Boltzman 机（RBM），k-均值（K-Means）)，经常倾向于选取合适的 <code>epsilon</code> 以使得白化达到低通滤波的效果。（注：通常认为数据中的高频分量是噪声，低通滤波的作用就是尽可能抑制这些噪声，同时保留有用的信息。在 PCA 等方法中，假设数据的信息主要分布在方差较高的方向，方差较低的方向是噪声（即高频分量），因此后文中 <code>epsilon</code> 的选择与特征值有关）。一种检验 <code>epsilon</code> 是否合适的方法是用该值对数据进行 ZCA 白化，然后对白化前后的数据可视化。如果 <code>epsilon</code> 值过低，白化后的数据会显得噪声很大；相反，如果 <code>epsilon</code> 值过高，白化后的数据与原始数据相比就过于模糊。一种直观上得到 <code>epsilon</code> 大小的方法是以图形方式画出数据的特征值，选取的 <code>epsilon</code> 应大于大多数较小的、反映数据中噪声的特征值。</p>
<p>在基于重构的模型中，损失函数有一项是用于惩罚那些与原始输入数据差异较大的重构结果（注：以自动编码机为例，要求输入数据经过编码和解码之后还能尽可能的还原输入数据）。如果 <code>epsilon</code> 太小，白化后的数据中就会包含很多噪声，而模型要拟合这些噪声，以达到很好的重构结果。因此，对于基于重构的模型来说，对原始数据进行低通滤波就显得非常重要。</p>
<ul>
<li>如果数据已被缩放到合理范围(如[0,1])，可以从<code>epsilon = 0.01</code>或<code>epsilon = 0.1</code>开始调节<code>epsilon</code>。</li>
</ul>
<h3 id="基于正交化ICA的模型"><a href="#基于正交化ICA的模型" class="headerlink" title="基于正交化ICA的模型"></a>基于正交化ICA的模型</h3><p>对基于正交化ICA的模型来说，保证输入数据尽可能地白化（即协方差矩阵为单位矩阵）非常重要。这是因为：这类模型需要对学习到的特征做正交化，以解除不同维度之间的相关性（详细内容请参考 ICA 一节）。因此在这种情况下，<code>epsilon</code> 要足够小（如 <code>epsilon = 1e − 6</code>）。</p>
<ul>
<li>在使用分类框架时，我们应该只基于训练集上的数据计算PCA/ZCA白化矩阵。需要保存以下两个参数留待测试集合使用：(a)用于零均值化数据的平均值向量；(b)白化矩阵。测试集需要采用这两组保存的参数来进行相同的预处理。</li>
</ul>
<h2 id="具体应用"><a href="#具体应用" class="headerlink" title="具体应用"></a>具体应用</h2><h3 id="自然灰度图像"><a href="#自然灰度图像" class="headerlink" title="自然灰度图像"></a>自然灰度图像</h3><p>灰度图像具有平稳特性，我们通常在第一步对每个数据样本分别做均值消减（即减去直流分量），然后采用 PCA/ZCA 白化处理，其中的 <code>epsilon</code> 要足够大以达到低通滤波的效果。</p>
<h3 id="自然彩色图像"><a href="#自然彩色图像" class="headerlink" title="自然彩色图像"></a>自然彩色图像</h3><p>对于彩色图像，色彩通道间并不存在平稳特性。因此我们通常首先对数据进行特征缩放（使像素值位于 [0,1] 区间），然后使用足够大的 <code>epsilon</code> 来做 PCA/ZCA。在进行 PCA 变换前需要对特征进行分量均值归零化。</p>
<h3 id="MINIS手写数据集"><a href="#MINIS手写数据集" class="headerlink" title="MINIS手写数据集"></a>MINIS手写数据集</h3><p>MNIST 数据集的像素值在 [0,255] 区间中。我们首先将其缩放到 [0,1] 区间。实际上，进行逐样本均值消去也有助于特征学习。注：也可选择以对 MNIST 进行 PCA/ZCA 白化，但这在实践中不常用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">NYY</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2018/11/08/deep_learning/data-normalization/">http://yoursite.com/2018/11/08/deep_learning/data-normalization/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/神经网络/">神经网络</a><a class="post-meta__tags" href="/tags/数据预处理/">数据预处理</a></div><div class="social-share"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2018/11/08/deep_learning/face-keypoint-detection/"><i class="fa fa-chevron-left">  </i><span>face-keypoint-detection</span></a></div><div class="next-post pull-right"><a href="/2018/11/08/deep_learning/transfer-learning/"><span>迁移学习--样本自适应</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'http://yoursite.com/2018/11/08/deep_learning/data-normalization/';
  this.page.identifier = '2018/11/08/deep_learning/data-normalization/';
  this.page.title = 'data-normalization';
}
var d = document, s = d.createElement('script');
s.src = "https://" + 'niuyuanyuan' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-src" src="https://niuyuanyuan.disqus.com/count.js" async></script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 By NYY</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.6"></script><script src="/js/fancybox.js?version=1.5.6"></script><script src="/js/sidebar.js?version=1.5.6"></script><script src="/js/copy.js?version=1.5.6"></script><script src="/js/fireworks.js?version=1.5.6"></script><script src="/js/transition.js?version=1.5.6"></script><script src="/js/scroll.js?version=1.5.6"></script><script src="/js/head.js?version=1.5.6"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>