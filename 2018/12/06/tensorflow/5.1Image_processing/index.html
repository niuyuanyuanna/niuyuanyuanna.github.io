<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Tensorflow图像处理"><meta name="keywords" content="Tensorflow,入门教程,CNN"><meta name="author" content="NYY,undefined"><meta name="copyright" content="NYY"><title>Tensorflow图像处理 | NYY's blog</title><link rel="shortcut icon" href="/img/my_icon.jpg"><link rel="stylesheet" href="/css/index.css?version=1.5.6"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css?version=1.5.6"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#图像处理"><span class="toc-number">1.</span> <span class="toc-text">图像处理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#图像数据处理"><span class="toc-number">2.</span> <span class="toc-text">图像数据处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#TFRecord输入数据格式"><span class="toc-number">2.1.</span> <span class="toc-text">TFRecord输入数据格式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TFRecord格式"><span class="toc-number">2.1.1.</span> <span class="toc-text">TFRecord格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TFRecord样例"><span class="toc-number">2.1.2.</span> <span class="toc-text">TFRecord样例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#图像数据处理-1"><span class="toc-number">2.2.</span> <span class="toc-text">图像数据处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TensorFlow图像处理函数"><span class="toc-number">2.2.1.</span> <span class="toc-text">TensorFlow图像处理函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#图像编码处理"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">图像编码处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#图像大小调整"><span class="toc-number">2.2.1.2.</span> <span class="toc-text">图像大小调整</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#图像的裁剪和填充"><span class="toc-number">2.2.1.3.</span> <span class="toc-text">图像的裁剪和填充</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#图像翻转"><span class="toc-number">2.2.1.4.</span> <span class="toc-text">图像翻转</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#图像色彩调整"><span class="toc-number">2.2.1.5.</span> <span class="toc-text">图像色彩调整</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#图像标准化"><span class="toc-number">2.2.1.6.</span> <span class="toc-text">图像标准化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#处理标注框"><span class="toc-number">2.2.1.7.</span> <span class="toc-text">处理标注框</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.jpg"></div><div class="author-info__name text-center">NYY</div><div class="author-info__description text-center"></div><div class="follow-button"><a href="https://github.com/niuyuanyuanna" target="_blank">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">46</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">34</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">9</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://www.ouyangsong.com" target="_blank">欧阳松的博客</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://github.com/niuyuanyuanna/BlogImages/raw/master/background/tf.jpeg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">NYY's blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">Tensorflow图像处理</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-12-06</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Framework/">Framework</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2018/12/06/tensorflow/5.1Image_processing/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2018/12/06/tensorflow/5.1Image_processing/"></span></a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">2,784</span><span class="post-meta__separator">|</span><span>Reading time: 10 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a><font color="blue">图像处理</font></h1><h1 id="图像数据处理"><a href="#图像数据处理" class="headerlink" title="图像数据处理"></a>图像数据处理</h1><p>在前面的实验中，使用了卷积神经网络训练图像。但是在很多图像识别的问题中，相同物体在不同的亮度、对比度下的差别非常大，但这些因素都不应该影响最后的识别结果。此次实验将对图像数据进行预处理，使得训练得到的神经网络模型尽可能小地被无关因素所影响。</p>
<h2 id="TFRecord输入数据格式"><a href="#TFRecord输入数据格式" class="headerlink" title="TFRecord输入数据格式"></a>TFRecord输入数据格式</h2><p>TensorFlow提供了一种统一的格式来存储数据，就是TFRecord。在上一个实验中，使用了一个从类别名称到所有数据列表的词典来维护图像和类别的关系。但是这种方式的可扩展性非常差，当数据来源更加复杂、每个样例中的信息更加丰富之后，这种方式很难有效地记录输入数据中的信息，于是采用TensorFlow提供的TFRecord的格式来统一输入数据的格式。</p>
<h3 id="TFRecord格式"><a href="#TFRecord格式" class="headerlink" title="TFRecord格式"></a>TFRecord格式</h3><p>TFRecord 文件中的数据都是通过 tf.train.Example 以 Protocol Buffer(以下简称PB) 的格式存储。PB是Google的一种数据交换的格式，他独立于语言，独立于平台，以二进制的形式存在。它能更好的利用内存，方便复制和移动。<br>下面给出tf.train.Example的定义：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">message Example &#123;  </span><br><span class="line">    Features features = <span class="number">1</span>;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line">message Features&#123;  </span><br><span class="line">    map&lt;string,Feature&gt; featrue = <span class="number">1</span>;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line">message Feature&#123;  </span><br><span class="line">    oneof kind&#123;  </span><br><span class="line">        BytesList bytes_list = <span class="number">1</span>;  </span><br><span class="line">        FloatList float_list = <span class="number">2</span>;  </span><br><span class="line">        Int64List int64_list = <span class="number">3</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>从代码中我们可以看出， tf.train.Example 包含了一个字典，key是字符串，value为Feature，Feature可以取值为字符串（BytesList ）、浮点数列表（FloatList ）、整型数列表（Int64List ）。</p>
<h3 id="TFRecord样例"><a href="#TFRecord样例" class="headerlink" title="TFRecord样例"></a>TFRecord样例</h3><p>下面，使用样例，将MNIST输入数据转化为TFRecord的格式。</p>
<p>写入TFRecord文件主要分为下面几个步骤：</p>
<ul>
<li>获取需要转换的数据</li>
<li>将数据填入Example PB，并将Example PB转换为一个字符串</li>
<li>通过<code>tf.python_io.TFRecordWriter</code>将字符串写入TFRecord文件中。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="comment">#将MNIST输入数据转化为TFRecord的格式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow.examples.tutorials.mnist <span class="keyword">import</span> input_data</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment">#把传入的value转化为整数型的属性，int64_list对应着 tf.train.Example 的定义</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_int64_feature</span><span class="params">(value)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> tf.train.Feature(int64_list=tf.train.Int64List(value=[value]))</span><br><span class="line"></span><br><span class="line"><span class="comment">#把传入的value转化为字符串型的属性，bytes_list对应着 tf.train.Example 的定义</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_bytes_feature</span><span class="params">(value)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> tf.train.Feature(bytes_list=tf.train.BytesList(value=[value]))</span><br><span class="line">    </span><br><span class="line"><span class="comment">#读取MNIST数据</span></span><br><span class="line">mnist =input_data.read_data_sets(<span class="string">"/home/sun/AI/CNN/handWrite1/data"</span>,                                     dtype=tf.uint8, one_hot=<span class="keyword">True</span>)</span><br><span class="line"><span class="comment">#训练数据的图像，可以作为一个属性来存储</span></span><br><span class="line">images = mnist.train.images</span><br><span class="line"><span class="comment">#训练数据所对应的标签，可以作为一个属性来存储</span></span><br><span class="line">labels = mnist.train.labels</span><br><span class="line"><span class="comment">#训练数据的图像分辨率，可以作为一个属性来存储</span></span><br><span class="line">pixels = images.shape[<span class="number">0</span>]</span><br><span class="line"><span class="comment">#训练数据的数量</span></span><br><span class="line">num_examples = mnist.train.num_examples</span><br><span class="line"><span class="comment">#指定要写入TFRecord文件的地址</span></span><br><span class="line">filename = <span class="string">"./TFRecord/output.tfrecords"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建一个write来写TFRecord文件</span></span><br><span class="line">writer = tf.python_io.TFRecordWriter(filename)</span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> range(num_examples):</span><br><span class="line">    <span class="comment">#把图像矩阵转化为字符串</span></span><br><span class="line">    image_raw = images[index].tostring()</span><br><span class="line">    <span class="comment">#将一个样例转化为Example Protocol Buffer，并将所有的信息写入这个数据结构</span></span><br><span class="line">    example = tf.train.Example(features=tf.train.Features(feature=&#123;</span><br><span class="line">        <span class="string">'pixels'</span>: _int64_feature(pixels),</span><br><span class="line">        <span class="string">'label'</span>: _int64_feature(np.argmax(labels[index])),</span><br><span class="line">        <span class="string">'image_raw'</span>: _bytes_feature(image_raw)&#125;))</span><br><span class="line">    <span class="comment">#将 Example 写入TFRecord文件</span></span><br><span class="line">    writer.write(example.SerializeToString())</span><br><span class="line">    </span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure>
<p>以上代码可以将MNIST数据集中的所有训练数据存储到一个TFRecord文件中。当数据量较大时，可以写入到多个TFRecord文件。<br>接下来读取TFRecord文件：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#读取TFRecord文件中的数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建一个reader来读取TFRecord文件中的样例</span></span><br><span class="line">reader = tf.TFRecordReader()</span><br><span class="line"><span class="comment">#通过 tf.train.string_input_producer 创建输入队列</span></span><br><span class="line">filename_queue = tf.train.string_input_producer([<span class="string">"./TFRecord/output.tfrecords"</span>])</span><br><span class="line"><span class="comment">#从文件中读取一个样例</span></span><br><span class="line">_, serialized_example = reader.read(filename_queue)</span><br><span class="line"><span class="comment">#解析读入的一个样例</span></span><br><span class="line">features = tf.parse_single_example(</span><br><span class="line">	serialized_example,</span><br><span class="line">	features=&#123;</span><br><span class="line">		<span class="comment">#这里解析数据的格式需要和上面程序写入数据的格式一致</span></span><br><span class="line">		<span class="string">'image_raw'</span>: tf.FixedLenFeature([], tf.string),</span><br><span class="line">		<span class="string">'pixels'</span>: tf.FixedLenFeature([], tf.int64),</span><br><span class="line">		<span class="string">'label'</span>: tf.FixedLenFeature([], tf.int64),</span><br><span class="line">	&#125;)</span><br><span class="line"><span class="comment">#tf.decode_raw可以将字符串解析成图像对应的像素数组</span></span><br><span class="line">images = tf.decode_raw(features[<span class="string">'image_raw'</span>], tf.uint8)</span><br><span class="line"><span class="comment">#tf.cast可以将传入的数据转化为想要改成的数据类型</span></span><br><span class="line">labels = tf.cast(features[<span class="string">'label'</span>], tf.int32)</span><br><span class="line">pixels = tf.cast(features[<span class="string">'pixels'</span>], tf.int32)</span><br><span class="line"></span><br><span class="line">sess = tf.Session()</span><br><span class="line"><span class="comment">#启动多线程处理输入数据</span></span><br><span class="line">coord = tf.train.Coordinator()</span><br><span class="line">threads = tf.train.start_queue_runners(sess=sess, coord=coord)</span><br><span class="line"></span><br><span class="line"><span class="comment">#每次运行可以读取TFRecord文件中的一个样例。当所有样例都读完之后，在此样例中的程序会从头读取</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">	image, label, pixel = sess.run([images, labels, pixels])</span><br><span class="line">	print(label)</span><br></pre></td></tr></table></figure></p>
<h2 id="图像数据处理-1"><a href="#图像数据处理-1" class="headerlink" title="图像数据处理"></a>图像数据处理</h2><p>在之前的实验中，都是直接使用图像的原始像素矩阵输入模型，本次实验会通过对图像的预处理，来尽可能避免模型受到无关因素的影响。大多数情况下，图象的预处理过程可以提高模型的准确率。</p>
<h3 id="TensorFlow图像处理函数"><a href="#TensorFlow图像处理函数" class="headerlink" title="TensorFlow图像处理函数"></a>TensorFlow图像处理函数</h3><h4 id="图像编码处理"><a href="#图像编码处理" class="headerlink" title="图像编码处理"></a>图像编码处理</h4><p>RGB色彩模式的图像可以看成一个三维矩阵，矩阵中的每一个数表示了图像上的不同位置，不同颜色的亮度。然而图像在存储时并不是直接记录这些矩阵中的数字，而是记录经过压缩编码之后的结果。所以要将一张图像还原成一个三维矩阵，需要解码的过程。Tensorflow提供了对jpeg和png格式图像的编码/解码函数。以下代码示范了如何使用Tensorflow中对jpeg格式图像的编码/解码函数：<br>以下面这张图片为例：</p>
<center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/tensorflow/92736450.jpg" width="50%"><br></center>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">image_raw_data = tf.gfile.FastGFile(<span class="string">"/path/to/picture"</span>, <span class="string">'rb'</span>).read()</span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    img_data = tf.image.decde_jpeg(image_raw_data)</span><br><span class="line">    print(img_data.eval())</span><br><span class="line">    <span class="comment"># 输出解码后的三维矩阵，打印的内容为：</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    [[[252 252 252]</span></span><br><span class="line"><span class="string">  ...</span></span><br><span class="line"><span class="string">  [243 244 238]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> [[252 252 252]</span></span><br><span class="line"><span class="string">  ...</span></span><br><span class="line"><span class="string">  [243 244 238]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> [[252 252 252]</span></span><br><span class="line"><span class="string">  ...</span></span><br><span class="line"><span class="string">  [243 244 238]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> ...</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> [[249 249 249]</span></span><br><span class="line"><span class="string">  ...</span></span><br><span class="line"><span class="string">  [249 250 245]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> [[249 249 249]</span></span><br><span class="line"><span class="string">  ...</span></span><br><span class="line"><span class="string">  [249 250 245]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> [[249 249 249]</span></span><br><span class="line"><span class="string">  ...</span></span><br><span class="line"><span class="string">  [249 250 245]]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    plt.imshow(img_data.eval())</span><br><span class="line">    plt.show()</span><br><span class="line">    img_data = tf.image.convert_image_dtype(img_data, dtype=tf.float32)</span><br></pre></td></tr></table></figure>
<p>plt.show得到图像：</p>
<center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/tensorflow/80040349.jpg" width="50%"><br></center>

<p>接下来以这张图像为例，对 图像进行简单变换。</p>
<h4 id="图像大小调整"><a href="#图像大小调整" class="headerlink" title="图像大小调整"></a>图像大小调整</h4><p>神经网络输入节点的个数是固定的，所以在将图像的像素作为输入提供给神经网络之前，需要先将图像的大小统一。这就是图像大小调整需要完成的任务。 </p>
<p>图像大小调整有两种方式，第一种是通过算法使得新的图像尽量保存原始图像上的所有信息。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">resized = tf.image.resize_images(img_data, [<span class="number">300</span>, <span class="number">300</span>], method=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>其中<code>img_data</code>是上一步中已经解码后的图像数据。</p>
<p>Tensorflow提供了四种不同的方法，并且将它们封装到了tf.image.resize_image函数：method参数给出了调整图像大小的算法。</p>
<ol>
<li><code>method = Bilinear interpolation</code>双线性插值法</li>
<li><code>method = Nearest neighbor interpolation</code>最近邻法</li>
<li><code>method = Bicubic interpolation</code>双三次插值法</li>
<li><code>method = Area interpolation</code>面积插值法</li>
</ol>
<p>经过裁剪填充之后，得到下图：</p>
<center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/tensorflow/34359031.jpg" width="90%"><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/tensorflow/20164669.jpg" width="90%"><br></center>

<p>从图中可以看出不同的算法产生的结果会有细微的区别。除了将整张图像信息完整保存，tensorflow还提供了API对图像进行裁剪或者填充。</p>
<h4 id="图像的裁剪和填充"><a href="#图像的裁剪和填充" class="headerlink" title="图像的裁剪和填充"></a>图像的裁剪和填充</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">croped = tf.image.resize_image_with_crop_or_pad(img_data, <span class="number">1000</span>, <span class="number">1000</span>)</span><br><span class="line">padded = tf.image.resize_image_with_crop_or_pad(img_data, <span class="number">3000</span>, <span class="number">3000</span>)</span><br></pre></td></tr></table></figure>
<p>生成的图像如下所示：</p>
<center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/tensorflow/17956206.jpg" width="90%"><br></center>

<p>通过tf.image.central_crop函数可以按比例裁剪图像，这个函数的第一个参数为原始图像，第二个为调整比例，这个需要是一个(0,1]的实数。</p>
<p>上面介绍的图像裁剪函数都是截取或者填充图像中间的部分。Tensorflow也提供了tf.image.crop_to_bounding_box函数和tf.image.pad_to_bounding_box函数来裁剪或者填充给定区域的图像。</p>
<h4 id="图像翻转"><a href="#图像翻转" class="headerlink" title="图像翻转"></a>图像翻转</h4><p>Tensorflow提供了一些函数来支持对图像的翻转。以下代码实现了将图像上下翻转、左右翻转已经沿对角线翻转的功能：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将图像上下翻转</span></span><br><span class="line">flipped_up_down = tf.image.flip_up_down(img_data)</span><br><span class="line"><span class="comment"># 将图像左右翻转</span></span><br><span class="line">flipped_left_right = tf.image.flip_left_right(img_data)</span><br><span class="line"><span class="comment"># 将图像沿对角线翻转</span></span><br><span class="line">transposed = tf.image.transpose_image(img_data)</span><br></pre></td></tr></table></figure>
<p>得到的图像如下所示：</p>
<center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/tensorflow/39527516.jpg" width="75%"><br></center>

<p>在很多图像识别问题中，图像的翻转不会影响识别的结果。于是在训练图像识别的神经网络模型时，可以随机地翻转训练图像，这样训练得到的模型就可以识别不同角度的实体。比如假设在训练数据中所有的猫头都是向右的，那么训练出来的模型就无法很好的识别猫头向左的猫。虽然这个问题可以通过收集更多的训练数据来解决，但是通过随机翻转训练图像的方式可以在零成本的情况下很大程度地缓解该问题。所以随机翻转训练图像是一种很常用的图像预处理方式。Tensorflow提供了方便的API完成随机图像翻转的过程。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以一定概率上下翻转图像</span></span><br><span class="line">flipped = tf.image.random_flip_up_down(img_data)</span><br><span class="line"><span class="comment"># 以一定概率左右翻转图像</span></span><br><span class="line">flipped = tf.image.random_flip_left_right(img_data)</span><br></pre></td></tr></table></figure>
<h4 id="图像色彩调整"><a href="#图像色彩调整" class="headerlink" title="图像色彩调整"></a>图像色彩调整</h4><p>和图像翻转类似，调整图像的亮度、对比度、饱和度和色相在很多图像识别应用中都不会影响识别结果。所以在训练神经网络模型时，可以随机调整训练图像的这些属性，从而使得训练得到的模型尽可能小地受到无关因素的影响。</p>
<ul>
<li>调整图像亮度</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将图像的亮度-0.5</span></span><br><span class="line">adjusted = tf.image.adjust_brightness(img_data, <span class="number">-0.5</span>)</span><br><span class="line"><span class="comment"># 将图像的亮度+0.5</span></span><br><span class="line">adjusted = tf.image.adjust_brightness(img_data, <span class="number">0.5</span>)</span><br><span class="line"><span class="comment">#在[-max_delta, max_delta]的范围随机调整图像的亮度</span></span><br><span class="line">adjusted = tf.image.random_brightness(img_data, max_delta)</span><br></pre></td></tr></table></figure>
<p>将max_delta设置为1后，调整后所得图像为：</p>
<center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/tensorflow/90104314.jpg" width="75%"><br></center>

<ul>
<li>调整图像对比度</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 将图像的对比度-5</span><br><span class="line">adjusted = tf.image.adjust_contrast(img_data, -5)</span><br><span class="line"># 将图像的对比度+5</span><br><span class="line">adjusted = tf.image.adjust_contrast(img_data, 5)</span><br><span class="line"># 在[lower, upper]的范围随机调整图的对比度</span><br><span class="line">adjusted = tf.image.random_contrast(img_data, lower, upper)</span><br></pre></td></tr></table></figure>
<p>将lower, upper设置为0, 5后（lower不能为负数），调整后所得图像为：</p>
<center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/tensorflow/15455084.jpg" width="75%"><br></center>

<ul>
<li>调整图像色相</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将图像的色相加0.1</span></span><br><span class="line">adjusted = tf.image.adjust_hue(img_data, <span class="number">0.1</span>)</span><br><span class="line"><span class="comment"># 将图像的色相加0.6</span></span><br><span class="line">adjusted = tf.image.adjust_hue(img_data, <span class="number">0.6</span>)</span><br><span class="line"><span class="comment"># 在[0, max_delta]的范围随机调整图像的色相</span></span><br><span class="line">adjusted = tf.image.random_hue(img_data, max_delta)</span><br></pre></td></tr></table></figure>
<p>将max_delta设置为0.5后，得到的结果为：</p>
<center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/tensorflow/41049686.jpg" width="75%"><br></center>

<ul>
<li>调整图像饱和度</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将图像的饱和度-5</span></span><br><span class="line">adjusted = tf.image.adjust_saturation(img_data, <span class="number">-5</span>)</span><br><span class="line"><span class="comment"># 将图像的饱和度+5</span></span><br><span class="line">adjusted = tf.image.adjust_saturation(img_data, <span class="number">5</span>)</span><br><span class="line"><span class="comment"># 在[lower, upper]的范围随机调整图的饱和度</span></span><br><span class="line">adjusted = tf.image.random_saturation(image, lower, upper)</span><br></pre></td></tr></table></figure>
<p>将lower, upper设置为0, 5后（lower不能为负数），调整后所得图像为：</p>
<center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/tensorflow/86143789.jpg" width="75%"><br></center>

<h4 id="图像标准化"><a href="#图像标准化" class="headerlink" title="图像标准化"></a>图像标准化</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将代表一张图像的三维矩阵中的数字均值变为0，方差变为1</span></span><br><span class="line">adjusted = tf.image.per_image_standardization(image)</span><br></pre></td></tr></table></figure>
<p>标准化后和原图对比：</p>
<center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/tensorflow/36295859.jpg" width="75%"><br></center>

<h4 id="处理标注框"><a href="#处理标注框" class="headerlink" title="处理标注框"></a>处理标注框</h4><p>在很多图像识别的数据集中，图像中需要关注的物体通常会被标注框圈出来。下面这段代码展示了如何通过tf.image.draw_bounding_boxes函数在图像中加入标注框。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">NYY</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2018/12/06/tensorflow/5.1Image_processing/">http://yoursite.com/2018/12/06/tensorflow/5.1Image_processing/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Tensorflow/">Tensorflow</a><a class="post-meta__tags" href="/tags/入门教程/">入门教程</a><a class="post-meta__tags" href="/tags/CNN/">CNN</a></div><div class="social-share"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2018/12/06/others/picgo/"><i class="fa fa-chevron-left">  </i><span>七牛云图床迁移到github</span></a></div><div class="next-post pull-right"><a href="/2018/12/06/tensorflow/4.1迁移学习识别花/"><span>Inception-V3迁移学习</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'http://yoursite.com/2018/12/06/tensorflow/5.1Image_processing/';
  this.page.identifier = '2018/12/06/tensorflow/5.1Image_processing/';
  this.page.title = 'Tensorflow图像处理';
}
var d = document, s = d.createElement('script');
s.src = "https://" + 'niuyuanyuan' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-src" src="https://niuyuanyuan.disqus.com/count.js" async></script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2019 By NYY</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.6"></script><script src="/js/fancybox.js?version=1.5.6"></script><script src="/js/sidebar.js?version=1.5.6"></script><script src="/js/copy.js?version=1.5.6"></script><script src="/js/fireworks.js?version=1.5.6"></script><script src="/js/transition.js?version=1.5.6"></script><script src="/js/scroll.js?version=1.5.6"></script><script src="/js/head.js?version=1.5.6"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>