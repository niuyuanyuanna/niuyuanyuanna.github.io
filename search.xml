<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>数据结构之二叉树</title>
      <link href="/2018/04/06/dataStructureBinaryTree/"/>
      <url>/2018/04/06/dataStructureBinaryTree/</url>
      <content type="html"><![CDATA[<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><ul><li>向量的search操作效率较高，如二分查找，其效率可以达到$log(n)$，但其动态操作，无论是插入和删除，其效率都较低，需要线性的时间。</li><li>列表的search操作，其效率较低，需要线性的时间，但由于其循位置访问的方式，一旦给定具体的操作位置，对于列表的动态操作就只需要在局部进行，时间损耗为$O(1)$。</li><li>二叉树结合了向量和列表的优点，可以理解为二维的列表。将树形结构称为半线性结构。</li></ul><h3 id="树的基本概念"><a href="#树的基本概念" class="headerlink" title="树的基本概念"></a>树的基本概念</h3><ol><li>树： 在树型结构中，彼此元素之间的关系为edge，顶点为vertex，区别于列表中的node。需要为每一棵树指定一个特殊的顶点，称为根(root)。</li><li>有根树：指定了其中一个顶点作为根的树。通过彼此的嵌套，小型的有根树可以逐步地整合为规模更大的有根树。</li><li>兄弟树(sibling)：同一棵树的子树，它们之间根据度（degree）来度量。</li><li>度数、顶点、边数间的关系：顶点的度数之和 = 边数 = 顶点总数-1。度数和顶点数同阶，因此在考虑算法时间复杂度时，以顶点数n作为参照。</li><li>有序树：对有同一个父顶点的兄弟树编号，此时的这些兄弟树都是有序树。</li></ol><h3 id="树结构特性"><a href="#树结构特性" class="headerlink" title="树结构特性"></a>树结构特性</h3><h4 id="连通性"><a href="#连通性" class="headerlink" title="连通性"></a>连通性</h4><p>k+1个节点通过k条边依次相连，构成一条路径。其路径长度=边数。<br>连通图（connected）：节点之间均有路径</p><h4 id="无环性"><a href="#无环性" class="headerlink" title="无环性"></a>无环性</h4><p>当第1个节点和第k+1个节点相连时，构成一个环路（loop）<br>无环图（acyclic）：不含环路的图</p><h4 id="树特性"><a href="#树特性" class="headerlink" title="树特性"></a>树特性</h4><ul><li>无环连通图</li><li>极小连通图</li><li>极大无环图</li></ul><p>任一节点v与根之间存在唯一路径。因此一旦确定了根之后，所有的节点都可以根据这条唯一的路径定义一个参数depth，即v在这颗树中的深度。定义在path(v)上的节点为v的祖先（ancestor），v是它们的后代（descendent）。</p><ul><li>半线性：在任意深度v的祖先 / 后代存在，则必然 / 未必唯一。</li></ul><p>没有后代的节点称为叶子（leaf），所有叶子中深度最大的为树的高度，子树的高度也就是其根节点的深度。</p><h3 id="树的表示"><a href="#树的表示" class="headerlink" title="树的表示"></a>树的表示</h3><p>树结构的接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root()           根节点</span><br><span class="line">parent()         父节点</span><br><span class="line">firstChild()     长子</span><br><span class="line">nextSibling()    兄弟</span><br><span class="line">insert(i, e)     将e作为第i个孩子插入</span><br><span class="line">remove(i)        删除第i个孩子（及其后代）</span><br><span class="line">traverse()       遍历</span><br></pre></td></tr></table></figure></p><p>由于每个节点只有一个父节的特性，在向上查询时，可以取得很好的效果，但在向下查询时需要遍历所有节点。在表格中增加子节点的信息，使得向下查找只需遍历当前节点的子节点。</p><p><img src="http://p6um59a45.bkt.clouddn.com/18-4-8/65826164.jpg" alt=""></p><p>但是这样操作对于子节点仍然有些多余，因此考虑将子节点查找的结构变为：</p><p><img src="http://p6um59a45.bkt.clouddn.com/18-4-8/70722176.jpg" alt=""></p><p>每个节点均设置两个引用，横纵坐标方向为firstChild()，纵坐标方向为nextSibling()。</p><h2 id="二叉树-1"><a href="#二叉树-1" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树是节点度数不超过2的树，同一节点的孩子和子树用左右进行区分表示为：</p><ul><li>lChild()     ——   lSubtree()</li><li>rChiled()  ——   rSubtree()<br>这里已经隐含了树的有序性。</li></ul><h3 id="基本特性"><a href="#基本特性" class="headerlink" title="基本特性"></a>基本特性</h3><ul><li>所有深度为k的节点最多不超过$2^{k}$个</li><li>含有n个节点，高度为h的二叉树中，其数量关系为：$h&lt;n&lt;2^{h+1}$<ul><li>当$n=h+1$时，二叉树退化为一条单链</li><li>当$n=2^{h+1}-1$时，得到满二叉树(full binary tree)即所有节点的度数都是2</li></ul></li></ul><p>对于二叉树而言，其宽度随高度呈指数增长，称为涨宽。</p><ul><li>真二叉树：对于只有单分支或者叶子节点添加一个或2个对应数据为0的孩子，将这个二叉树变为一个满二叉树。<br><img src="http://p6um59a45.bkt.clouddn.com/18-4-8/51267035.jpg" alt=""></li></ul><p>二叉树可以描述任意一颗树，将任意一棵树用长子-兄弟法表示。多出的兄弟节点可以用兄弟节点的子节点表示。<br><img src="http://p6um59a45.bkt.clouddn.com/18-4-8/13837723.jpg" alt=""></p><h3 id="二叉树的实现"><a href="#二叉树的实现" class="headerlink" title="二叉树的实现"></a>二叉树的实现</h3><p>二叉树的基本组成单位是binary node。<br>BinNode模板类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># define BinNodePosi(T) BinNode&lt;T&gt;*   //节点位置</span><br><span class="line">template &lt;typename T&gt; struct BinNode&#123;</span><br><span class="line">    BinNodePosi(T) parent, lChild, rChild;</span><br><span class="line">    T data;</span><br><span class="line">    int height;  //高度</span><br><span class="line">    int size();  //子树规模</span><br><span class="line">    BinNodePosi(T) insertAsLC(T const &amp;);                 //作为左孩子插入</span><br><span class="line">    BinNodePosi(T) insertAsRC(T const &amp;);                 //作为右孩子插入</span><br><span class="line">    BinNodePosi(T) succ();                                //当前节点的直接后继</span><br><span class="line">    template &lt;typename VST&gt; void travLevel(VST &amp;);        //子树层次遍历</span><br><span class="line">    template &lt;typename VST&gt; void travPre(VST &amp;);          //子树先序遍历</span><br><span class="line">    template &lt;typename VST&gt; void travIn(VST &amp;);           //子树中序遍历</span><br><span class="line">    template &lt;typename VST&gt; void travPost(VST &amp;);        //子树后序遍历</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BinNode接口实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">BinNodePosi(T) BinNode&lt;T&gt;::insertAsLC(T const &amp; e)&#123;</span><br><span class="line">    return lChild = new BinNode(e, this);   // this.lChild = null</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">BinNodePosi(T) BinNode&lt;T&gt;::insertAsRC(T const &amp; e)&#123;  //只需要常数时间</span><br><span class="line">    return rChild = new BinNode(e, this);   // this.rChild = null</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;   </span><br><span class="line">int BinNode&lt;T&gt;::size()&#123;          //后代的总数是其根的子树之和。递归统计子树规模，需要线性时间</span><br><span class="line">    int s = 1;</span><br><span class="line">    if(lChild)&#123;</span><br><span class="line">        s += lChild-&gt;size();</span><br><span class="line">    &#125;</span><br><span class="line">    if(rChild)&#123;</span><br><span class="line">        s += rChild-&gt;size();</span><br><span class="line">    &#125;</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>BinTree模板：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt; class BinTree&#123;</span><br><span class="line">    protected:</span><br><span class="line">        int _size;</span><br><span class="line">        BinNodePosi(T) _root; //根节点</span><br><span class="line">        virtual int updateHeight(BinNodePosi(T) x);  //更新节点x高度</span><br><span class="line">        void updateHeightAbove(BinNodePosi(T) x);    //更新x及祖先高度</span><br><span class="line">    public:</span><br><span class="line">        int size() const&#123;return _size;&#125;              //国模</span><br><span class="line">        bool empty() const&#123;return !_root;&#125;           //判断是否为空树</span><br><span class="line">        BinNodePosi(T) root() const&#123;return _root;&#125;   //返回树根</span><br><span class="line">        /*子树接入、删除、分离接口*/</span><br><span class="line">        /*遍历接口  */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以高度更新接口为例：通过宏定义的封装方式高度，因为根据树的退化情况，其高度均不同。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># define stature(p) ((p) ? (p)-&gt;height : -1)</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">int BinTree&lt;T&gt;::updateHeight(BinNodePosi(T) x)&#123;</span><br><span class="line">    return x-&gt;height = 1 + max(stature(x-&gt;lChild), stature(x-&gt;rChild));   //采用常规二叉树规则，其时间复杂度为O(1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">void BinTree&lt;T&gt;::udateHeightAbouve(BinNodePosi(T) x)&#123;//向上更新节点高度，其时间复杂度正比于树的深度。</span><br><span class="line">    while(x)&#123;</span><br><span class="line">        updateHeight(x);</span><br><span class="line">        x = x-&gt;parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>节点插入：<br>在一个已有的树节点中，该节点原本没有右孩子。将新生成的一个节点插入到该节点的右侧，将其变为该节点的右孩子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt; </span><br><span class="line">BinNodePosi(T)BinTree&lt;T&gt;::insertAsRC(BinNoidePosi(T) x)&#123;</span><br><span class="line">    _size++;</span><br><span class="line">    x-&gt;insertAsRC(e);</span><br><span class="line">    updateHeightAbove(x);</span><br><span class="line">    return x-&gt;rChild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="二叉树相关算法"><a href="#二叉树相关算法" class="headerlink" title="二叉树相关算法"></a>二叉树相关算法</h3><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><p>按照某种次序访问数中的各个节点，使得每个节点被访问恰好一次。遍历分为先序、中序、后序，按照当前节点与其左右孩子节点的访问次序来划分。<br><img src="http://p6um59a45.bkt.clouddn.com/18-4-8/10018835.jpg" alt=""></p><ol><li>先序遍历，时间复杂度为$O(n)$<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T, typename VST&gt;</span><br><span class="line">void traverse(BinNodePosi(T) x, VST &amp; visit)&#123;</span><br><span class="line">    if(!x) return;  //先把树根节点取出访问再递归访问左右子节点</span><br><span class="line">    visit(x-&gt;data);</span><br><span class="line">    traverse(x-&gt;lChild, visit);</span><br><span class="line">    traverse(x-&gt;rChild, visit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>可以将尾递归的形式化简为迭代的形式，引入一个栈存储节点的位置。<br>第一种迭代方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T, typename VST&gt;</span><br><span class="line">void travPre_I1(BinNodePosi(T) x, VST &amp; visit)&#123;</span><br><span class="line">    Stack &lt;BinNodePosi(T)&gt; S;</span><br><span class="line">    if(x) S.push(x);</span><br><span class="line">    while(!S.empty())&#123;</span><br><span class="line">        x = S.pop();</span><br><span class="line">        visit(x-&gt;data);</span><br><span class="line">        if(HasRChild(*x)) S.push(x-&gt;rChild); //右孩子先入后出</span><br><span class="line">        if(HasLChild(*x)) S.push(x-&gt;lChild); //左孩子后入先出</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第一种迭代方法较难理解，不便于判断子节点的遍历次序，引入第二种迭代方法：<br><img src="http://p6um59a45.bkt.clouddn.com/18-4-8/51411613.jpg" alt=""><br>这种方法自上而下对做侧分支进行访问然后自下而上对右子树遍历。不同的右子树相互独立且自成一个子任务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T, typename VST&gt;</span><br><span class="line">static void visitAlongLeftBranch(BinNodePosi(T) x, VST &amp; visit, Stack &lt;BinNodePosi(T)&gt; &amp; S)&#123;</span><br><span class="line">    while(x)&#123;</span><br><span class="line">        visit(x-&gt;rChild);   //访问当前节点</span><br><span class="line">        S.push(x-&gt;rChild);  //右孩子入栈</span><br><span class="line">        x = x-&gt;lChild;      //沿左侧链下行</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T, typename VST&gt;</span><br><span class="line">void travPre_I2(BinNodePosi(T) x, VST &amp; visit)&#123;</span><br><span class="line">    Stack &lt;BinNodePosi(T)&gt; S;</span><br><span class="line">    while(true)&#123;</span><br><span class="line">        visitAlongLeftBranch(x, visit, S);</span><br><span class="line">        if(S.empty()) break;</span><br><span class="line">        x = S.pop();      //弹出下一子树根</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>visitAlongLeftBranch()这个函数会从当前节点一直访问左侧链，并自下而上的将右子节点存入栈中。主循环只需要重复执行这个函数直到栈为空退出。</p><ol start="2"><li>中序遍历<br>递归算法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T, typename VST&gt;</span><br><span class="line">void traverse(BinNodePosi(T) x, VST &amp; visit)&#123;</span><br><span class="line">    if(!x) return;  </span><br><span class="line">    traverse(x-&gt;lChild, visit);</span><br><span class="line">    visit(x-&gt;data);</span><br><span class="line">    traverse(x-&gt;rChild, visit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>根据观察可以发现中序遍历是从根节点开始沿左侧分支向下，直到找到最后一个左孩子，访问左孩子后再访问上层节点，最后访问该上层节点的右孩子。<br><img src="http://p6um59a45.bkt.clouddn.com/18-4-8/99511231.jpg" alt=""><br>迭代算法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">static void goAlongLeftBranch(BinNodePosi(T) x, Stack &lt;BinNodePosi(T)&gt; &amp; S)&#123;</span><br><span class="line">    while(x)&#123;</span><br><span class="line">        //visit(x-&gt;rChild);   //访问当前节点</span><br><span class="line">        //S.push(x-&gt;rChild);  //右孩子入栈</span><br><span class="line">        S.push(x);</span><br><span class="line">        x = x-&gt;lChild;      //沿左侧链下行</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T, typename VST&gt;</span><br><span class="line">void trav_I1(BinNodePosi(T) x, VST &amp; visit)&#123;</span><br><span class="line">    Stack &lt;BinNodePosi(T)&gt; S;</span><br><span class="line">    while(true)&#123;</span><br><span class="line">        goAlongLeftBranch(x, S);</span><br><span class="line">        if(S.empty()) break;</span><br><span class="line">        x = S.pop();      //左侧节点访问</span><br><span class="line">        visit(x-&gt;data);</span><br><span class="line">        x = x-&gt;rChild;    //转向右子树，当右子树为空时进行处理。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>goAlongLeftBranch（）函数从当前节点出发，逐批将左侧节点逆序入栈，直到找到最左侧节点。在主函数中弹出栈顶节点，进行访问后再转向右子树。最终主程序的时间复杂度为$O(n)$。</p><ol start="3"><li>后续遍历<br>递归算法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T, typename VST&gt;</span><br><span class="line">void traverse(BinNodePosi(T) x, VST &amp; visit)&#123;</span><br><span class="line">    if(!x) return;  </span><br><span class="line">    traverse(x-&gt;lChild, visit);</span><br><span class="line">    traverse(x-&gt;rChild, visit);</span><br><span class="line">    visit(x-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><img src="http://p6um59a45.bkt.clouddn.com/18-4-8/66214575.jpg" alt=""><br>在后序遍历的过程中，从左侧链最后一个节点开始，再访问其右子节点，再自下而上访问其父节点。<br>迭代算法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">static void gotoHLVFL(Stack &lt;BinNodePosi(T)&gt; &amp; S)&#123;</span><br><span class="line">    while(BinNodePosi(T) x= S.top())&#123;</span><br><span class="line">        if(HasLChild(*x))&#123;</span><br><span class="line">            if(HasRChild(*x)) S.push(x-&gt;rChild);</span><br><span class="line">            S.push(x-&gt;lChild);</span><br><span class="line">        &#125;else</span><br><span class="line">            S.push(x-&gt;rChild);</span><br><span class="line">    S.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T, typename VST&gt;</span><br><span class="line">void travPost_I(BinNodePosi(T) x, VST &amp; visit)&#123;</span><br><span class="line">    Stack &lt;BinNodePosi(T)&gt; S;</span><br><span class="line">    if(x) S.push(x);</span><br><span class="line">    while(!S.empth())&#123;</span><br><span class="line">        if(S.top()!=x-&gt;parent) gotoHLVFL(S);</span><br><span class="line">        x = S.pop();      //左侧节点访问</span><br><span class="line">        visit(x-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="4"><li>层次遍历<br>上面的三种遍历方式都存在子节点先于父节点接受访问的逆序情况，因此使用栈进行存储。对于层次遍历而言，所有子节点都应严格的后于父节点接受访问，即为顺序对每层访问，需要用到队列。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T, typename VST&gt;</span><br><span class="line">void BinNode&lt;T&gt;::travPost_I( VST &amp; visit)&#123;</span><br><span class="line">    Queue&lt;BinNodePosi(T)&gt; Q;</span><br><span class="line">    Q.enqueue(this);</span><br><span class="line">    while(!Q.empty())&#123;</span><br><span class="line">        BinNodePosi(T) x = Q.dequeue();          //取出队首节点并访问</span><br><span class="line">        visit(x-&gt;data);</span><br><span class="line">        if(HasLChild(*x) Q.enqueue(x-&gt;lChild));  //左孩子入队</span><br><span class="line">        if(HasRChild(*x) Q.enqueue(x-&gt;rChild));  //右孩子入队</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>每个节点入队、出队的操作恰好为1次，整体的时间复杂度为$O(n)$</p><h4 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h4><p>已知二叉树的排列序列，还原出二叉树。<br>已知树的中序 + 先序/后序 即可还原出原始的二叉树。</p>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据结构之栈和队列</title>
      <link href="/2018/04/06/dataStructureStackAndQueue/"/>
      <url>/2018/04/06/dataStructureStackAndQueue/</url>
      <content type="html"><![CDATA[<h1 id="栈（stack）"><a href="#栈（stack）" class="headerlink" title="栈（stack）"></a>栈（stack）</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>栈仍然是一个序列，遵循后进先出的原则。可以基于向量或列表派生，共有三种操作方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push()    入栈   insert(size(), e)</span><br><span class="line">pop()     出栈   remove(size() -1)       </span><br><span class="line">top()     取顶操作    (*this)[size() -1]</span><br></pre></td></tr></table></figure><h2 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h2><ul><li>逆序输出：conversion 输出次序与处理过程颠倒，递归深度和输出长度不易预知</li><li>递归嵌套：stack permutation + parenthesis 具有自相似性的问题可递归描述，但分支位置和嵌套深度不固定</li><li>延迟缓冲：evaluation 线性扫描算法模式中，在预读足够长之后，才能确定可处理的前缀</li></ul><h3 id="逆序输出"><a href="#逆序输出" class="headerlink" title="逆序输出"></a>逆序输出</h3><p>逆序输出的一个应用为进制转换，将整除后的余数入栈，最后出栈。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void convert(Stack&lt;char&gt; &amp; S, _int64)&#123;</span><br><span class="line">    static char digit[] = &#123;&apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;&#125;;</span><br><span class="line">    while(n&gt;0)&#123;</span><br><span class="line">        S.push(digit[n % base]);</span><br><span class="line">        n /= base;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">main()&#123;</span><br><span class="line">    Stack&lt;char&gt; S;</span><br><span class="line">    convert(S, n, base);</span><br><span class="line">    while(!S.empty())</span><br><span class="line">        print(&quot;%c&quot;, S.pop());    //逆序逆序输出</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="递归嵌套"><a href="#递归嵌套" class="headerlink" title="递归嵌套"></a>递归嵌套</h3><p>括号匹配是递归嵌套的一种应用。找到括号的方法即是遇到“（”则入栈，遇到“）”则出栈。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bool paren(const char exp[], int lo, int hi)&#123;</span><br><span class="line">    Stack&lt;char&gt; S;</span><br><span class="line">    for(int i = lo; i &lt; hi; i++)&#123;</span><br><span class="line">        if(&apos;(&apos; == exp[i])          //若遇到(则进栈</span><br><span class="line">            S.push(exp[i]);</span><br><span class="line">        else if(!S.empty())        //若遇到)且栈非空则出栈</span><br><span class="line">            S.pop();</span><br><span class="line">        else return false;         //若遇到)时栈已空，则不匹配</span><br><span class="line">    &#125;</span><br><span class="line">    return S.empty();              //只有栈为空时匹配</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种算法可以便捷的推广到多种括号并存的情况，也可以引申至HTML语言中的标签上。</p><h4 id="栈混洗"><a href="#栈混洗" class="headerlink" title="栈混洗"></a>栈混洗</h4><p>将A栈的栈顶弹出存入S中转栈，然后将S栈的栈顶弹出存入到B栈，完成栈的混洗。若A全部转入S后弹出，A和B的栈顶和栈底顺序正好颠倒，若S弹出的开始时间是随机的，那么B栈中存储的数据顺序就是随机的。因此栈混洗的情况有catalan数种：$\frac{2n!}{\left ( n + 1 \right )!\times n!}$。<br>在级数排序时，有几种排序是禁形，如A中元素为123，B中为312，此时B不可能通过混洗得到。若一个排列是栈混洗，当且仅当其排序不包含312的形式。<br>判定是否为栈混洗的时候：</p><ul><li>每次S.pop()之前，判断S是否为空</li><li>若需弹出的元素在S中，却非顶元素</li></ul><h3 id="延迟缓冲"><a href="#延迟缓冲" class="headerlink" title="延迟缓冲"></a>延迟缓冲</h3><p>中缀表达式求值为延迟缓冲的应用<br>以算数表达式为例 ：求值算法=栈+线性扫描<br>实现算法：用两个栈分别存储运算数和运算符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">float evaluate(char* S, char* &amp; RPN)&#123;        //RPN转换</span><br><span class="line">    Stack&lt;float&gt; opnd;                       //运算数栈</span><br><span class="line">    Stack&lt;char&gt; optr;                        //运算符栈</span><br><span class="line">    optr.push(&apos;\0&apos;);                          //尾哨兵</span><br><span class="line">    while(!optr.empty())&#123;</span><br><span class="line">        if(isdigit(*S))</span><br><span class="line">            readNumber(S, opnd);             //读入操作数，可能为多位</span><br><span class="line">            append(RPN, opend.top());        //接入RPN</span><br><span class="line">        else&#123;</span><br><span class="line">            switch(orderBetween(optr.top(), *S))&#123; //分别处理，判断当前运算符和栈顶运算符之间的优先级高低       </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return opnd.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在读入操作数时，需要进行处理，因为读入数可能是多位。如果当前number为一位数字，就入栈；如果是多位数字就需要对这几位数字进行处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">float evaluate(char* S, char* &amp; RPN)&#123;        //RPN转换</span><br><span class="line">    Stack&lt;float&gt; opnd;                       //运算数栈</span><br><span class="line">    Stack&lt;char&gt; optr;                        //运算符栈</span><br><span class="line">    optr.push(&apos;\0&apos;);                         //尾哨兵</span><br><span class="line">    int numBits = 0;                         //用于存储数字的位数</span><br><span class="line">    while(!optr.empty())&#123;</span><br><span class="line">        if(isdigit(*S))</span><br><span class="line">            numBits += 1;</span><br><span class="line">            readNumber(S, opnd, numBits);    //读入操作数，可能为多位</span><br><span class="line">            append(RPN, opend.top());        //接入RPN</span><br><span class="line">        else&#123;</span><br><span class="line">            numBits = 0;</span><br><span class="line">            switch(orderBetween(optr.top(), *S))&#123; //分别处理，判断当前运算符和栈顶运算符之间的优先级高低       </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return opnd.pop();</span><br><span class="line">&#125;</span><br><span class="line">float readNumber(char* S, Stack opnd, int num)&#123;  </span><br><span class="line">    if(num &lt; 2)&#123;</span><br><span class="line">        opnd.push(*S);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        float oOpnd = S;</span><br><span class="line">        for(i=2; i&lt;=n; i++)&#123;</span><br><span class="line">            float bitNum = opnd.pop()*10^(i-1)</span><br><span class="line">            oOpnd += bitNum;</span><br><span class="line">        &#125;</span><br><span class="line">        opnd.push(oOpnd);        </span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>判断运算符优先级采用表格存储，行为当前运算符，列为栈顶运算符 。</p><p><img src="https://i.loli.net/2018/04/06/5ac719f3997ef.png" alt=""></p><p>对于不同优先级的处理方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">switch(orderBetween(optr.top(), *S))&#123;</span><br><span class="line">    case &apos;&lt;&apos;:                                  //栈顶优先级低，推迟计算，当前运算符入栈</span><br><span class="line">        optr.push(*S);</span><br><span class="line">        S++;</span><br><span class="line">        break;</span><br><span class="line">    case &apos;=&apos;:                                  //优先级相等，脱括号，接收下一字符。只有在括号和\0的时候才有=出现</span><br><span class="line">        optr.pop();</span><br><span class="line">        S++;</span><br><span class="line">        break;</span><br><span class="line">    case &apos;&gt;&apos;:                                  //栈顶优先级高，栈顶运算符出栈，执行计算</span><br><span class="line">        char op = optr.pop();</span><br><span class="line">        append(RPN, op);     //接入RPN</span><br><span class="line">        if(&apos;!&apos; == op) </span><br><span class="line">            opnd.push(calcu(op, opnd.pop()))    //一元运算符入栈</span><br><span class="line">        else&#123;</span><br><span class="line">            float pOpnd2 = opnd.pop();</span><br><span class="line">            float pOpnd1 = opnd.pop();</span><br><span class="line">            opnd.push(calcu(pOpnd1, op, pOpnd2));</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逆波兰表达式（RPN）：不使用括号表示优先级，所有操作数的次序和在中缀表达式中的次序相同。</p><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><h2 id="队列基础"><a href="#队列基础" class="headerlink" title="队列基础"></a>队列基础</h2><p>队列接口与实现，先进先出，后进后出，其操作为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dequeue()                                 头部删除</span><br><span class="line">front()                                   头部查询</span><br><span class="line">enqueue(e)                                尾部插入 </span><br><span class="line">rear()                                    尾部查询</span><br></pre></td></tr></table></figure></p><p>其模板类可以直接基于向量或列表派生。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt; class Queue:public List&lt;T&gt;&#123;</span><br><span class="line">    public:   //size()和empty()可以直接继承</span><br><span class="line">    T dequeue()&#123;</span><br><span class="line">        return remove(first());</span><br><span class="line">    &#125;</span><br><span class="line">    T &amp; front()&#123;</span><br><span class="line">        return first()-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据结构之列表</title>
      <link href="/2018/04/05/dataStructureList/"/>
      <url>/2018/04/05/dataStructureList/</url>
      <content type="html"><![CDATA[<h1 id="列表基础"><a href="#列表基础" class="headerlink" title="列表基础"></a>列表基础</h1><p>对于数据结构的操作可以分为两类：</p><ul><li>静态：仅读取get      $O(1)$、search    $O(logn)$操作</li><li>动态：需写入insert  $O(n)$、remove  $O(n)$操作<br>列表采用动态存储策略：</li><li>列表元素称为节点（node）</li><li>各节点通过指针或引用彼此联接，形成一个线性序列</li><li>相邻节点彼此互称为前驱（predecessor）或后继（successor）</li></ul><h2 id="向量与列表的区别"><a href="#向量与列表的区别" class="headerlink" title="向量与列表的区别"></a>向量与列表的区别</h2><ul><li><p>向量：可根据元素的秩直接确定其物理地址。元素V[i]的物理地址为<br>$V + i × s$<br>(s为单个单元占用的空间量)。寻秩访问效率较高。</p></li><li><p>列表：也可以进行循秩访问，但效率较低。应改为循位置访问（call-by-position）的方式，利用节点之间的互相引用，找到指定节点。</p></li></ul><h2 id="列表节点ADT接口"><a href="#列表节点ADT接口" class="headerlink" title="列表节点ADT接口"></a>列表节点ADT接口</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pred()                                  当前节点前驱节点位置</span><br><span class="line">succ()                                  当前节点后继节点的位置</span><br><span class="line">data()                                  当前节点所存的数据对象</span><br><span class="line">insertAsPred(e)                         插入前驱节点，存入被引用对象e，返回新节点位置</span><br><span class="line">insertAsSuccess(e)                      插入后继节点，存入被引用对象e，返回新节点位置</span><br></pre></td></tr></table></figure><p>定义ListNode模板类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#define Posi(T) ListNode&lt;T&gt;*</span><br><span class="line">template &lt;typname T&gt;</span><br><span class="line">struct ListNode&#123;</span><br><span class="line">    T data;</span><br><span class="line">    Posi(T) pred;</span><br><span class="line">    Posi(T) succ;</span><br><span class="line">    ListNode() &#123;&#125;;</span><br><span class="line">    ListNode(T e, Posi(T) p = NULL, Posi(T) s = NULL)</span><br><span class="line">        : data(e), pred(p), succ(s) &#123;&#125;</span><br><span class="line">    Posi(T) insertAsPred(T const&amp; e);</span><br><span class="line">    Posi(T) insertAsSucc(T const&amp; e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接口操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">size()</span><br><span class="line">first(), last()                               返回首、末节点的位置</span><br><span class="line">insertAsFirst(e), insertAsLast(e)             将e当做末节点插入</span><br><span class="line">insertBefore(p, e), insertAfter(p, e)         将e当做节点p的直接前驱、后继插入</span><br><span class="line">remove(r)</span><br><span class="line">disordered()</span><br><span class="line">sort()</span><br><span class="line">find(e)                                        查找目标元素e</span><br><span class="line">search(e)                                      查找目标元素e，返回不大于e且秩最大的元素</span><br><span class="line">deduplicate()                                  删除重复元素</span><br><span class="line">uniquify()                                     删除重复元素</span><br><span class="line">traverse()                                     遍历向量并统一处理</span><br></pre></td></tr></table></figure></p><p>在List结构中，为了便于理解，定义：</p><table><thead><tr><th style="text-align:center">-1</th><th style="text-align:center">0</th><th style="text-align:center">……</th><th style="text-align:center">n-1</th><th style="text-align:center">n</th><th></th></tr></thead><tbody><tr><td style="text-align:center">header（头哨兵）</td><td style="text-align:center">first（首节点）</td><td style="text-align:center">……</td><td style="text-align:center">last(末节点)</td><td style="text-align:center">trailer(尾哨兵)</td><td></td></tr><tr><td style="text-align:center">固定存在</td><td style="text-align:center">可能不存在</td><td style="text-align:center">……</td><td style="text-align:center">可能不存在</td><td style="text-align:center">固定存在</td><td></td></tr><tr><td style="text-align:center">对外部invisible</td><td style="text-align:center">对外部visible</td><td style="text-align:center">对外部visible</td><td style="text-align:center">对外部visible</td><td style="text-align:center">对外部invisible</td></tr></tbody></table><h1 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h1><h2 id="寻秩访问"><a href="#寻秩访问" class="headerlink" title="寻秩访问"></a>寻秩访问</h2><p>无序列表可以进行循秩访问，可通过重载下标操作符进行，其时间复杂度为$O(r)$，效率低下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">T List&lt;T&gt;::operator[](Rank r) const&#123;</span><br><span class="line">    Posi(T) p = first();</span><br><span class="line">    while(0 &lt; r--)</span><br><span class="line">        p = p-&gt;succ;</span><br><span class="line">    return p-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="节点查找"><a href="#节点查找" class="headerlink" title="节点查找"></a>节点查找</h2><p>当有多个重复元素的时候，会首先停止在最靠后的位置，在最坏情况下时间复杂度为$O(n)$<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">Posi(T) List&lt;T&gt;::find(T const &amp; e, int  n, Posi(T) p) const&#123;</span><br><span class="line">    while(0 &lt; n--)&#123;                  //命中或越界才返回</span><br><span class="line">        if(e == (p = p-&gt;pred)-&gt;data) //取出当前节点的数据域并与e比对</span><br><span class="line">            return p;</span><br><span class="line">    &#125;</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">find(e, n, p)         //在p的n个前驱中查找指定元素e</span><br><span class="line">find(e, p, n)         //在p的n个后继中查找指定元素e</span><br></pre></td></tr></table></figure></p><h2 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h2><p>当this指向的是首节点，这样操作会使插入的节点的前驱变为头节点。具体步骤为创建新节点时指定新节点的前驱和后继，即将当前节点前驱的后继指定为新节点，将当前节点后继的前驱指定为新节点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">Posi(T) List&lt;T&gt;::insertBefore(Posi(T) p, T const&amp; e)&#123;</span><br><span class="line">    _size++;</span><br><span class="line">    return p-&gt;insertAsPred(e);</span><br><span class="line">&#125;</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">Posi(T) ListNode&lt;T&gt;::insertAsPred(T const&amp; e)&#123;</span><br><span class="line">    Posi(T) x = new ListNode(e, pred, this);  //首先创建一个ListNode，耗时</span><br><span class="line">    pred -&gt;succ = x;                          //创建连接</span><br><span class="line">    pred = x;</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>insertAsLast(e)   等价于  insertBefore(trailer, e)<br>基于复制的构造：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">void List&lt;T&gt;::copyNodes(Posi(T) p, int n)&#123;</span><br><span class="line">    init();                                 //创建空的列表</span><br><span class="line">    while(n--)&#123; </span><br><span class="line">        insertAsLast(p-&gt;data);              //将从p开始的n项依次作为末节点插入</span><br><span class="line">        p = p-&gt;succ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h2><p>在列表中删除指定元素时间复杂度为$O(1)$。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">T List&lt;T&gt;::remove(Posi(T) p)&#123;</span><br><span class="line">    T e = p-&gt;data;              //备份删除节点的数据</span><br><span class="line">    p-&gt;pred-&gt;succ = p-&gt;succ;    //待删除节点的后继 变为 待删除节点的前驱的后继</span><br><span class="line">    p-&gt;succ-&gt;pred = p-&gt;pred;    //待删除节点的前驱 变为 待删除节点的后继的前驱</span><br><span class="line">    delete p;</span><br><span class="line">    _size--;</span><br><span class="line">    return e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>销毁一个已有的列表(析构)，时间复杂度为$O(n)$，相当于反复执行remove操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt; </span><br><span class="line">List&lt;T&gt;::~List()&#123;</span><br><span class="line">    clear();                   //删除所有可见节点</span><br><span class="line">    delete header;</span><br><span class="line">    delete trailer;</span><br><span class="line">&#125;</span><br><span class="line">template &lt;typename T&gt; </span><br><span class="line">int List&lt;T&gt;::clear()&#123;</span><br><span class="line">    int oldSize = _size;</span><br><span class="line">    while(0 &lt; _size)&#123;</span><br><span class="line">        remove(header-&gt;succ)    //反复删除首节点，直到列表为空</span><br><span class="line">    &#125;</span><br><span class="line">    return oldSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="列表唯一化"><a href="#列表唯一化" class="headerlink" title="列表唯一化"></a>列表唯一化</h2><p>将列表分为三部分：</p><ul><li>已经没有重复元素的前面部分</li><li>当前查找的元素e</li><li>还未进行查找的后面部分<br>使用find操作从首节点遍历至末节点，在当前节点的前驱中查找与当前节点数据相同的节点。其时间复杂度为$O(n^{2})$。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T &gt;</span><br><span class="line">int List&lt;T&gt;::deduplicate()&#123;</span><br><span class="line">    if(_size &lt; 2) return 0;</span><br><span class="line">    int oldSize = _size;</span><br><span class="line">    Posi(T) p = first();                    //初始化</span><br><span class="line">    Rank r = 1;</span><br><span class="line">    while(trailer != (p=p-&gt;succ))&#123;          //遍历从首节点直至末节点</span><br><span class="line">        Posi(T) q = find(p-&gt;data, r, p);    //在p的r个前驱中查找相同的元素，r即整个前缀的长度也就是第一部分的长度</span><br><span class="line">        q ? remove(q) : r++;                //如果有就删除该元素，没有就r++</span><br><span class="line">    &#125;</span><br><span class="line">    return oldSize - _size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h1><h2 id="列表唯一化-1"><a href="#列表唯一化-1" class="headerlink" title="列表唯一化"></a>列表唯一化</h2><p>有序列表的唯一化比无序列表的耗时少，因为其有序，则只需要检测相邻节点的数据是否相同，其时间复杂度为$O(n)$。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typname T&gt; </span><br><span class="line">int List&lt;T&gt;::uniquify()&#123;</span><br><span class="line">    if(_size &lt; 2)</span><br><span class="line">        return 0;</span><br><span class="line">    int oldSize = _size;</span><br><span class="line">    ListNodePosi(T) p = first();</span><br><span class="line">    ListNodePosi(T) q;</span><br><span class="line">    while(trailer != (q=p-&gt;succ))&#123;       //从首节点遍历到尾节点</span><br><span class="line">        if(p-&gt;data != q-&gt;data)           //若相邻节点互异则转入下一个区段</span><br><span class="line">            p = q;</span><br><span class="line">        else </span><br><span class="line">            remove(q);</span><br><span class="line">    &#125;</span><br><span class="line">    return oldSize - _size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="列表查找"><a href="#列表查找" class="headerlink" title="列表查找"></a>列表查找</h2><p>其平均时间复杂度为$O(n)$<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;  &#123;</span><br><span class="line">Posi(T) List&lt;T&gt;::search(T const &amp; e, int n, Posi(T) p) const&#123;</span><br><span class="line">    while(0 &lt;= n--)&#123;                     //对p的最近n个前驱，从右向左逐个比较</span><br><span class="line">        if(((p = p-&gt;pred)-&gt;data) &lt;= e)</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="列表排序"><a href="#列表排序" class="headerlink" title="列表排序"></a>列表排序</h1><h2 id="选择排序法（selection-sort）"><a href="#选择排序法（selection-sort）" class="headerlink" title="选择排序法（selection sort）"></a>选择排序法（selection sort）</h2><p>类似于冒泡排序法，将序列分成两部分</p><ul><li>前半部分是无序子序列，但最大值不超多后半部分的最小值</li><li>后半部分是有序子序列</li></ul><p>改进方法：</p><ul><li>找到前部分的最大值</li><li>将最大值移到后半部分的最前端</li></ul><p>对列表中起始于位置P的连续n个元素做选择排序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typname T&gt;    &#123;&#125;</span><br><span class="line">void List&lt;T&gt;::selectionSort(Posi(T) p, int n)&#123;</span><br><span class="line">    Posi(T) head = p-&gt;pred;         //头哨兵初始化</span><br><span class="line">    Posi(T) tail = p;</span><br><span class="line">    for(int i = 0; i &lt; n; i++)&#123;     //尾哨兵初始化</span><br><span class="line">        tail = tail-&gt;succ;</span><br><span class="line">    &#125;</span><br><span class="line">    while(1 &lt; n)&#123;</span><br><span class="line">        insertBefore(tail, remove(selectMax(head-&gt;succ, n)));  //remove返回节点数据</span><br><span class="line">        tail = tail-&gt;pred;</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Posi(T) List&lt;T&gt;:selectMax(Posi(T), int n)&#123;</span><br><span class="line">    Posi(T) max = p;</span><br><span class="line">    for(Posi(T) cur = p; 1 &lt; n; n--)&#123;    //遍历后续节点</span><br><span class="line">        if(!lt((cur = cur-&gt;succ)-&gt;data, max-&gt;data)) </span><br><span class="line">            max = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    return max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在选择最大元素时，!lt（not less than）意思是前者比后者不小，也就是&gt;=，如果改为严格&gt;算法会不稳定，遇到相同的max元素的时候无法将该元素移动到末尾。<br>insert和remove都需要动态分配空间，即new一个ListNode和delete，消耗时间，因此需要优化。该算法时间复杂度为$\theta \left ( n^{2} \right )$。</p><h2 id="插入排序法（insert-sort"><a href="#插入排序法（insert-sort" class="headerlink" title="插入排序法（insert sort)"></a>插入排序法（insert sort)</h2><p>将列表看成两个部分：</p><ul><li>前部分sorted</li><li>后部分unsorted</li></ul><p>算法从左到右进行插值，仅使用$O(1)$的辅助空间，属于就地算法(in-place)，时间复杂度为$O(n^{2})$。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">void List&lt;T&gt;::insertionSort(Posi(T) p, int n)&#123;</span><br><span class="line">    for(int r = 0; r &lt; n; r++)&#123;</span><br><span class="line">        insertAfter(search(p-&gt;data, r, p))   //search会返回在p的前面r个元素中不大于p对应的数据的最大值的位置，之后insert在那个位置之后</span><br><span class="line">        p = p-&gt;succ;                         //p转向直接后继</span><br><span class="line">        remove(p-&gt;pred);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="逆序对（inversion）"><a href="#逆序对（inversion）" class="headerlink" title="逆序对（inversion）"></a>逆序对（inversion）</h3><p>在插值排序的过程中，将当前元素插入到前缀中的合适位置时，当前元素和前缀中的后缀部分会构成i对逆序对，该值就是search所需的次数，所以总体的插值损耗时间为$O(I + n)$。此算法具有输入敏感(input-sensitive)特性。</p>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据结构之向量</title>
      <link href="/2018/04/04/hello-world/"/>
      <url>/2018/04/04/hello-world/</url>
      <content type="html"><![CDATA[<p>&emsp;&emsp;根据清华大学邓俊辉老师的课程整理记录。使用C++编程。</p><h2 id="向量基础"><a href="#向量基础" class="headerlink" title="向量基础"></a>向量基础</h2><h3 id="向量概念"><a href="#向量概念" class="headerlink" title="向量概念"></a>向量概念</h3><p>&emsp;&emsp;向量是数组的抽象与泛化，由一组元素按照现行次序封装而成。</p><ul><li>各元素与[0,n)内的秩一一对应</li><li>元素类型不限于基本类型 </li><li>操作、管理、维护更简化、统一、安全</li><li>可更为敏捷参与复杂数据结构的控制与实现</li></ul><p>&emsp;&emsp;向量ADT接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">size()</span><br><span class="line">get()</span><br><span class="line">put(r,e)</span><br><span class="line">insert(r,e)</span><br><span class="line">remove(r)</span><br><span class="line">disordered()</span><br><span class="line">sort()</span><br><span class="line">find(e)                 查找目标元素e</span><br><span class="line">search(e)               查找目标元素e，返回不大于e且秩最大的元素</span><br><span class="line">deduplicate()           删除重复元素</span><br><span class="line">uniquify()              删除重复元素</span><br><span class="line">traverse()              遍历向量并统一处理</span><br></pre></td></tr></table></figure><h2 id="无序向量"><a href="#无序向量" class="headerlink" title="无序向量"></a>无序向量</h2><h3 id="向量的动态扩容"><a href="#向量的动态扩容" class="headerlink" title="向量的动态扩容"></a>向量的动态扩容</h3><p>&emsp;&emsp;copyfrom接口在copy向量时申请的容量是copy内容的两倍，因此可根据这种方式来进行扩容，其累计增容时间为$O(n^{2})$,分摊增益时间为$O(n)$</p><p>&emsp;&emsp;扩容代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void Vector&lt;T&gt;::<span class="function"><span class="title">expand</span></span>()&#123;</span><br><span class="line">    <span class="keyword">if</span>(_size&lt;_capacity) <span class="built_in">return</span>;</span><br><span class="line">    _capacity = max(_capacity,DEFAULT_CAPACITY);</span><br><span class="line">    T* oldElem = _elem;</span><br><span class="line">    _elem = new T[_capacity &lt;&lt;=1]; //容量加倍,移位</span><br><span class="line">    <span class="keyword">for</span>(int i = 0; i &lt; _size; i++)</span><br><span class="line">        _elem[i] = oldElem[i];</span><br><span class="line">    delete [] oldElem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="向量插入"><a href="#向量插入" class="headerlink" title="向量插入"></a>向量插入</h3><p>&emsp;&emsp;将向量的后继整体向后移位，空出一个位置后将其插入<br>&emsp;&emsp;算法实现：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Rank Vector&lt;T&gt;::insert(Raank r, T const &amp; e)&#123;</span><br><span class="line">    expand()  //如有必要先考虑扩容</span><br><span class="line">    <span class="keyword">for</span>(int i = _size; i &gt; r; i--)  //从后往前移位，若从前往后移可能出现覆盖的现象</span><br><span class="line">        _elem[i] = _elem[i-1];</span><br><span class="line">    _elem[r] = e;</span><br><span class="line">    _size++;</span><br><span class="line">    <span class="built_in">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="区间删除"><a href="#区间删除" class="headerlink" title="区间删除"></a>区间删除</h3><p>&emsp;&emsp;将后继左移填补删除部分，时间复杂度为$O(n)$。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int Vector&lt;T&gt;::remove(Rank lo,Rank hi)&#123;</span><br><span class="line">    if(lo==hi) return 0;</span><br><span class="line">    while(hi &lt; _size) </span><br><span class="line">        _elem[lo++] = _elem[hi++];</span><br><span class="line">    _size = lo;</span><br><span class="line">    shrink();  //更新规模</span><br><span class="line">    return hi - lo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;单元素删除可看做区间删除的特例$[r]=[r,r+1)$，时间复杂度为$O(n)$。若在进行区间操作时，叠加单元素操作进行区间操作会导致$O(n^{2})$的时间复杂度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">T Vector&lt;T&gt;::remove(Rank r)&#123;</span><br><span class="line">    T e = _elem[r];  //备份被删除的元素</span><br><span class="line">    remove(r, r+1); //调用区间删除算法</span><br><span class="line">    return e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h3><p>&emsp;&emsp;查找操作都是从后向前查找匹配的元素，在最坏的情况下，其时间复杂度为$O(n)$，但在n给定的情况下其时间复杂度为$O(1)$。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Rank Vector&lt;T&gt;::find(T const &amp; e, Rank lo, Rank hi)&#123;</span><br><span class="line">    while((lo &lt; hi--) &amp;&amp; (e != _elem[hi]));</span><br><span class="line">    return hi; //hi&lt;lo时查找失败，否则hi为命中元素的秩</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="去重操作"><a href="#去重操作" class="headerlink" title="去重操作"></a>去重操作</h3><p>&emsp;&emsp;无序向量的唯一化需要用到去重操作。<br>&emsp;&emsp;while循环中find操作查找当前元素的前驱，remove对后继操作，则累计时间复杂度为$O(n^{2})$。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int Vector&lt;T&gt;::deduplicate()&#123;</span><br><span class="line">    int oldSize = _size;</span><br><span class="line">    Rank i = 1;        //初始值从_elem[1]开始</span><br><span class="line">    while(i &lt; _size)&#123;  //从前向后查询是否有与_elem[i]相同的元素，若有就删除</span><br><span class="line">        (find(_elem[i], 0, i)) &lt; 0 ? i++ : remove(i);</span><br><span class="line">    &#125;</span><br><span class="line">    return oldSize - _size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="遍历操作"><a href="#遍历操作" class="headerlink" title="遍历操作"></a>遍历操作</h3><p>&emsp;&emsp;统一对各元素实施visit操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct Increase&#123;</span><br><span class="line">    virtual void operator()(T &amp; e)&#123;e++;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void increase(Vector&lt;T&gt; &amp; V)&#123;</span><br><span class="line">    V.traverse(Increase&lt;T&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="有序向量"><a href="#有序向量" class="headerlink" title="有序向量"></a>有序向量</h2><h3 id="唯一化"><a href="#唯一化" class="headerlink" title="唯一化"></a>唯一化</h3><p>&emsp;&emsp;将无序向量有序化后便于操作，如无序向量的去重操作对应有序向量的唯一化操作，前者的时间复杂度为$O(n^{2})$。</p><ul><li>有序序列，任意一对相邻元素顺序</li><li>无序序列，总有一对相邻元素逆序</li><li>相邻逆序对的数量可用于度量向量逆序的程度</li></ul><p>&emsp;&emsp;检查各相邻元素是顺序或者逆序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int Vector&lt;T&gt;::disordered() condt&#123;</span><br><span class="line">    int n = 0;</span><br><span class="line">    for(int i=1; i &lt; _size; i++)</span><br><span class="line">        n += (_elem[i-1] &gt; _elem[i]);</span><br><span class="line">    return n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;将无序向量的去重操作推广到有序向量更为高效。</p><ul><li>有序向量去重法一<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int Vector&lt;T&gt;::uniquify()&#123;</span><br><span class="line">    int oldSize = _size;</span><br><span class="line">    int i = 0;</span><br><span class="line">    while(i &lt; _size-1)&#123;</span><br><span class="line">        (_elem[i] == _elem[i+1]) ? remove(i+1):i++;</span><br><span class="line">    &#125;</span><br><span class="line">    return oldSize - _size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>&emsp;&emsp;此方法的时间复杂度和deduplicate相同，都为$O(n^{2})$。改进算法，将重复的元素批量删除。</p><ul><li>有序向量去重法二<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int Vector&lt;T&gt;::uniquify()&#123;</span><br><span class="line">    Rank i = 0, j = 0;</span><br><span class="line">    while(++j &lt; _size)&#123;             //逐一扫描，直至末尾元素</span><br><span class="line">        if(_elem[i] != _elem[j])    //找到两个不同元素后将第i+1元素用j元素覆盖</span><br><span class="line">            _elem[++i] = _elem[j];</span><br><span class="line">    &#125;</span><br><span class="line">    _size = ++i;</span><br><span class="line">    shrink();     //如果有必要截除尾部多余元素</span><br><span class="line">    return j-i;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>&emsp;&emsp;此方法的时间复杂度仅为$O(n)$</p><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>&emsp;&emsp;随机选择使用二分查找还是Fibonacci查找。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Rank Vector&lt;T&gt;::search(T const &amp; e, Rank lo,Rank hi) const&#123;</span><br><span class="line">    return (rand() % 2) ? binSearch(_elem, e, lo, hi) : fibSearch(_elem, e, lo,hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;补充：Fibonacci数递归公式为$fib(n)=fib(n-1)+fib(n-2)$，若直接实现公式，此方法的时间复杂度为$O(2^{n})$。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int fib(n)&#123;</span><br><span class="line">    return (2&gt;n) ? n : fib(n-1) + fib(n-2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;优化方法为：进行动态规划，可以将时间复杂度降为$O(n)$。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int fib(n)&#123;</span><br><span class="line">    int f = 0;</span><br><span class="line">    int g = 1;</span><br><span class="line">    while(0 &lt; n--)&#123;</span><br><span class="line">        g = g + f;</span><br><span class="line">        f = g - f;</span><br><span class="line">    &#125; </span><br><span class="line">    return g;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;查找的语义约定：</p><ul><li>若查找元素小于向量最小元素，则返回lo-1即左哨兵</li><li>若查找元素大于向量最大元素，则返回hi-1即右侧哨兵左邻</li></ul><ul><li>A版本算法<br>&emsp;&emsp;减而治之，以任意元素 x = S[mi]为界，将待查找区间分为三部分，将mi取做向量的中点，且不考虑重复元素。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static Rank binSearch(T* A, T const &amp; e, Rank lo, Rank hi)&#123;</span><br><span class="line">    while(lo &lt; hi)&#123;</span><br><span class="line">        Rank mi = (lo + hi) &gt;&gt; 1;   //取出lo和hi的中点，&gt;&gt;表示右移一位</span><br><span class="line">        if(e &lt; A[mi])</span><br><span class="line">            hi = mi;</span><br><span class="line">        else if(A[mi] &lt; e)</span><br><span class="line">            lo = mi + 1;</span><br><span class="line">        else</span><br><span class="line">            return mi;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;      //查找失败，返回-1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>&emsp;&emsp;此方法的时间复杂度为$1.5log(n)$。左右分支的比较次数不等，但递归深度相同，左侧的比较次数较少，右侧的比较次数较多，因此可以调整递归深度，将左侧拉深，右侧变浅，从而减少平均比较次数。因此改进算法，将中点设置为$fib(k-1)-1$。</p><p>&emsp;&emsp;Fib查找：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static Rank fibSearch(T* A, T const &amp; e, Rank lo, Rank hi)&#123;</span><br><span class="line">    Fib fib(hi -lo);  //创建Fib数列</span><br><span class="line">    while(lo &lt; hi)&#123;</span><br><span class="line">        while(hi - lo &lt; fib.get())   //前向顺序查找，确定Fib(k)-1的轴</span><br><span class="line">            fib.prev()</span><br><span class="line">        Rank mi = lo + fib.get() -1;</span><br><span class="line">        if(e &lt; A[mi]) </span><br><span class="line">            hi = mi;</span><br><span class="line">        else if(A[mi] &lt; e)</span><br><span class="line">            lo = mi + 1;</span><br><span class="line">        else</span><br><span class="line">            return mi;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;设平均查找长度为$a(\lambda )\times log(n)$，在λ在[0,1)范围内，使得平均查找长度有最优值，可以列出:<br>&emsp;&emsp;$a\left (\lambda \right ) \times log\left (n \right ) = \lambda \times [1 + a\left (\lambda \right ) \times log\left (n \lambda \right )]+ \left (1 - \lambda \right )\times \left [ 2 + a\left (\lambda \right ) \times log\left (n \left (1 - \lambda \right ) \right ) \right ]$<br>&emsp;&emsp;整理后可得$\lambda = \varphi = 0.6180339…$时，$a\left ( \lambda  \right )= 1.44420…$达到最优值。</p><ul><li><p>B版本算法<br>&emsp;&emsp;分为两个区间，mi的前驱和后继判断次数都为1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt; static Rank binSearch(T* A, T const &amp; e, Rank lo, Rank hi)&#123;</span><br><span class="line">    while(1 &lt; hi -lo)&#123;      //区间宽度为1时退出循环</span><br><span class="line">        Rank mi = (lo + hi) &gt;&gt; 1;</span><br><span class="line">        (e &lt; A[mi]) ? hi = mi : lo = mi;    //区间划分为[lo, mi)、[mi, hi)</span><br><span class="line">    &#125;</span><br><span class="line">    return (e == A[lo] ? lo : -1;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>C版本算法<br>&emsp;&emsp;为了实现语义规定，在B版本基础上改进，为最终版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template &lt;tempename T&gt; static Rank binSearch(T* A, T const &amp; e, Rank lo, Rank hi)&#123;</span><br><span class="line">    while(lo &lt; hi)&#123;         //区间宽度为0时退出循环</span><br><span class="line">        Rank mi = (lo + hi) &gt;&gt; 1;</span><br><span class="line">        (e &lt; A[mi]) ? hi = mi : lo = mi +1;  //区间划分为[lo, mi)、(mi, hi]</span><br><span class="line">    &#125;</span><br><span class="line">    return --lo;  //lo-1为不大于e的元素的最大秩 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>&emsp;&emsp;中点的选取可以动态选取，根据$\frac{mi-lo}{hi-lo}\approx \frac{e - A\left [ lo \right ]}{A\left [ hi \right ] - A\left [ lo \right ]}$进行插值查找 ，最终的平均查找次数为$log\left ( log\left ( n \right ) \right )$。<br>&emsp;&emsp;对比普通查找，插值查找的优势不明显，在查找宽度极大或操作成本极高的情况下优势 较为明显。且该方法易受到干扰，需引入乘法及除法的额外计算。</p><ul><li><p>最终可行方法<br>&emsp;&emsp;通过插值查找缩小查找范围，再进行二分查找。<br>&emsp;&emsp;查找方式选择：</p></li><li><p>大规模：插值查找</p></li><li>中规模：折半查找</li><li>小规模：顺序查找</li></ul><h2 id="无序向量有序化"><a href="#无序向量有序化" class="headerlink" title="无序向量有序化"></a>无序向量有序化</h2><p>&emsp;&emsp;向量元素有序排列时，计算效率会大大提升，如去重、查找等操作。</p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt; void Veector&lt;T&gt;::bubbleSort(Rank lo, Rank hi)&#123;</span><br><span class="line">        while( !bubble(lo, hi--));     //逐趟扫描交换，直至全序</span><br><span class="line">&#125;</span><br><span class="line">template &lt;typename T&gt; bool Vector&lt;T&gt;::bubble(Rank lo, Rank hi)&#123;</span><br><span class="line">        bool sorted = true;         //整体有序标志</span><br><span class="line">        while (++lo &lt; hi)&#123;           //逐一检查相邻元素，若为逆序则交换</span><br><span class="line">               if(_elem[lo-1]&gt;_elem[lo])&#123;</span><br><span class="line">                     sorted = false;</span><br><span class="line">                     swap(_elem[lo-1], _elem[lo]);</span><br><span class="line">               &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sorted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;相应的java代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class DataStructure &#123;</span><br><span class="line">    private static boolean sorted = true;</span><br><span class="line">    private static int[] testlist;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        testlist = new int[]&#123;1, 20, 15, 5, 16, 10, 22&#125;;</span><br><span class="line">        int hi = testlist.length;</span><br><span class="line">        int lo = 0;</span><br><span class="line">        while(!bubble(lo, hi--) &amp;&amp; hi &gt; 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static boolean bubble(int lo, int hi)&#123;</span><br><span class="line">        while(++lo &lt; hi)&#123;</span><br><span class="line">            if (testlist[lo -1] &gt; testlist[lo])&#123;</span><br><span class="line">                sorted = false;</span><br><span class="line">                int change = testlist[lo];</span><br><span class="line">                testlist[lo] = testlist[lo-1];</span><br><span class="line">                testlist[lo-1] = change;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i=0;i&lt;testlist.length;i++)</span><br><span class="line">            System.out.print(testlist[i] + &quot;\t&quot;);</span><br><span class="line">        System.out.println();</span><br><span class="line">        return sorted;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;打印结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1    15    5    16    10    20    22    </span><br><span class="line">1    5    15    10    16    20    22    </span><br><span class="line">1    5    10    15    16    20    22    </span><br><span class="line">1    5    10    15    16    20    22    </span><br><span class="line">1    5    10    15    16    20    22    </span><br><span class="line">1    5    10    15    16    20    22    </span><br><span class="line">1    5    10    15    16    20    22</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;可以看出在第四次扫描的时候，所有的元素都已经就位，但算法仍然在进行扫描，因此可以根据此算法进行改进，将hi移动到已经就位的元素的开头。</p><h3 id="并归排序"><a href="#并归排序" class="headerlink" title="并归排序"></a>并归排序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">void Vector&lt;T&gt;::mergeSort(Raank lo, Rank hi)&#123;</span><br><span class="line">    if(hi - lo &lt; 2)</span><br><span class="line">        return;</span><br><span class="line">    int mi = (lo + hi) &gt;&gt; 1;</span><br><span class="line">    mergeSort(lo, mi);  //前半段排序</span><br><span class="line">    mergeSort(mi, hi);  //后半段排序</span><br><span class="line">    merge(lo, mi, hi);  //归并</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;二路归并：将两个有序的序列合并成一个有序序列，S[lo, hi) = S[lo, mi)+S[mi,hi)。时间消耗为O(n)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt; void Vector&lt;T&gt;::merge(Rank lo, Rank hi)&#123;</span><br><span class="line">    T* A = _elem + lo;  //合并后的向量为A[0, hi -lo) = _elem[lo, hi)</span><br><span class="line">    int lb = mi -lo;    //前子向量B[0, lb) = _elem[lo, mi)，为复制的A前半部分的值</span><br><span class="line">    T* B = new T[lb];</span><br><span class="line">    for(Rank i = 0; i &lt;lb; b[i] = A[i++]);</span><br><span class="line">    int lc = hi - mi;   //后子向量C[0, lc) = _elem[mi, hi)，直接指向mi之后</span><br><span class="line">    T* C = _elem + mi;</span><br><span class="line">    for(Rank i = 0, j = 0, k = 0; (j &lt; lb)||(k &lt;lc);)&#123;</span><br><span class="line">        if((j &lt; lb) &amp;&amp; (lc &lt;= k || (B[j] &lt;= C[k]))) //短路求值，当k值越界</span><br><span class="line">            A[i++] = B[j++];</span><br><span class="line">        if((k &lt; lc) &amp;&amp; (lb &lt;= j || (C[k] &lt; B[j])))</span><br><span class="line">            A[i++] = C[k++];</span><br><span class="line">    &#125;</span><br><span class="line">    delete [] B;    //释放临时空间B   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;判断时可以进行精简：不用考虑C提前耗尽的情况，如果C提前耗尽，将B粘贴到A的末尾。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for(Rank i = 0, j = 0, k =0; j &lt; lb;)&#123;</span><br><span class="line">    if((k &lt; lc) &amp;&amp; (C[k] &lt; B[j]))</span><br><span class="line">        A[i++] = B[j++];</span><br><span class="line">    if(lc &lt;= k || (B[j] &lt;= C[k]))</span><br><span class="line">        A[i++] = C[k++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;java实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">testlist = new int[]&#123;1, 4, 15, 5, 9, 10, 22&#125;;</span><br><span class="line"></span><br><span class="line">    private static void mergeSort(int[] testlist)&#123;</span><br><span class="line">        int mid = testlist.length / 2;</span><br><span class="line">        int[] B = new int[mid];</span><br><span class="line">        for (int i = 0; i &lt; mid ;i++)&#123;</span><br><span class="line">            B[i] = testlist[i];</span><br><span class="line">            System.out.print(B[i] + &quot;\t&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        int[] C = new int[testlist.length - mid];</span><br><span class="line">        for (int i = mid; i &lt; testlist.length; i++) &#123;</span><br><span class="line">            C[i-mid] = testlist[i];</span><br><span class="line">            System.out.print(C[i-mid] + &quot;\t&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        for (int i = 0, j = 0, k = 0; j &lt; mid;)&#123;</span><br><span class="line">            if (k &lt; C.length &amp;&amp; C[k] &lt; B[j])</span><br><span class="line">                testlist[i++] = C[k++];</span><br><span class="line">            if (C.length &lt;= k || B[j] &lt;= C[k])</span><br><span class="line">                testlist[i++] = B[j++];</span><br><span class="line">//            else</span><br><span class="line">//                testlist[i++] = C[k++];</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; testlist.length; i++) &#123;</span><br><span class="line">            System.out.print(testlist[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1    4    15            //B</span><br><span class="line">5    9    10    22    //C </span><br><span class="line">1    4    5    9    10    15    22     //testList</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
