<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>七牛云图床迁移到github</title>
      <link href="/2018/12/06/others/picgo/"/>
      <url>/2018/12/06/others/picgo/</url>
      <content type="html"><![CDATA[<h1 id="七牛云图床迁移到github"><a href="#七牛云图床迁移到github" class="headerlink" title="七牛云图床迁移到github"></a>七牛云图床迁移到github</h1><p>前两天访问博客发现所有传到七牛云的图片都无法访问了。。。原来是临时域名被回收了，然鹅没有正经域名的我很方，备案好像很麻烦，于是，赶紧把七牛云Bucket的所有图片拉到本地。</p><p>操作环境：</p><ul><li>win10</li><li>qshell</li></ul><p>qshell是七牛云进行Bucket管理的工具，现在支持windows系统，在官网按照指引下载对应版本qshell</p><h2 id="下载七牛云图床中的图片"><a href="#下载七牛云图床中的图片" class="headerlink" title="下载七牛云图床中的图片"></a>下载七牛云图床中的图片</h2><h3 id="安装qshell"><a href="#安装qshell" class="headerlink" title="安装qshell"></a>安装qshell</h3><p>电脑运行cmd，将目录切换到qshell解压路径下，如我的解压路径为：<code>E:\UnusualSoftwares\qshell-v2.3.4</code>切换到该目录后，运行qshell，这里需要把对应版本的<code>.exe</code>文件改名为<code>qshell.exe</code>然后再运行qshell，否则是没有安装成功的。</p><p>执行<code>qshell.exe</code>后得到下面信息</p><p>·<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>E:\UnusualSoftwares\qshell-v2.3.4&gt;qshell.exe<br>Qiniu commandline tool for managing your bucket and CDN</p><p>Usage:<br>  qshell [command]</p><p>Available Commands:<br>  account       Get/Set AccessKey and SecretKey<br>  alilistbucket List all the file in the bucket of aliyun oss by prefix<br>  b64decode     Base64 Decode, default nor url safe<br>  b64encode     Base64 Encode, default not url safe<br>  batchchgm     Batch change the mime type of files in bucket<br>  batchchtype   Batch change the file type of files in bucket<br>  batchcopy     Batch copy files from bucket to bucket<br>  batchdelete   Batch delete files in bucket<br>  batchexpire   Batch set the deleteAfterDays of the files in bucket<br>  batchfetch    Batch fetch remoteUrls and save them in qiniu Bucket<br>  batchmove     Batch move files from bucket to bucket<br>  batchrename   Batch rename files in the bucket<br>  batchsign     Batch create the private url from the public url list file<br>  batchstat     Batch stat files in bucket<br>  buckets       Get all buckets of the account<br>  cdnprefetch   Batch prefetch the urls in the url list file<br>  cdnrefresh    Batch refresh the cdn cache by the url list file<br>  chgm          Change the mime type of a file<br>  chtype        Change the file type of a file<br>  completion    generate autocompletion script for bash<br>  copy          Make a copy of a file and save in bucket<br>  d2ts          Create a timestamp in seconds using seconds to now<br>  delete        Delete a remote file in the bucket<br>  dircache      Cache the directory structure of a file path<br>  domains       Get all domains of the bucket<br>  expire        Set the deleteAfterDays of a file<br>  fetch         Fetch a remote resource by url and save in bucket<br>  fput          Form upload a local file<br>  get           Download a single file from bucket<br>  help          Help about any command<br>  ip            Query the ip information<br>  listbucket    List all the files in the bucket<br>  listbucket2   List all the files in the bucket using v2/list interface<br>  m3u8delete    Delete m3u8 playlist and the slices it references<br>  m3u8replace   Replace m3u8 domain in the playlist<br>  mirrorupdate  Fetch and update the file in bucket using mirror storage<br>  move          Move/Rename a file and save in bucket<br>  pfop          issue a request to process file in bucket<br>  prefop        Query the pfop status<br>  privateurl    Create private resource access url<br>  qdownload     Batch download files from the qiniu bucket<br>  qetag         Calculate the hash of local file using the algorithm of qiniu qetag<br>  qupload       Batch upload files to the qiniu bucket<br>  qupload2      Batch upload files to the qiniu bucket<br>  reqid         Decode qiniu reqid<br>  rpcdecode     rpcdecode of qiniu<br>  rpcencode     rpcencode of qiniu<br>  rput          Resumable upload a local file<br>  saveas        Create a resource access url with fop and saveas<br>  stat          Get the basic info of a remote file<br>  sync          Sync big file to qiniu bucket<br>  tms2d         Convert timestamp in milliseconds to a date (TZ: Local)<br>  tns2d         Convert timestamp in Nanoseconds to a date (TZ: Local)<br>  ts2d          Convert timestamp in seconds to a date (TZ: Local)<br>  unzip         Unzip the archive file created by the qiniu mkzip API<br>  urldecode     Url Decode<br>  urlencode     Url Encode<br>  user          Manage users<br>  version       show version</p><p>Flags:<br>  -C, –config string   config file (default is $HOME/.qshell.json)<br>  -d, –debug           debug mode<br>  -h, –help            help for qshell<br>  -L, –local           use current directory as config file path<br>  -v, –version         show version</p><p>Use “qshell [command] –help” for more information about a command.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 下载所有图片</span><br><span class="line"></span><br><span class="line">1. 在七牛云查找到自己的AK和SK，粘贴到命令：</span><br></pre></td></tr></table></figure></p><p>qshell account ak sk<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. 在对象存储中新建一个Bucket，假设名字为NewBucket</span><br><span class="line">3. 将原来Bucket中的所有图像复制到NewBucket</span><br><span class="line"></span><br><span class="line">- 这里首先需要导出原Bucket中的图片list，使用命令：</span><br></pre></td></tr></table></figure></p><p>qshell listbucket originBucket localFileName.txt<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">保存到本地的文件里包括空间中的文件名和文件的各种参数，需要使用编辑器打开（记事本打开会错行），然后把文件名以外的参数全部删掉，只保留文件名，一行一行的排列。</span><br><span class="line"></span><br><span class="line">因为windows的cmd没有cat命令，那就写个python脚本把后面的删掉好了。</span><br><span class="line">```python</span><br><span class="line">def deal_with_file(file_in, file_out):</span><br><span class="line">    with open(file_in, &apos;r&apos;) as fin:</span><br><span class="line">        with open(file_out, &apos;w+&apos;) ad fout:</span><br><span class="line">            for line in fin:</span><br><span class="line">                line = line.split(&apos;\t&apos;)</span><br><span class="line">                fout.write(line[0] + &apos;\n&apos;)</span><br></pre></td></tr></table></figure></p><p>把清理过后的list存成一个新的文件。</p><ul><li>执行命令，将list中的file都复制到newBucket中：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">qshell batchcopy originBucket newBucket cleanedLocalFileName.txt</span><br></pre></td></tr></table></figure><ul><li>在<code>qshell.exe</code>根目录新建<code>qshell.conf</code>文件</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;dest_dir&quot;  :   &quot;./qiniu&quot;,// 文件下载所保存的目录</span><br><span class="line">    &quot;bucket&quot;    :   &quot;newBucket&quot;,// 空间名</span><br><span class="line">    &quot;domain&quot;    :   &quot;http://niuyuanyuanna.clouddn.com/&quot;,// 空间域名</span><br><span class="line">    &quot;access_key&quot;    :&quot;******&quot;, // ak</span><br><span class="line">    &quot;secret_key&quot;    :&quot;******&quot;, // sk</span><br><span class="line">    &quot;prefix&quot;    :   &quot;&quot;,</span><br><span class="line">    &quot;suffix&quot;    :   &quot;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>执行命令，将newBucket中的文件下载到本地：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">qshell qdownload 10 qshell.conf  // `10` 为下载的并发协程数量</span><br></pre></td></tr></table></figure><p>下载好的图像会以日期-文件名的形式存储，我下载好的如图所示：</p><p><center><br>   <img src="https://raw.githubusercontent.com/niuyuanyuanna/BlogImages/master/others/20181206235257.png" width="70%/"><br></center><br>接下来就是重头戏，使用github仓库作为图床啦。</p><h2 id="GitHub图床"><a href="#GitHub图床" class="headerlink" title="GitHub图床"></a>GitHub图床</h2><p>在研友的介绍下，考虑了一波阿里云oos、腾讯云、微博图床还有免费的，综合考虑还是选择github，毕竟很稳呐，在此之前，下载了一个比较好用的图床管理应用，叫PicGo，js实现，贼强。可以直接支持github图床上传，但希望批量上传，并且之前的markdown里面的链接也可以直接替换，因此采用直接将图片上传到github仓库的方法。</p><p>首先需要新建一个仓库来存放图片，如我的仓库名为BlogImage。</p><p>下面就需要把刚刚下载好的图片对应到markdown中，需要进行正则匹配，查找到之前失效的url，然后替换掉，直接看python代码吧。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_image_file</span><span class="params">(md_file)</span>:</span></span><br><span class="line">    <span class="comment"># 这个函数主要是将markdown中对应的url中的img移动到对应的目录下</span></span><br><span class="line">    img_patten = <span class="string">r'!\[.*?\]\((.*?)\)|&lt;img.*?src=[\'\"](.*?)[\'\"].*?&gt;'</span></span><br><span class="line">    <span class="keyword">if</span> os.path.splitext(md_file)[<span class="number">1</span>] != <span class="string">'.md'</span>:</span><br><span class="line">        print(<span class="string">'&#123;&#125;不是Markdown文件，不做处理。'</span>.format(md_file))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    cnt_replace = <span class="number">0</span></span><br><span class="line">    <span class="keyword">with</span> open(md_file, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        post = f.read()</span><br><span class="line">        matches = re.compile(img_patten).findall(post)</span><br><span class="line">        <span class="keyword">if</span> matches <span class="keyword">and</span> len(matches) &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> match <span class="keyword">in</span> list(chain(*matches)):</span><br><span class="line">                <span class="keyword">if</span> match <span class="keyword">and</span> len(match) &gt; <span class="number">0</span>:</span><br><span class="line">                    match_l = match.split(<span class="string">'/'</span>)</span><br><span class="line">                    sub_dir_name = match_l[<span class="number">-2</span>]</span><br><span class="line">                    file_name = match_l[<span class="number">-1</span>]</span><br><span class="line">                    url_base = match_l[<span class="number">-3</span>]</span><br><span class="line">                    <span class="keyword">if</span> url_base == <span class="string">'p6um59a45.bkt.clouddn.com'</span>:</span><br><span class="line">                        full_path = os.path.join(<span class="string">'E:\\UnusualSoftwares\\qshell-v2.3.4\\blog_images'</span>, sub_dir_name, file_name)</span><br><span class="line">                        dir_path = <span class="string">'F:\\blog\\blog_imgs\\computerVersion\\'</span></span><br><span class="line">                        output_name = os.path.join(dir_path, file_name)</span><br><span class="line">                        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(output_name):</span><br><span class="line">                            <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(full_path):</span><br><span class="line">                                print(<span class="string">'path &#123;&#125; not exists'</span>.format(full_path))</span><br><span class="line">                            <span class="keyword">else</span>:</span><br><span class="line">                                shutil.move(full_path, dir_path)</span><br><span class="line">                        cnt_replace = cnt_replace + <span class="number">1</span></span><br><span class="line">                        print(<span class="string">'move &#123;&#125;'</span>.format(full_path))</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        print(<span class="string">'&#123;&#125; is not in qiniuyun'</span>.format(match))</span><br><span class="line">        <span class="keyword">if</span> post <span class="keyword">and</span> cnt_replace &gt; <span class="number">0</span>:</span><br><span class="line">            print(<span class="string">'&#123;&#125; done'</span>.format(os.path.basename(md_file)))</span><br><span class="line">        <span class="keyword">elif</span> cnt_replace == <span class="number">0</span>:</span><br><span class="line">            print(<span class="string">'&#123;&#125;中没有需要替换的URL'</span>.format(os.path.basename(md_file)))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">repalce_url</span><span class="params">(md_file)</span>:</span></span><br><span class="line">    <span class="comment"># 这个函数真正替换markdown中的url</span></span><br><span class="line">    img_patten = <span class="string">r'!\[.*?\]\((.*?)\)|&lt;img.*?src=[\'\"](.*?)[\'\"].*?&gt;'</span></span><br><span class="line">    <span class="keyword">if</span> os.path.splitext(md_file)[<span class="number">1</span>] != <span class="string">'.md'</span>:</span><br><span class="line">        print(<span class="string">'&#123;&#125;不是Markdown文件，不做处理。'</span>.format(md_file))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    cnt_replace = <span class="number">0</span></span><br><span class="line">    dir_ts = time.strftime(<span class="string">'%Y-%m-%d-%H-%M-%S'</span>, time.localtime())</span><br><span class="line">    <span class="keyword">with</span> open(md_file, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        post = f.read()</span><br><span class="line">        matches = re.compile(img_patten).findall(post)</span><br><span class="line">        <span class="keyword">if</span> matches <span class="keyword">and</span> len(matches) &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> match <span class="keyword">in</span> list(chain(*matches)):</span><br><span class="line">                <span class="keyword">if</span> match <span class="keyword">and</span> len(match) &gt; <span class="number">0</span>:</span><br><span class="line"></span><br><span class="line">                    match_last_name = match.split(<span class="string">'/'</span>)[<span class="number">-1</span>]</span><br><span class="line">                    new_url = <span class="string">'https://github.com/niuyuanyuanna/BlogImages/raw/master/computerVersion/'</span></span><br><span class="line">                    new_url = new_url + match_last_name</span><br><span class="line">                    post = post.replace(match, new_url)</span><br><span class="line">                    cnt_replace = cnt_replace + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> post <span class="keyword">and</span> cnt_replace &gt; <span class="number">0</span>:</span><br><span class="line">            open(md_file, <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>).write(post)</span><br><span class="line">            print(<span class="string">'done'</span>)</span><br><span class="line">        <span class="keyword">elif</span> cnt_replace == <span class="number">0</span>:</span><br><span class="line">            print(<span class="string">'&#123;&#125;中没有需要替换的URL'</span>.format(os.path.basename(md_file)))</span><br></pre></td></tr></table></figure><p>因为上传到github仓库中的图片，其外链可以直接用<code>https://github.com/niuyuanyuanna/BlogImages/raw/master/computerVersion/filename</code>表示，即网页端打开仓库中的图片，将链接中的<code>blob</code>更改为<code>raw</code>就可以访问到。</p><p>all done！</p><p>再次吐槽！辣鸡七牛云!</p>]]></content>
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> 图床 </tag>
            
            <tag> 乱七八糟 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Tensorflow图像处理</title>
      <link href="/2018/12/06/tensorflow/5.1Image_processing/"/>
      <url>/2018/12/06/tensorflow/5.1Image_processing/</url>
      <content type="html"><![CDATA[<h1 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a><font color="blue">图像处理</font></h1><h1 id="图像数据处理"><a href="#图像数据处理" class="headerlink" title="图像数据处理"></a>图像数据处理</h1><p>在前面的实验中，使用了卷积神经网络训练图像。但是在很多图像识别的问题中，相同物体在不同的亮度、对比度下的差别非常大，但这些因素都不应该影响最后的识别结果。此次实验将对图像数据进行预处理，使得训练得到的神经网络模型尽可能小地被无关因素所影响。</p><h2 id="TFRecord输入数据格式"><a href="#TFRecord输入数据格式" class="headerlink" title="TFRecord输入数据格式"></a>TFRecord输入数据格式</h2><p>TensorFlow提供了一种统一的格式来存储数据，就是TFRecord。在上一个实验中，使用了一个从类别名称到所有数据列表的词典来维护图像和类别的关系。但是这种方式的可扩展性非常差，当数据来源更加复杂、每个样例中的信息更加丰富之后，这种方式很难有效地记录输入数据中的信息，于是采用TensorFlow提供的TFRecord的格式来统一输入数据的格式。</p><h3 id="TFRecord格式"><a href="#TFRecord格式" class="headerlink" title="TFRecord格式"></a>TFRecord格式</h3><p>TFRecord 文件中的数据都是通过 tf.train.Example 以 Protocol Buffer(以下简称PB) 的格式存储。PB是Google的一种数据交换的格式，他独立于语言，独立于平台，以二进制的形式存在。它能更好的利用内存，方便复制和移动。<br>下面给出tf.train.Example的定义：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">message Example &#123;  </span><br><span class="line">    Features features = <span class="number">1</span>;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line">message Features&#123;  </span><br><span class="line">    map&lt;string,Feature&gt; featrue = <span class="number">1</span>;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line">message Feature&#123;  </span><br><span class="line">    oneof kind&#123;  </span><br><span class="line">        BytesList bytes_list = <span class="number">1</span>;  </span><br><span class="line">        FloatList float_list = <span class="number">2</span>;  </span><br><span class="line">        Int64List int64_list = <span class="number">3</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>从代码中我们可以看出， tf.train.Example 包含了一个字典，key是字符串，value为Feature，Feature可以取值为字符串（BytesList ）、浮点数列表（FloatList ）、整型数列表（Int64List ）。</p><h3 id="TFRecord样例"><a href="#TFRecord样例" class="headerlink" title="TFRecord样例"></a>TFRecord样例</h3><p>下面，使用样例，将MNIST输入数据转化为TFRecord的格式。</p><p>写入TFRecord文件主要分为下面几个步骤：</p><ul><li>获取需要转换的数据</li><li>将数据填入Example PB，并将Example PB转换为一个字符串</li><li>通过<code>tf.python_io.TFRecordWriter</code>将字符串写入TFRecord文件中。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="comment">#将MNIST输入数据转化为TFRecord的格式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow.examples.tutorials.mnist <span class="keyword">import</span> input_data</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment">#把传入的value转化为整数型的属性，int64_list对应着 tf.train.Example 的定义</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_int64_feature</span><span class="params">(value)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> tf.train.Feature(int64_list=tf.train.Int64List(value=[value]))</span><br><span class="line"></span><br><span class="line"><span class="comment">#把传入的value转化为字符串型的属性，bytes_list对应着 tf.train.Example 的定义</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_bytes_feature</span><span class="params">(value)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> tf.train.Feature(bytes_list=tf.train.BytesList(value=[value]))</span><br><span class="line">    </span><br><span class="line"><span class="comment">#读取MNIST数据</span></span><br><span class="line">mnist =input_data.read_data_sets(<span class="string">"/home/sun/AI/CNN/handWrite1/data"</span>,                                     dtype=tf.uint8, one_hot=<span class="keyword">True</span>)</span><br><span class="line"><span class="comment">#训练数据的图像，可以作为一个属性来存储</span></span><br><span class="line">images = mnist.train.images</span><br><span class="line"><span class="comment">#训练数据所对应的标签，可以作为一个属性来存储</span></span><br><span class="line">labels = mnist.train.labels</span><br><span class="line"><span class="comment">#训练数据的图像分辨率，可以作为一个属性来存储</span></span><br><span class="line">pixels = images.shape[<span class="number">0</span>]</span><br><span class="line"><span class="comment">#训练数据的数量</span></span><br><span class="line">num_examples = mnist.train.num_examples</span><br><span class="line"><span class="comment">#指定要写入TFRecord文件的地址</span></span><br><span class="line">filename = <span class="string">"./TFRecord/output.tfrecords"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建一个write来写TFRecord文件</span></span><br><span class="line">writer = tf.python_io.TFRecordWriter(filename)</span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> range(num_examples):</span><br><span class="line">    <span class="comment">#把图像矩阵转化为字符串</span></span><br><span class="line">    image_raw = images[index].tostring()</span><br><span class="line">    <span class="comment">#将一个样例转化为Example Protocol Buffer，并将所有的信息写入这个数据结构</span></span><br><span class="line">    example = tf.train.Example(features=tf.train.Features(feature=&#123;</span><br><span class="line">        <span class="string">'pixels'</span>: _int64_feature(pixels),</span><br><span class="line">        <span class="string">'label'</span>: _int64_feature(np.argmax(labels[index])),</span><br><span class="line">        <span class="string">'image_raw'</span>: _bytes_feature(image_raw)&#125;))</span><br><span class="line">    <span class="comment">#将 Example 写入TFRecord文件</span></span><br><span class="line">    writer.write(example.SerializeToString())</span><br><span class="line">    </span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure><p>以上代码可以将MNIST数据集中的所有训练数据存储到一个TFRecord文件中。当数据量较大时，可以写入到多个TFRecord文件。<br>接下来读取TFRecord文件：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#读取TFRecord文件中的数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建一个reader来读取TFRecord文件中的样例</span></span><br><span class="line">reader = tf.TFRecordReader()</span><br><span class="line"><span class="comment">#通过 tf.train.string_input_producer 创建输入队列</span></span><br><span class="line">filename_queue = tf.train.string_input_producer([<span class="string">"./TFRecord/output.tfrecords"</span>])</span><br><span class="line"><span class="comment">#从文件中读取一个样例</span></span><br><span class="line">_, serialized_example = reader.read(filename_queue)</span><br><span class="line"><span class="comment">#解析读入的一个样例</span></span><br><span class="line">features = tf.parse_single_example(</span><br><span class="line">serialized_example,</span><br><span class="line">features=&#123;</span><br><span class="line"><span class="comment">#这里解析数据的格式需要和上面程序写入数据的格式一致</span></span><br><span class="line"><span class="string">'image_raw'</span>: tf.FixedLenFeature([], tf.string),</span><br><span class="line"><span class="string">'pixels'</span>: tf.FixedLenFeature([], tf.int64),</span><br><span class="line"><span class="string">'label'</span>: tf.FixedLenFeature([], tf.int64),</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">#tf.decode_raw可以将字符串解析成图像对应的像素数组</span></span><br><span class="line">images = tf.decode_raw(features[<span class="string">'image_raw'</span>], tf.uint8)</span><br><span class="line"><span class="comment">#tf.cast可以将传入的数据转化为想要改成的数据类型</span></span><br><span class="line">labels = tf.cast(features[<span class="string">'label'</span>], tf.int32)</span><br><span class="line">pixels = tf.cast(features[<span class="string">'pixels'</span>], tf.int32)</span><br><span class="line"></span><br><span class="line">sess = tf.Session()</span><br><span class="line"><span class="comment">#启动多线程处理输入数据</span></span><br><span class="line">coord = tf.train.Coordinator()</span><br><span class="line">threads = tf.train.start_queue_runners(sess=sess, coord=coord)</span><br><span class="line"></span><br><span class="line"><span class="comment">#每次运行可以读取TFRecord文件中的一个样例。当所有样例都读完之后，在此样例中的程序会从头读取</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">image, label, pixel = sess.run([images, labels, pixels])</span><br><span class="line">print(label)</span><br></pre></td></tr></table></figure></p><h2 id="图像数据处理-1"><a href="#图像数据处理-1" class="headerlink" title="图像数据处理"></a>图像数据处理</h2><p>在之前的实验中，都是直接使用图像的原始像素矩阵输入模型，本次实验会通过对图像的预处理，来尽可能避免模型受到无关因素的影响。大多数情况下，图象的预处理过程可以提高模型的准确率。</p><h3 id="TensorFlow图像处理函数"><a href="#TensorFlow图像处理函数" class="headerlink" title="TensorFlow图像处理函数"></a>TensorFlow图像处理函数</h3><h4 id="图像编码处理"><a href="#图像编码处理" class="headerlink" title="图像编码处理"></a>图像编码处理</h4><p>RGB色彩模式的图像可以看成一个三维矩阵，矩阵中的每一个数表示了图像上的不同位置，不同颜色的亮度。然而图像在存储时并不是直接记录这些矩阵中的数字，而是记录经过压缩编码之后的结果。所以要将一张图像还原成一个三维矩阵，需要解码的过程。Tensorflow提供了对jpeg和png格式图像的编码/解码函数。以下代码示范了如何使用Tensorflow中对jpeg格式图像的编码/解码函数：<br>以下面这张图片为例：</p><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/tensorflow/92736450.jpg" width="50%"><br></center><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">image_raw_data = tf.gfile.FastGFile(<span class="string">"/path/to/picture"</span>, <span class="string">'rb'</span>).read()</span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    img_data = tf.image.decde_jpeg(image_raw_data)</span><br><span class="line">    print(img_data.eval())</span><br><span class="line">    <span class="comment"># 输出解码后的三维矩阵，打印的内容为：</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    [[[252 252 252]</span></span><br><span class="line"><span class="string">  ...</span></span><br><span class="line"><span class="string">  [243 244 238]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> [[252 252 252]</span></span><br><span class="line"><span class="string">  ...</span></span><br><span class="line"><span class="string">  [243 244 238]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> [[252 252 252]</span></span><br><span class="line"><span class="string">  ...</span></span><br><span class="line"><span class="string">  [243 244 238]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> ...</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> [[249 249 249]</span></span><br><span class="line"><span class="string">  ...</span></span><br><span class="line"><span class="string">  [249 250 245]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> [[249 249 249]</span></span><br><span class="line"><span class="string">  ...</span></span><br><span class="line"><span class="string">  [249 250 245]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> [[249 249 249]</span></span><br><span class="line"><span class="string">  ...</span></span><br><span class="line"><span class="string">  [249 250 245]]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    plt.imshow(img_data.eval())</span><br><span class="line">    plt.show()</span><br><span class="line">    img_data = tf.image.convert_image_dtype(img_data, dtype=tf.float32)</span><br></pre></td></tr></table></figure><p>plt.show得到图像：</p><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/tensorflow/80040349.jpg" width="50%"><br></center><p>接下来以这张图像为例，对 图像进行简单变换。</p><h4 id="图像大小调整"><a href="#图像大小调整" class="headerlink" title="图像大小调整"></a>图像大小调整</h4><p>神经网络输入节点的个数是固定的，所以在将图像的像素作为输入提供给神经网络之前，需要先将图像的大小统一。这就是图像大小调整需要完成的任务。 </p><p>图像大小调整有两种方式，第一种是通过算法使得新的图像尽量保存原始图像上的所有信息。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">resized = tf.image.resize_images(img_data, [<span class="number">300</span>, <span class="number">300</span>], method=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>其中<code>img_data</code>是上一步中已经解码后的图像数据。</p><p>Tensorflow提供了四种不同的方法，并且将它们封装到了tf.image.resize_image函数：method参数给出了调整图像大小的算法。</p><ol><li><code>method = Bilinear interpolation</code>双线性插值法</li><li><code>method = Nearest neighbor interpolation</code>最近邻法</li><li><code>method = Bicubic interpolation</code>双三次插值法</li><li><code>method = Area interpolation</code>面积插值法</li></ol><p>经过裁剪填充之后，得到下图：</p><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/tensorflow/34359031.jpg" width="90%"><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/tensorflow/20164669.jpg" width="90%"><br></center><p>从图中可以看出不同的算法产生的结果会有细微的区别。除了将整张图像信息完整保存，tensorflow还提供了API对图像进行裁剪或者填充。</p><h4 id="图像的裁剪和填充"><a href="#图像的裁剪和填充" class="headerlink" title="图像的裁剪和填充"></a>图像的裁剪和填充</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">croped = tf.image.resize_image_with_crop_or_pad(img_data, <span class="number">1000</span>, <span class="number">1000</span>)</span><br><span class="line">padded = tf.image.resize_image_with_crop_or_pad(img_data, <span class="number">3000</span>, <span class="number">3000</span>)</span><br></pre></td></tr></table></figure><p>生成的图像如下所示：</p><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/tensorflow/17956206.jpg" width="90%"><br></center><p>通过tf.image.central_crop函数可以按比例裁剪图像，这个函数的第一个参数为原始图像，第二个为调整比例，这个需要是一个(0,1]的实数。</p><p>上面介绍的图像裁剪函数都是截取或者填充图像中间的部分。Tensorflow也提供了tf.image.crop_to_bounding_box函数和tf.image.pad_to_bounding_box函数来裁剪或者填充给定区域的图像。</p><h4 id="图像翻转"><a href="#图像翻转" class="headerlink" title="图像翻转"></a>图像翻转</h4><p>Tensorflow提供了一些函数来支持对图像的翻转。以下代码实现了将图像上下翻转、左右翻转已经沿对角线翻转的功能：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将图像上下翻转</span></span><br><span class="line">flipped_up_down = tf.image.flip_up_down(img_data)</span><br><span class="line"><span class="comment"># 将图像左右翻转</span></span><br><span class="line">flipped_left_right = tf.image.flip_left_right(img_data)</span><br><span class="line"><span class="comment"># 将图像沿对角线翻转</span></span><br><span class="line">transposed = tf.image.transpose_image(img_data)</span><br></pre></td></tr></table></figure><p>得到的图像如下所示：</p><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/tensorflow/39527516.jpg" width="75%"><br></center><p>在很多图像识别问题中，图像的翻转不会影响识别的结果。于是在训练图像识别的神经网络模型时，可以随机地翻转训练图像，这样训练得到的模型就可以识别不同角度的实体。比如假设在训练数据中所有的猫头都是向右的，那么训练出来的模型就无法很好的识别猫头向左的猫。虽然这个问题可以通过收集更多的训练数据来解决，但是通过随机翻转训练图像的方式可以在零成本的情况下很大程度地缓解该问题。所以随机翻转训练图像是一种很常用的图像预处理方式。Tensorflow提供了方便的API完成随机图像翻转的过程。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以一定概率上下翻转图像</span></span><br><span class="line">flipped = tf.image.random_flip_up_down(img_data)</span><br><span class="line"><span class="comment"># 以一定概率左右翻转图像</span></span><br><span class="line">flipped = tf.image.random_flip_left_right(img_data)</span><br></pre></td></tr></table></figure><h4 id="图像色彩调整"><a href="#图像色彩调整" class="headerlink" title="图像色彩调整"></a>图像色彩调整</h4><p>和图像翻转类似，调整图像的亮度、对比度、饱和度和色相在很多图像识别应用中都不会影响识别结果。所以在训练神经网络模型时，可以随机调整训练图像的这些属性，从而使得训练得到的模型尽可能小地受到无关因素的影响。</p><ul><li>调整图像亮度</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将图像的亮度-0.5</span></span><br><span class="line">adjusted = tf.image.adjust_brightness(img_data, <span class="number">-0.5</span>)</span><br><span class="line"><span class="comment"># 将图像的亮度+0.5</span></span><br><span class="line">adjusted = tf.image.adjust_brightness(img_data, <span class="number">0.5</span>)</span><br><span class="line"><span class="comment">#在[-max_delta, max_delta]的范围随机调整图像的亮度</span></span><br><span class="line">adjusted = tf.image.random_brightness(img_data, max_delta)</span><br></pre></td></tr></table></figure><p>将max_delta设置为1后，调整后所得图像为：</p><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/tensorflow/90104314.jpg" width="75%"><br></center><ul><li>调整图像对比度</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 将图像的对比度-5</span><br><span class="line">adjusted = tf.image.adjust_contrast(img_data, -5)</span><br><span class="line"># 将图像的对比度+5</span><br><span class="line">adjusted = tf.image.adjust_contrast(img_data, 5)</span><br><span class="line"># 在[lower, upper]的范围随机调整图的对比度</span><br><span class="line">adjusted = tf.image.random_contrast(img_data, lower, upper)</span><br></pre></td></tr></table></figure><p>将lower, upper设置为0, 5后（lower不能为负数），调整后所得图像为：</p><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/tensorflow/15455084.jpg" width="75%"><br></center><ul><li>调整图像色相</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将图像的色相加0.1</span></span><br><span class="line">adjusted = tf.image.adjust_hue(img_data, <span class="number">0.1</span>)</span><br><span class="line"><span class="comment"># 将图像的色相加0.6</span></span><br><span class="line">adjusted = tf.image.adjust_hue(img_data, <span class="number">0.6</span>)</span><br><span class="line"><span class="comment"># 在[0, max_delta]的范围随机调整图像的色相</span></span><br><span class="line">adjusted = tf.image.random_hue(img_data, max_delta)</span><br></pre></td></tr></table></figure><p>将max_delta设置为0.5后，得到的结果为：</p><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/tensorflow/41049686.jpg" width="75%"><br></center><ul><li>调整图像饱和度</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将图像的饱和度-5</span></span><br><span class="line">adjusted = tf.image.adjust_saturation(img_data, <span class="number">-5</span>)</span><br><span class="line"><span class="comment"># 将图像的饱和度+5</span></span><br><span class="line">adjusted = tf.image.adjust_saturation(img_data, <span class="number">5</span>)</span><br><span class="line"><span class="comment"># 在[lower, upper]的范围随机调整图的饱和度</span></span><br><span class="line">adjusted = tf.image.random_saturation(image, lower, upper)</span><br></pre></td></tr></table></figure><p>将lower, upper设置为0, 5后（lower不能为负数），调整后所得图像为：</p><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/tensorflow/86143789.jpg" width="75%"><br></center><h4 id="图像标准化"><a href="#图像标准化" class="headerlink" title="图像标准化"></a>图像标准化</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将代表一张图像的三维矩阵中的数字均值变为0，方差变为1</span></span><br><span class="line">adjusted = tf.image.per_image_standardization(image)</span><br></pre></td></tr></table></figure><p>标准化后和原图对比：</p><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/tensorflow/36295859.jpg" width="75%"><br></center><h4 id="处理标注框"><a href="#处理标注框" class="headerlink" title="处理标注框"></a>处理标注框</h4><p>在很多图像识别的数据集中，图像中需要关注的物体通常会被标注框圈出来。下面这段代码展示了如何通过tf.image.draw_bounding_boxes函数在图像中加入标注框。</p>]]></content>
      
      <categories>
          
          <category> Framework </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tensorflow </tag>
            
            <tag> 入门教程 </tag>
            
            <tag> CNN </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Inception-V3迁移学习</title>
      <link href="/2018/12/06/tensorflow/4.1%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E8%AF%86%E5%88%AB%E8%8A%B1/"/>
      <url>/2018/12/06/tensorflow/4.1%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E8%AF%86%E5%88%AB%E8%8A%B1/</url>
      <content type="html"><![CDATA[<h1 id="迁移学习"><a href="#迁移学习" class="headerlink" title="迁移学习"></a><font color="blue">迁移学习</font></h1><h2 id="Inceptipn-v3模型"><a href="#Inceptipn-v3模型" class="headerlink" title="Inceptipn-v3模型"></a>Inceptipn-v3模型</h2><p>Inception-v3模型中的Inception结构是将不同的卷积层通过并联的方式结合在一起。其卷积层使用了不同尺寸的过滤器，然后将得到的矩阵拼接起来。图一是一个Inception模块的一个单元结构图：</p><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/tensorflow/89932450.jpg" width="50%"><br></center><p>它会使用不同尺寸的过滤器处理输入矩阵，由图中可以看到，最上面的矩阵是使用了边长为1的过滤器的卷积层前向传播结果。类似的，中间矩阵使用的过滤器边长为3，下方矩阵使用的过滤器边长为5。不同的矩阵代表了Inception模块中的一条计算路径，虽然过滤器大小不同，但若所有的过滤器都是用全0填充且步长为1，那么前向传播得到的结果长和宽都与输入矩阵一致。这样经过不同过滤器处理的结果可以拼接成一个更深的矩阵，如上图所示，可以将它们在深度这个维度上组合起来。上图所示的Inception模块得到的结果矩阵的长和宽输入一样，深度为三个矩阵深度的和。</p><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/tensorflow/30363493.jpg" width="75%"><br></center><p>如上图所示，Inception-v3模型总共有46层，由11个Inception模块组成，共有96个卷积层，因此代码量较大，给出实现模型结构中红框处的实现代码。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#slim.arg_scope 函数可以用于设置默认的参数值。slim.arg_scope 函数的第一个参数是一个列表</span></span><br><span class="line"><span class="comment">#这个列表中的参数将会使用默认的参数取值,在调用 slim.conv2d(net,320,[1,1]) 时会自动加上 stride = 1 ,padding = 'SAME'</span></span><br><span class="line"><span class="keyword">with</span> slim.arg_scope([slim.conv2d,slim.max_pool2d,slim.avg_pool2d],</span><br><span class="line">                        stride = <span class="number">1</span>,padding = <span class="string">'SAME'</span>):</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">#此处省略了 Inception-v3 中前面的网络结构而直接实现最后的 Inception 模块</span></span><br><span class="line">    net = 上一层的输出节点矩阵</span><br><span class="line">    <span class="comment">#为这个 Inception 模块声明一个统一的变量命名空间</span></span><br><span class="line">    <span class="keyword">with</span> tf.variable_scope(<span class="string">'last_inception'</span>):</span><br><span class="line">        <span class="comment">#给 Inception 模块中每一条并联的路径声明一个命名空间</span></span><br><span class="line">        <span class="keyword">with</span> tf.variable_scope(<span class="string">'Branch_0'</span>):</span><br><span class="line">            <span class="comment"># 实现一个过滤器边长为 1，深度为 320 的卷积层</span></span><br><span class="line">            branch_0 = slim.conv2d(net,<span class="number">320</span>,[<span class="number">1</span>,<span class="number">1</span>],scope = <span class="string">'Conv2d_0a_lxl'</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#实现第二条路径，本身也是一个 Inception 结构,最终深度为 384*2</span></span><br><span class="line">        <span class="keyword">with</span> tf.variable_scope(<span class="string">'Branch_1'</span>):</span><br><span class="line">            branch_1 = slim.conv2d(net,<span class="number">384</span>,[<span class="number">1</span>,<span class="number">1</span>],scope = <span class="string">'Conv2d_0a_1x1'</span>)</span><br><span class="line">            <span class="comment">#tf.concat 函数可以将多个矩阵拼接起来，第一个参数指定了拼接的维度，</span></span><br><span class="line">            <span class="comment">#这里给出的 3 代表了矩阵是在深度这个维度上进行拼接</span></span><br><span class="line">            branch_1 = tf.concat(<span class="number">3</span>,[</span><br><span class="line">                        <span class="comment">#如图所示，此处 2 层卷积层的输入都是 branch_1 而不是 net</span></span><br><span class="line">                        slim.conv2d(branch_1,<span class="number">384</span>,[<span class="number">1</span>,<span class="number">3</span>],scope = <span class="string">'Conv2d_0b_1x3'</span>),</span><br><span class="line">                        slim.conv2d(branch_1,<span class="number">384</span>,[<span class="number">3</span>,<span class="number">1</span>],scope = <span class="string">'Conv2d_0b_3x1'</span>)])</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#实现第三条路径，此处也是一个小的 Inception 模型</span></span><br><span class="line">        <span class="keyword">with</span> tf.variable_scope(<span class="string">'Branch_2'</span>):</span><br><span class="line">            branch_2 = slim.conv2d(net,<span class="number">448</span>,[<span class="number">1</span>,<span class="number">1</span>],scope = <span class="string">'Conv2d_0b_3x3'</span>)</span><br><span class="line">            branch_2 = slim.conv2d(branch_2,<span class="number">384</span>,[<span class="number">3</span>,<span class="number">3</span>],scope = <span class="string">'Conv2d_0b_3x3'</span>)</span><br><span class="line">            branch_2 = tf.concat(<span class="number">3</span>,[</span><br><span class="line">                         slim.conv2d(branch_2,<span class="number">384</span>,[<span class="number">1</span>,<span class="number">3</span>],scope = <span class="string">'Conv2d_0c_1x3'</span>),</span><br><span class="line">                         slim.conv2d(branch_2,<span class="number">384</span>,[<span class="number">3</span>,<span class="number">1</span>],scope = <span class="string">'Conv2d_0c_3x1'</span>)])</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#实现第四条路径，池化卷积层,输出层深度为 192</span></span><br><span class="line">        <span class="keyword">with</span> tf.variable_scope(<span class="string">'Branch_3'</span>):</span><br><span class="line">            branch_3 = slim.avg_pool2d(net,[<span class="number">3</span>,<span class="number">3</span>],scope = <span class="string">'AvgPool_0a_3x3'</span>)</span><br><span class="line">            branch_3 = slim.conv2d(branch_3,<span class="number">192</span>,[<span class="number">1</span>,<span class="number">1</span>],scope = <span class="string">'Conv2d_0b_1x1'</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#当前 Inception 模块的最后输出为以上 4 条路径在第三维（深度）上的合并</span></span><br><span class="line">        net = tf.concat(<span class="number">3</span>,[branch_0,branch_1,branch_2,branch_3])</span><br></pre></td></tr></table></figure><h2 id="模型的迁移学习"><a href="#模型的迁移学习" class="headerlink" title="模型的迁移学习"></a>模型的迁移学习</h2><p>所谓迁移学习，就是将一个问题上训练好的模型通过简单的调整使其适用于一个新的问题。根据论文DeCAF中的结论，可以保留训练好的Inception-3模型中所有卷积层的参数，只是替换最后一层全连接层，在最后这一层全连接层之前的网络层称之为瓶颈层。</p><p>将新的图像通过训练好的卷积神经网络直到瓶颈层的过程可以看成是对图像进行特征提取的过程。在训练好的Inception-3模型中，因为将瓶颈层的输出再通过一个单层的全连接层神经网络可以很好的区分1000种类别的图像，所以瓶颈层输出的节点向量可以直接利用这个训练好的神经网络对图像进行特征提取，然后再将提取到的特征向量作为输入来训练一个新的单层全连接神经网络处理的分类问题。</p><p>但是，在数据量足够的情况下，迁移学习的效果远远不如完全重新训练。但迁移学习所需要的时间较短。</p><h2 id="使用TensorFlow进行迁移学习"><a href="#使用TensorFlow进行迁移学习" class="headerlink" title="使用TensorFlow进行迁移学习"></a>使用TensorFlow进行迁移学习</h2><h3 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h3><p>当前实验所需要的数据集为花的图片，存放于“flower_photo”文件夹下，其中共有5个文件夹，每个文件夹对应一种花的图片，每个种类的图片数量均大于500。</p><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/tensorflow/4843558.jpg" width="75%"><br></center><p>每种花的图片数据如下图所示：</p><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/tensorflow/4738162.jpg" width="75%"><br></center><h3 id="数据分类"><a href="#数据分类" class="headerlink" title="数据分类"></a>数据分类</h3><p>初步处理完数据后，将数据分为训练集和测试集，并且将分类结果存储在result字典中。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def creat_image_list(testing_persentage, validation_persentage):</span><br><span class="line">    # result为字典，存储所有图片，key：label_name，value：字典，存储图片名称、数据集属性等</span><br><span class="line">    result = &#123;&#125;</span><br><span class="line">    # 获取当前目录的所有子目录</span><br><span class="line">    sub_dirs = [x[0] for x in os.walk(INPUT_DATA)]</span><br><span class="line">    is_root_dir = True</span><br><span class="line">    for sub_dir in sub_dirs:</span><br><span class="line">        # 得到的第一个为当前目录，跳过</span><br><span class="line">        if is_root_dir:</span><br><span class="line">            is_root_dir = False</span><br><span class="line">            continue</span><br><span class="line"></span><br><span class="line">        # 获取当前目录下所有有效图片文件</span><br><span class="line">        extensions = [&apos;jpg&apos;, &apos;jpeg&apos;, &apos;JPG&apos;, &apos;JPEG&apos;]</span><br><span class="line">        file_list = []</span><br><span class="line">        dir_name = os.path.basename(sub_dir)  # 文件名，如“daisy”</span><br><span class="line">        for extension in extensions:</span><br><span class="line">            file_glob = os.path.join(INPUT_DATA, dir_name, &quot;*.&quot; + extension)</span><br><span class="line">            file_list.extend(glob.glob(file_glob))</span><br><span class="line">        if not file_list:</span><br><span class="line">            continue</span><br><span class="line"></span><br><span class="line">        # 目录名为类的名称，如daisy</span><br><span class="line">        label_name = dir_name.lower()</span><br><span class="line"></span><br><span class="line">        # 初始化当前类的训练集、测试集、验证集</span><br><span class="line">        training_images = []</span><br><span class="line">        testing_images = []</span><br><span class="line">        validation_images = []</span><br><span class="line">        for file_name in file_list:</span><br><span class="line">            base_name = os.path.basename(file_name)  # base_name为图片的名字,如：‘5673551_01d1ea993e_n.jpg’</span><br><span class="line">            chance = np.random.randint(100)  # 随机将图片分配给三个数据集</span><br><span class="line">            if chance &lt; validation_persentage:</span><br><span class="line">                validation_images.append(base_name)</span><br><span class="line">            elif chance &lt; (testing_persentage + validation_persentage):</span><br><span class="line">                testing_images.append(base_name)</span><br><span class="line">            else:</span><br><span class="line">                training_images.append(base_name)</span><br><span class="line"></span><br><span class="line">        # 将当前类别数据放入结果字典</span><br><span class="line">        result[label_name] = &#123;</span><br><span class="line">            &apos;dir&apos;: dir_name,</span><br><span class="line">            &apos;training&apos;: training_images,</span><br><span class="line">            &apos;testing&apos;: testing_images,</span><br><span class="line">            &apos;validation&apos;: validation_images</span><br><span class="line">        &#125;</span><br><span class="line">    return result</span><br></pre></td></tr></table></figure></p><p>首先从数据文件夹中读取所有的图片列表，按照训练和测试数据分开，其中<code>testing_percentage</code>和 <code>validation_percentage</code>指定了测试数据和验证数据集的大小。</p><h3 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h3><p>在将数据喂给神经网络之前，先定义一些辅助函数，有利于帮助简化程序</p><h4 id="获取图片地址"><a href="#获取图片地址" class="headerlink" title="获取图片地址"></a>获取图片地址</h4><p>此函数可以通过类别名称、所属数据集和图片编号获取图片的地址。类别名称就是图片所属的文件夹名称，所属数据类别是其为训练集还是测试集，图片编号即为图片名字。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def get_image_path(image_lists, image_dir, label_name, index, category):</span><br><span class="line">    label_lists = image_lists[label_name]  # 获取label_name这个类别的所有图片信息</span><br><span class="line">    category_list = label_lists[category]  # 获取指定类中三个数据集中指定的数据集，如：training中的图片信息</span><br><span class="line">    mod_index = index % len(category_list)</span><br><span class="line">    base_name = category_list[mod_index]  # 获取指定编号的图片的文件名</span><br><span class="line">    sub_dir = label_lists[&apos;dir&apos;]</span><br><span class="line">    full_path = os.path.join(image_dir, sub_dir, base_name)  # 最终的path为image_dir/sub_dir/base_name</span><br><span class="line">    return full_path</span><br></pre></td></tr></table></figure></p><ul><li>image_lists：所有图片信息</li><li>image_dir：根目录</li><li>label_name：类别名称</li><li>index：图片编号</li><li>category：图片所在集合为训练集、测试集还是验证集</li></ul><h4 id="获取特征向量地址"><a href="#获取特征向量地址" class="headerlink" title="获取特征向量地址"></a>获取特征向量地址</h4><p>通过所有图片信息、所属类别（如daisy）、图片编号、所属数据集（如training）获取通过模型之后的特征向量地址。参数比get_image_path方法少了image_dir，替换成CACHE_DIR为保存模型变量的临时文件存储文件夹。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_bottleneck_path</span><span class="params">(image_lists, label_name, index, category)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> get_image_path(image_lists, CACHE_DIR, label_name, index, category) + <span class="string">'.txt'</span></span><br></pre></td></tr></table></figure></p><h4 id="加载Inception-V3模型"><a href="#加载Inception-V3模型" class="headerlink" title="加载Inception-V3模型"></a>加载Inception-V3模型</h4><p>读取训练好的.pb格式的模型，并且返回数据输入所对应的张量及计算瓶颈层结果所对应的张量。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_model</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 读取训练好的模型</span></span><br><span class="line">    <span class="keyword">with</span> gfile.FastGFile(os.path.join(MODEL_DIR, MODEL_FILE), <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        graph_def = tf.GraphDef()</span><br><span class="line">        graph_def.ParseFromString(f.read())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 加载读取的模型，返回数据输入所对应的张量以及计算瓶颈层结果所对应的张量</span></span><br><span class="line">    bottleneck_tensor, jpeg_data_tensor = tf.import_graph_def(</span><br><span class="line">        graph_def, return_elements=[BOTTLENECK_TENSOR_NAME, JPEG_DATA_TENSOR_NAME])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> bottleneck_tensor, jpeg_data_tensor</span><br></pre></td></tr></table></figure></p><h4 id="判断当前文件夹是否存在"><a href="#判断当前文件夹是否存在" class="headerlink" title="判断当前文件夹是否存在"></a>判断当前文件夹是否存在</h4><p>确保输入路径存在，若不存在则创建<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ensure_dir_exists</span><span class="params">(dir_name)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(dir_name):</span><br><span class="line">        os.makedirs(dir_name)</span><br></pre></td></tr></table></figure></p><h3 id="训练过程"><a href="#训练过程" class="headerlink" title="训练过程"></a>训练过程</h3><h4 id="计算当前图片的瓶颈张量值"><a href="#计算当前图片的瓶颈张量值" class="headerlink" title="计算当前图片的瓶颈张量值"></a>计算当前图片的瓶颈张量值</h4><p>将当前图片作为输入计算bottleneck_tensor的值，返回值为特征向量。从此处开始需要用到session，因为这时已经开始进行前向传播的过程。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_bottleneck_on_image</span><span class="params">(sess, image_data, image_data_tensor, bottleneck_tensor)</span>:</span></span><br><span class="line">    bottleneck_values = sess.run(bottleneck_tensor, &#123;image_data_tensor: image_data&#125;)</span><br><span class="line">    bottenneck_values = np.squeeze(bottleneck_values)  <span class="comment"># 将四位数组压缩为一个特征向量</span></span><br><span class="line">    <span class="keyword">return</span> bottenneck_values</span><br></pre></td></tr></table></figure></p><h4 id="获取图片的特征向量"><a href="#获取图片的特征向量" class="headerlink" title="获取图片的特征向量"></a>获取图片的特征向量</h4><p>首先视图寻找已经计算且保存下来的特征向量，如果找不到该特征向量，再计算特征向量并保存到文件。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_or_create_bottleneck</span><span class="params">(sess, image_lists, label_name, index, category,</span></span></span><br><span class="line"><span class="function"><span class="params">                             jpeg_data_tensor, bottleneck_tensor)</span>:</span></span><br><span class="line">    label_lists = image_lists[label_name]  <span class="comment"># 获取label_name这个类别的所有图片信息</span></span><br><span class="line">    sub_dir = label_lists[<span class="string">'dir'</span>]  <span class="comment"># 获取daisy类别的training图片信息</span></span><br><span class="line">    sub_dir_path = os.path.join(CACHE_DIR, sub_dir)  <span class="comment"># 创建CHACHE_DIR/sub_dir文件夹</span></span><br><span class="line">    ensure_dir_exists(sub_dir_path)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取一张图片对应的特征向量文件路径</span></span><br><span class="line">    bottleneck_path = get_bottleneck_path(image_lists, label_name, index, category)</span><br><span class="line">    <span class="comment"># 如果没有保存过特征向量文件就计算特征向量并且保存，否则读取文件中的特征向量string值</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(bottleneck_path):</span><br><span class="line">        image_path = get_image_path(image_lists, INPUT_DATA, label_name, index, category)</span><br><span class="line">        image_data = gfile.FastGFile(image_path, <span class="string">'rb'</span>).read()  <span class="comment"># 图片内容</span></span><br><span class="line">        bottelneck_values = run_bottleneck_on_image(</span><br><span class="line">            sess, image_data, jpeg_data_tensor, bottleneck_tensor)  <span class="comment"># 得到特征向量</span></span><br><span class="line">        bottleneck_string = <span class="string">','</span>.join(str(x) <span class="keyword">for</span> x <span class="keyword">in</span> bottelneck_values)  <span class="comment"># 将特征向量转化为string存储到.txt文件中</span></span><br><span class="line">        <span class="keyword">with</span> open(bottleneck_path, <span class="string">'w'</span>) <span class="keyword">as</span> bottleneck_file:</span><br><span class="line">            bottleneck_file.write(bottleneck_string)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">with</span> open(bottleneck_path, <span class="string">'r'</span>) <span class="keyword">as</span> bottleneck_file:</span><br><span class="line">            bottleneck_string = bottleneck_file.read()</span><br><span class="line">        bottelneck_values = [float(x) <span class="keyword">for</span> x <span class="keyword">in</span> bottleneck_string.split(<span class="string">','</span>)]</span><br><span class="line">    <span class="keyword">return</span> bottelneck_values</span><br></pre></td></tr></table></figure></p><h4 id="小批量获取特征向量"><a href="#小批量获取特征向量" class="headerlink" title="小批量获取特征向量"></a>小批量获取特征向量</h4><p>随机获取一个batch的图片作为训练数据<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_random_cached_bottlenecks</span><span class="params">(sess, image_lists, how_many, category,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  jpeg_data_tensor, bottleneck_tensor)</span>:</span></span><br><span class="line">    n_classes = len(image_lists.keys())</span><br><span class="line">    bottenecks = []</span><br><span class="line">    ground_truths = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(how_many):</span><br><span class="line">        <span class="comment"># 随机选择一个类别和图片编号加入当前的训练数据</span></span><br><span class="line">        label_index = random.randrange(n_classes)</span><br><span class="line">        label_name = list(image_lists.keys())[label_index]</span><br><span class="line">        image_index = random.randrange(MAX_NUM_IMAGES_PER_CLASS + <span class="number">1</span>)</span><br><span class="line">        botteneck = get_or_create_bottleneck(</span><br><span class="line">            sess, image_lists, label_name, image_index, category,</span><br><span class="line">            jpeg_data_tensor, bottleneck_tensor)</span><br><span class="line">        ground_truth = np.zeros(n_classes, dtype=np.float32)</span><br><span class="line">        ground_truth[label_index] = <span class="number">1.0</span></span><br><span class="line">        bottenecks.append(botteneck)</span><br><span class="line">        ground_truths.append(ground_truth)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bottenecks, ground_truths</span><br></pre></td></tr></table></figure></p><h4 id="定义全连接层"><a href="#定义全连接层" class="headerlink" title="定义全连接层"></a>定义全连接层</h4><p>训练过程，增加最后一个全连接层进行训练。同时定义其损失函数为交叉熵函数。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_final_training_ops</span><span class="params">(class_count, final_tensor_name, bottleneck_tensor)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> tf.name_scope(<span class="string">'input'</span>):</span><br><span class="line">        bottleneck_input = tf.placeholder_with_default(</span><br><span class="line">            bottleneck_tensor, shape=[<span class="keyword">None</span>, BOTTLENECK_TENSOR_SIZE],</span><br><span class="line">            name=<span class="string">'BottleneckInputPlaceholder'</span>)</span><br><span class="line"></span><br><span class="line">        ground_truth_input = tf.placeholder(tf.float32,</span><br><span class="line">                                            [<span class="keyword">None</span>, class_count],</span><br><span class="line">                                            name=<span class="string">'GroundTruthInput'</span>)</span><br><span class="line"></span><br><span class="line">    layer_name = <span class="string">'final_training_ops'</span></span><br><span class="line">    <span class="keyword">with</span> tf.name_scope(layer_name):</span><br><span class="line">        <span class="keyword">with</span> tf.name_scope(<span class="string">'weights'</span>):</span><br><span class="line">            layer_weights = tf.Variable(tf.truncated_normal([BOTTLENECK_TENSOR_SIZE, class_count], stddev=<span class="number">0.001</span>),</span><br><span class="line">                                        name=<span class="string">'final_weights'</span>)</span><br><span class="line">        <span class="keyword">with</span> tf.name_scope(<span class="string">'biases'</span>):</span><br><span class="line">            layer_biases = tf.Variable(tf.zeros([class_count]),</span><br><span class="line">                                       name=<span class="string">'final_biases'</span>)</span><br><span class="line">        <span class="keyword">with</span> tf.name_scope(<span class="string">'Wx_plus_b'</span>):</span><br><span class="line">            logits = tf.matmul(bottleneck_input, layer_weights) + layer_biases</span><br><span class="line"></span><br><span class="line">    final_tensor = tf.nn.softmax(logits, name=final_tensor_name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> tf.name_scope(<span class="string">'cross_entropy'</span>):</span><br><span class="line">        cross_entropy = tf.nn.softmax_cross_entropy_with_logits(</span><br><span class="line">            logits=logits, labels=ground_truth_input)</span><br><span class="line">        <span class="keyword">with</span> tf.name_scope(<span class="string">'total'</span>):</span><br><span class="line">            cross_entropy_mean = tf.reduce_mean(cross_entropy)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> tf.name_scope(<span class="string">'train'</span>):</span><br><span class="line">        train_step = tf.train.GradientDescentOptimizer(LEARNING_RATE).minimize(</span><br><span class="line">            cross_entropy_mean)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> train_step, cross_entropy_mean, bottleneck_input, \</span><br><span class="line">           ground_truth_input, final_tensor</span><br></pre></td></tr></table></figure></p><h4 id="计算正确率"><a href="#计算正确率" class="headerlink" title="计算正确率"></a>计算正确率</h4><p>evaluaion_step可以用于计算训练集和测试集的正确率。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_evaluation_step</span><span class="params">(result_tensor, ground_truth_tensor)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> tf.name_scope(<span class="string">'accuracy'</span>):</span><br><span class="line">        <span class="keyword">with</span> tf.name_scope(<span class="string">'correct_prediction'</span>):</span><br><span class="line">            correct_prediction = tf.equal(tf.argmax(result_tensor, <span class="number">1</span>),</span><br><span class="line">                                          tf.argmax(ground_truth_tensor, <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">with</span> tf.name_scope(<span class="string">'accuracy'</span>):</span><br><span class="line">            evaluation_step = tf.reduce_mean(tf.cast(correct_prediction,</span><br><span class="line">                                                     tf.float32))</span><br><span class="line">    <span class="keyword">return</span> evaluation_step</span><br></pre></td></tr></table></figure></p><h3 id="测试过程"><a href="#测试过程" class="headerlink" title="测试过程"></a>测试过程</h3><p>在最终测试的时候需要在所有的测试数据上计算正确率，此需要获取测试数据特征值。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_test_bottenecks</span><span class="params">(sess, image_lists, n_classes, jpeg_data_tensor, botteneck_tensor)</span>:</span></span><br><span class="line">    bottenecks = []</span><br><span class="line">    ground_truths = []</span><br><span class="line">    label_name_list = list(image_lists.keys())</span><br><span class="line">    <span class="comment"># 枚举所有类别以及每个类别中的测试图片</span></span><br><span class="line">    <span class="keyword">for</span> label_index, label_name <span class="keyword">in</span> enumerate(label_name_list):</span><br><span class="line">        category = <span class="string">'testing'</span></span><br><span class="line">        <span class="keyword">for</span> index, unused_base_name <span class="keyword">in</span> enumerate(image_lists[label_name][category]):</span><br><span class="line">            botteneck = get_or_create_bottleneck(</span><br><span class="line">                sess, image_lists, label_name, index, category, jpeg_data_tensor, botteneck_tensor)</span><br><span class="line">            ground_truth = np.zeros(n_classes, dtype=np.float32)</span><br><span class="line">            ground_truth[label_index] = <span class="number">1.0</span></span><br><span class="line">            bottenecks.append(botteneck)</span><br><span class="line">            ground_truths.append(ground_truth)</span><br><span class="line">    <span class="keyword">return</span> bottenecks, ground_truths</span><br></pre></td></tr></table></figure></p><h3 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h3><p>创建函数框架，创建main函数，在主函数中的操作为：</p><ol><li>加载训练数据</li><li>读取V3模型，获取瓶颈层参数</li><li>定义最后一层全连接层及损失函数</li><li>训练模型</li><li>测试模型</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义参数，其中文件路径可以自行更改，学习率和迭代次数以及最小批量数目可以自行调试</span></span><br><span class="line">MODEL_INPUT_WIDTH = <span class="number">299</span></span><br><span class="line">MODEL_INPUT_HEIGHT = <span class="number">299</span></span><br><span class="line">MODEL_INPUT_DEPTH = <span class="number">3</span></span><br><span class="line">BOTTLENECK_TENSOR_SIZE = <span class="number">2048</span></span><br><span class="line">BOTTLENECK_TENSOR_NAME = <span class="string">"pool_3/_reshape:0"</span></span><br><span class="line">JPEG_DATA_TENSOR_NAME = <span class="string">"DecodeJpeg/contents:0"</span></span><br><span class="line"><span class="comment"># RESIZED_INPUT_TENSOR_NAME = 'ResizeBilinear:0'</span></span><br><span class="line"></span><br><span class="line">MODEL_DIR = <span class="string">"./model/inception_dec_2015"</span></span><br><span class="line">MODEL_FILE = <span class="string">"tensorflow_inception_graph.pb"</span></span><br><span class="line">CACHE_DIR = <span class="string">"./cache"</span></span><br><span class="line">INPUT_DATA = <span class="string">"./flower_photos"</span></span><br><span class="line">SAVED_MODEL_DIR = <span class="string">"./model/output_model/flower_recognition.pb"</span></span><br><span class="line">OUTPUT_LABEL = <span class="string">"./model/output_model/output_labels.txt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证集和测试集的百分比</span></span><br><span class="line">VALIDATION_PERCENTAGE = <span class="number">10</span></span><br><span class="line">TEST_PERCENTAGE = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">LEARNING_RATE = <span class="number">0.01</span></span><br><span class="line">STEPS = <span class="number">4000</span></span><br><span class="line">BATCH = <span class="number">128</span></span><br><span class="line">MAX_NUM_IMAGES_PER_CLASS = <span class="number">2</span> ** <span class="number">27</span> - <span class="number">1</span>  <span class="comment"># ~134M</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(_)</span>:</span></span><br><span class="line">    <span class="comment"># 加载训练数据</span></span><br><span class="line">    image_lists = creat_image_list(TEST_PERCENTAGE, VALIDATION_PERCENTAGE)  <span class="comment"># 读取所有图片</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 读取训练好的模型,返回数据输入所对应的张量以及计算瓶颈层结果所对应的张量</span></span><br><span class="line">    graph, bottleneck_tensor, jpeg_data_tensor = (</span><br><span class="line">        create_inception_graph())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">        <span class="comment"># 设置session的参数为允许增长型，与GPU资源使用相关</span></span><br><span class="line">        config = tf.ConfigProto(allow_soft_placement=<span class="keyword">True</span>, log_device_placement=<span class="keyword">True</span>)</span><br><span class="line">        config.gpu_options.allow_growth = <span class="keyword">True</span></span><br><span class="line">        sess._config = config</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 训练步骤</span></span><br><span class="line">        (train_step, cross_entropy, bottleneck_input, ground_truth_input,</span><br><span class="line">         final_tensor) = add_final_training_ops(len(image_lists.keys()),</span><br><span class="line">                                                <span class="string">"final_result"</span>, bottleneck_tensor)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 评估步骤</span></span><br><span class="line">        evaluation_step = add_evaluation_step(final_tensor, ground_truth_input)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化</span></span><br><span class="line">        tf.global_variables_initializer().run()</span><br><span class="line">        <span class="comment"># 训练过程</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(STEPS):</span><br><span class="line">            train_bottlenecks, train_ground_truth = get_random_cached_bottlenecks(</span><br><span class="line">                    sess, image_lists, BATCH, <span class="string">'training'</span>, jpeg_data_tensor, bottleneck_tensor)</span><br><span class="line"></span><br><span class="line">            sess.run(train_step, feed_dict=&#123;bottleneck_input: train_bottlenecks,</span><br><span class="line">                                            ground_truth_input: train_ground_truth&#125;)</span><br><span class="line">            is_last_step = (i + <span class="number">1</span> == STEPS)</span><br><span class="line">            <span class="keyword">if</span> is_last_step <span class="keyword">or</span> (i % <span class="number">100</span>) == <span class="number">0</span>:</span><br><span class="line">                train_accuracy, cross_entropy_value = sess.run(</span><br><span class="line">                    [evaluation_step, cross_entropy],</span><br><span class="line">                    feed_dict=&#123;bottleneck_input: train_bottlenecks,</span><br><span class="line">                               ground_truth_input: train_ground_truth&#125;)</span><br><span class="line">                print(<span class="string">'Step %d: Train accuracy = %.1f%%'</span> % (i, train_accuracy * <span class="number">100</span>))</span><br><span class="line">                <span class="comment"># print('Step %d: Cross entropy = %f' % (i, cross_entropy_value))</span></span><br><span class="line">                validation_bottlenecks, validation_ground_truth = (</span><br><span class="line">                    get_random_cached_bottlenecks(</span><br><span class="line">                        sess, image_lists, STEPS, <span class="string">'validation'</span>,</span><br><span class="line">                        jpeg_data_tensor, bottleneck_tensor))</span><br><span class="line"></span><br><span class="line">                validation_accuracy = sess.run(evaluation_step,</span><br><span class="line">                                               feed_dict=&#123;bottleneck_input: validation_bottlenecks,</span><br><span class="line">                                                          ground_truth_input: validation_ground_truth&#125;)</span><br><span class="line"></span><br><span class="line">                print(<span class="string">'Step %d: Validation accuracy = %.1f%%'</span> % (i, validation_accuracy * <span class="number">100</span>))</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 测试集测试模型</span></span><br><span class="line">        test_bottlenecks, test_ground_truth = get_random_cached_bottlenecks(</span><br><span class="line">            sess, image_lists, BATCH, <span class="string">'testing'</span>, jpeg_data_tensor, bottleneck_tensor)</span><br><span class="line">        test_accuracy = sess.run(evaluation_step,</span><br><span class="line">                                 feed_dict=&#123;bottleneck_input: test_bottlenecks,</span><br><span class="line">                                            ground_truth_input: test_ground_truth&#125;)</span><br><span class="line">        print(<span class="string">'Final test accuracy = %.1f%%'</span> % (test_accuracy * <span class="number">100</span>))</span><br></pre></td></tr></table></figure><p>备注：</p><p>完整的代码保存在”/home/student/public/deep_learning/TensorFlow/class4“中。</p>]]></content>
      
      <categories>
          
          <category> Framework </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tensorflow </tag>
            
            <tag> 入门教程 </tag>
            
            <tag> CNN </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用深度CNN识别MNIST数据集</title>
      <link href="/2018/12/06/tensorflow/3.1CNNforMNIST/"/>
      <url>/2018/12/06/tensorflow/3.1CNNforMNIST/</url>
      <content type="html"><![CDATA[<h1 id="使用深度CNN识别MNIST数据集"><a href="#使用深度CNN识别MNIST数据集" class="headerlink" title="使用深度CNN识别MNIST数据集"></a><font color="blue">使用深度CNN识别MNIST数据集</font></h1><p>TensorFlow是一个非常强大的用来做大规模数值计算的库。其所擅长的任务之一就是实现以及训练深度神经网络。<br>在本教程中，我们将学到构建一个TensorFlow模型的基本步骤，并将通过这些步骤为MNIST构建一个深度卷积神经网络。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>在创建模型之前，需要先加载MNIST数据集，然后启动一个TensorFlow的session。MNIST数据集在上一堂课程中已经具体介绍过，这里不再赘述。</p><h3 id="创建骨干程序"><a href="#创建骨干程序" class="headerlink" title="创建骨干程序"></a>创建骨干程序</h3><p>为主程序设置一个骨干程序。创建一个名为<code>cnn_mnist.py</code>的文件，添加下列代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from __future__ import absolute_import</span><br><span class="line">from __future__ import division</span><br><span class="line">from __future__ import print_function</span><br><span class="line"></span><br><span class="line"># Imports</span><br><span class="line">import numpy as np</span><br><span class="line">import tensorflow as tf</span><br><span class="line"></span><br><span class="line">tf.logging.set_verbosity(tf.logging.INFO)</span><br><span class="line"></span><br><span class="line"># Our application logic will be added here</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">  tf.app.run()</span><br></pre></td></tr></table></figure></p><p>完成本实验时，需要添加代码来构建，训练和评估卷积神经网络。完整的最终代码可以在 <a href="https://github.com/tensorflow/tensorflow/blob/r1.7/tensorflow/examples/tutorials/layers/cnn_mnist.py" target="_blank" rel="noopener">这里</a>找到。</p><h3 id="加载数据集"><a href="#加载数据集" class="headerlink" title="加载数据集"></a>加载数据集</h3><p>为了方便起见，使用一个脚本来自动下载和导入<a href="http://yann.lecun.com/exdb/mnist/" target="_blank" rel="noopener">MNIST</a>数据集。它会自动创建一个<code>MNIST_data</code>的目录来存储数据。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def loadData():</span><br><span class="line">    mnist = input_data.read_data_sets(&quot;./tmp/data&quot;, one_hot=True)</span><br><span class="line">    train_data = mnist.train.images # 返回 np.array</span><br><span class="line">    train_labels = np.asarray(mnist.train.labels, dtype=np.int32)</span><br><span class="line">    test_data = mnist.test.images # 返回 np.array</span><br><span class="line">    test_labels = np.asarray(mnist.test.labels, dtype=np.int32)</span><br><span class="line">    return mnist, train_data, train_labels, test_data, test_labels</span><br></pre></td></tr></table></figure><p>这里，<code>mnist</code>是一个轻量级的类。它以Numpy数组的形式存储着训练、校验和测试数据集。同时提供了一个函数，用于在迭代中获得minibatch，后面我们将会用到。</p><h3 id="CNN介绍"><a href="#CNN介绍" class="headerlink" title="CNN介绍"></a>CNN介绍</h3><p>卷积神经网络（CNN）是当前用于图像分类任务的最先进的模型体系结构。CNN将一系列<code>filter</code>应用于图像的原始像素数据以提取和学习更高级别的特征，使得该模型可用于分类。CNN包含三个模块：</p><ul><li>卷积层。将特定数量的卷积滤镜应用于图像。对于每个子区域，图层执行一组卷积运算，在输出特征映射中生成单个值。卷积层通常将 ReLU激活函数应用于输出从而将非线性引入到模型中。</li><li>池化层。对由卷积层提取的图像数据进行下采样，减少特征映射的维度，从而减少处理时间。常用的池化算法是最大池化，对其提取特征的子区域（例如，2×2像素的块），保持其最大值并丢弃所有其他值。</li><li>全连接层。对由卷积图层提取的特征执行分类，并由池化层进行下采样。全连接层中，图层中的每个节点都连接到前一图层中的每个节点。</li></ul><p>通常，CNN由执行特征提取的多个卷积模块组成。每个模块由一个卷积层和一个池层组成。最后的卷积模块之后是一个或多个执行分类的全连接层。CNN最后的全连接层包含模型中每个目标类的单个节点（模型可能预测的所有可能的类），使用 <code>softmax</code>激活函数为每个节点生成0-1之间的值（softmax值之和等于1）。可以将给定图像的softmax值解释为图像落入每个目标类别可能性的相对测量值。</p><h2 id="深度CNN分类器"><a href="#深度CNN分类器" class="headerlink" title="深度CNN分类器"></a>深度CNN分类器</h2><p>在上一个实验中，我们采用softmax regression训练了一个多分类器，其在MINIST上仅有91%的正确率，识别效果差强人意，因此，此次实验将其扩展为一个拥有多层卷积网络的softmax回归模型，将准确率提升至97.07%左右。模型构造为：</p><ol><li>卷积层1：使用32个5x5滤波器（提取5x5像素子区域），具有ReLU激活函数；</li><li>池化层1：使用2x2过滤器和步长2执行最大池化（指定池与池不重叠）；</li><li>卷积层2：使用64个5x5滤波器，具有ReLU激活函数；</li><li>池化层2：使用2x2过滤器和步长2执行最大池化；</li><li>全连接层1：1,024个神经元，Dropout正则化率为0.4（概率为0.4，任何给定元素在训练期间将被丢弃）；</li><li>全连接层2（Logits Layer）：10个神经元，每个数字目标类别（0-9）一个。</li></ol><p><code>tf.layers</code>模块包含创建上述三种图层类型的方法：</p><ul><li><code>conv2d()</code>。构造一个二维卷积层。采用过滤器数量，过滤内核大小，填充和激活函数作为参数。</li><li><code>max_pooling2d()</code>。使用max-pooling算法构造一个二维池化层。采用过滤器大小和步幅作为参数。</li><li><code>dense()</code>。构建一个全连接层。以神经元数量和激活函数作为参数。<br>这些方法中的每一个都接受张量作为输入，并将变换后的张量作为输出返回。这样可以很容易地将一个图层连接到另一个图层：只需从一个图层创建方法获取输出并将其作为输入提供给另一个图层。<h3 id="创建分类器"><a href="#创建分类器" class="headerlink" title="创建分类器"></a>创建分类器</h3>创建<code>cnn_model_fn()</code>函数，函数符合TensorFlow的Estimator API预期的界面（稍后在创建估算器中的更多内容）。cnn_mnist.py取MNIST特征数据，标签和 模型模式（TRAIN，EVAL，PREDICT）作为参数; 配置CNN; 并返回预测，损失和培训操作：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def cnn_model_fn(features, labels, mode):</span><br></pre></td></tr></table></figure></li></ul><p>创建模型的相关操作都在这个函数中编写。</p><h4 id="输入层"><a href="#输入层" class="headerlink" title="输入层"></a>输入层</h4><p><code>layers</code>用于为二维图像数据创建卷积层和合并层的模块中的方法期望输入张量具有如下定义的形状 ：<code>[batch_size, image_width, image_height, channels]</code></p><ul><li><code>batch_size</code>：在训练期间执行梯度下降时使用的示例子集的大小。</li><li><code>image_width</code>：示例图像的宽度。</li><li><code>image_height</code>：示例图像的高度。</li><li><code>channels</code>：示例图像中的颜色通道数量。对于彩色图像，通道数量是3（红色，绿色，蓝色）。对于单色图像，只有1个通道（黑色）。<br>这里，MNIST数据集由单色的28x28像素图像组成，因此输入图层的所需形状为：<code>[batch_size, 28, 28, 1]</code><br>为了将我们的输入特征映射（features）转换为这种形状，我们可以执行以下reshape操作：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input_layer = tf.reshape(features[&quot;x&quot;], [-1,28,28,1])</span><br></pre></td></tr></table></figure></li></ul><p>请注意，我们已经指定<code>-1</code>为批量大小，它指定此维度应根据输入值的数量进行动态计算 <code>features[&quot;x&quot;]</code>，并保持所有其他维度的大小不变。这使我们可以把它batch_size当作一个我们可以调整的超参数。例如，如果我们将样例以5批次的形式提供给我们的模型，<code>features[&quot;x&quot;]</code>将包含3,920个值（每个图像中的每个像素都有一个值），并且<code>input_layer</code>的形状为<code>[5, 28, 28, 1]</code>。同样，如果我们以100个批次为例提供示例，<code>features[&quot;x&quot;]</code>将包含78,400个值，并且<code>input_layer</code>的形状为<code>[100, 28, 28, 1]</code>。</p><h4 id="卷积层1"><a href="#卷积层1" class="headerlink" title="卷积层1"></a>卷积层1</h4><p>现在可以开始实现第一层。它由一个卷积接一个max pooling组成。在第一个卷积层中，我们希望将32个5x5滤波器应用到输入层，并使用ReLU激活函数。可以使用模块中<code>layers</code>的<code>conv2d()</code>方法来创建此图层，如下所示：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conv1 = tf.layers.conv2d(</span><br><span class="line">    inputs=input_layer,</span><br><span class="line">    filters=32,</span><br><span class="line">    kernel_size=[5, 5],</span><br><span class="line">    padding=&quot;same&quot;,</span><br><span class="line">    activation=tf.nn.relu)</span><br></pre></td></tr></table></figure></p><ul><li><code>inputs</code>参数指定了输入张量，形状为 ：<code>[batch_size, image_width, image_height, channels]</code>。在这里，将第一个卷积层连接到<code>input_layer</code>；</li><li><code>filters</code>参数指定过滤器的数量，这里是32；</li><li><code>kernel_size</code>指定了作为过滤器的尺寸<code>[width, height]</code>，这里是<code>[5, 5]</code>；</li><li><code>padding</code>参数指定两个枚举值之一（不区分大小写）：<code>valid</code>（默认值）或<code>same</code>。为了指定输出张量应该与输入张量具有相同的宽度和高度值，在这里设置padding=same，它表示TensorFlow将0值添加到输入张量的边缘以保持宽度和高度为28.（没有填充，a在28x28的张量上进行5x5的卷积将产生形状为24x24的张量）；</li><li><code>activation</code>参数指定应用于卷积输出的激活函数。在这里，我们指定了使用ReLU激活 <code>tf.nn.relu</code>。<br>输出张量<code>conv2d()</code>的形状为 ：<code>[batch_size, 28, 28, 32]</code>，与输入相同的宽度和高度尺寸，但现在有32个通道保持每个滤波器的输出。</li></ul><h4 id="池化层1"><a href="#池化层1" class="headerlink" title="池化层1"></a>池化层1</h4><p>接下来，将第一个池化层连接到刚刚创建的卷积层。可以使用<code>layers</code>的<code>max_pooling2d()</code>方法来构建一个使用2x2过滤器和步长为2的最大池化层：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pool1 = tf.layers.max_pooling2d(inputs=conv1, pool_size=[2, 2], strides=2)</span><br></pre></td></tr></table></figure></p><ul><li><code>inputs</code>指定输入张量，形状为 ：<code>[batch_size, image_width, image_height, channels]</code>。在这里，将第一个卷积层的输出连接到<code>inputs</code>；</li><li><code>pool_size</code>表示最大池化过滤器的尺寸<code>[width, height]</code>，这里是<code>[2, 2]</code>；</li><li><code>strides</code>指定步长的大小。在这里，我们设置步长为2，这表明由滤波器提取的子区域应该在宽度和高度维度上分开2个像素（对于2x2滤波器，这意味着没有提取的区域将重叠）。如果要为宽度和高度设置不同的步长值，则可以改为指定元组或列表（例如，<code>stride=[3, 6]</code>）。<br>由<code>max_pooling2d()</code>（pool1）生成的输出张量具有以下形状 ：<code>[batch_size, 14, 14, 32]</code>，2x2滤波器每个将宽度和高度减小50％。</li></ul><h4 id="卷积层2"><a href="#卷积层2" class="headerlink" title="卷积层2"></a>卷积层2</h4><p>类似于第一个卷积层，创建第二个卷积层，不过此处需要将其输入变为第一个池化层的输出。改变滤波器的个数，配置64个滤波器，尺寸不变：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conv2 = tf.layers.conv2d(</span><br><span class="line">    inputs=pool1,</span><br><span class="line">    filters=64,</span><br><span class="line">    kernel_size=[5, 5],</span><br><span class="line">    padding=&quot;same&quot;,</span><br><span class="line">    activation=tf.nn.relu)</span><br></pre></td></tr></table></figure><h4 id="池化层2"><a href="#池化层2" class="headerlink" title="池化层2"></a>池化层2</h4><p>和第一个池化层类似，只需要改变其输入为第二个卷积层的输出其步长和滤波器尺寸均不变：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pool2 = tf.layers.max_pooling2d(inputs=conv2, pool_size=[2, 2], strides=2)</span><br></pre></td></tr></table></figure></p><h4 id="全连接层1"><a href="#全连接层1" class="headerlink" title="全连接层1"></a>全连接层1</h4><p>现在，图片尺寸减小到7x7，最后加入一个有1024个神经元的全连接层，用于处理整个图片。把池化层输出的张量<code>reshape</code>成一些向量，再使用<code>dense()</code>方法来连接全连接层。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pool2_flat = tf.reshape(pool2, [-1, 7*7*64])</span><br><span class="line">dense = tf.layers.dense(inputs=pool2_flat, units=1024, activation=tf.nn.relu)</span><br></pre></td></tr></table></figure></p><ul><li><code>units</code>指定全连接层中的神经元数（1024）</li><li><code>activation</code>表示可使用的激活函数，使用<code>tf.nn.relu</code>添加ReLU激活。</li></ul><h4 id="Dropout正则化"><a href="#Dropout正则化" class="headerlink" title="Dropout正则化"></a>Dropout正则化</h4><p>为了减少过拟合，在输出层之前加入dropout。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dropout = tf.layers.dropout(</span><br><span class="line">    inputs=dense, rate=0.4, training=mode == tf.estimator.ModeKeys.TRAIN)</span><br></pre></td></tr></table></figure></p><ul><li><code>inputs</code>指定输入张量，它是来自全连接层1（<code>dense</code>）的输出张量；</li><li><code>rate</code>指定了丢弃概率; 在这里，我们使用0.4，这意味着40％的元素将在训练中被随机丢弃；</li><li><code>training</code>使用布尔指定模型目前是否训练模式下运行; 如果<code>training</code>为<code>True</code>，则仅执行丢弃。在这里，我们检查mode传递的模型函数<code>cnn_model_fn</code>是否是TRAIN模式。</li></ul><p>输出张量<code>dropout</code>的形状为：<code>[batch_size, 1024]</code>。</p><h4 id="Logits层"><a href="#Logits层" class="headerlink" title="Logits层"></a>Logits层</h4><p>神经网络中的最后一层是logits层，它会返回预测的原始值。创建一个包含10个神经元（每个目标类为0-9）的全连接层，并使用ReLU激活函数（默认值）：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">logits = tf.layers.dense(inputs=dropout, units=10)</span><br></pre></td></tr></table></figure></p><p>最终的CNN输出张量<code>logits</code>形状为：<code>[batch_size, 10]</code>。</p><h4 id="生成预测"><a href="#生成预测" class="headerlink" title="生成预测"></a>生成预测</h4><p>对于一个给定的例子，预测的类别是具有最高原始值的对数张量对应行中的元素。可以使用<code>tf.argmax</code> 函数找到这个元素的索引：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tf.argmax(input=logits, axis=1)</span><br></pre></td></tr></table></figure></p><p>通过softmax激活函数从<code>logits</code>层中得出该样本属于不同类别的概率，使用tf.nn.softmax：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tf.nn.softmax(logits, name=&quot;softmax_tensor&quot;)</span><br></pre></td></tr></table></figure></p><p>用字典存储预测值，并返回一个<code>EstimatorSpec</code>对象：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">predictions = &#123;</span><br><span class="line">    &quot;classes&quot;: tf.argmax(input=logits, axis=1),</span><br><span class="line">    &quot;probabilities&quot;: tf.nn.softmax(logits, name=&quot;softmax_tensor&quot;)</span><br><span class="line">&#125;</span><br><span class="line">if mode == tf.estimator.ModeKeys.PREDICT:</span><br><span class="line">  return tf.estimator.EstimatorSpec(mode=mode, predictions=predictions)</span><br></pre></td></tr></table></figure></p><h3 id="计算损失"><a href="#计算损失" class="headerlink" title="计算损失"></a>计算损失</h3><p>对于训练和评估，需要定义一个损失函数来衡量模型的预测和目标类别的匹配度。对于MNIST多分类问题，通常采用交叉熵作为损失度量。以下代码计算模型以任一模式<code>TRAIN</code>或<code>EVAL</code>模式运行时的交叉熵：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">onehot_labels = tf.one_hot(indices=tf.cast(labels, tf.int32), depth=10)</span><br><span class="line">loss = tf.losses.softmax_cross_entropy(</span><br><span class="line">    onehot_labels=onehot_labels, logits=logits)</span><br></pre></td></tr></table></figure></p><p><code>labels</code>张量包含了样本的预测列表，例如[1, 9, …]。为了计算交叉熵，首先需要转换<code>labels</code> 成相应的单热编码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[0, 1, 0, 0, 0, 0, 0, 0, 0, 0],</span><br><span class="line"> [0, 0, 0, 0, 0, 0, 0, 0, 0, 1],</span><br><span class="line"> ...]</span><br></pre></td></tr></table></figure></p><h3 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h3><p>在前面，将CNN的损失定义为<code>logits</code>层和标签的<code>softmax</code>交叉熵。现在配置模以在训练期间优化这个损失值。使用0.001的学习率和随机梯度下降算法作为优化算法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if mode == tf.estimator.ModeKeys.TRAIN:</span><br><span class="line">  optimizer = tf.train.GradientDescentOptimizer(learning_rate=0.001)</span><br><span class="line">  train_op = optimizer.minimize(</span><br><span class="line">      loss=loss,</span><br><span class="line">      global_step=tf.train.get_global_step())</span><br><span class="line">  return tf.estimator.EstimatorSpec(mode=mode, loss=loss, train_op=train_op)</span><br></pre></td></tr></table></figure></p><h3 id="模型评估"><a href="#模型评估" class="headerlink" title="模型评估"></a>模型评估</h3><p>要在模型中添加准确性度量，<code>eval_metric_ops</code>在<code>EVAL</code>模式中定义字典，如下所示：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eval_metric_ops = &#123;</span><br><span class="line">    &quot;accuracy&quot;: tf.metrics.accuracy(</span><br><span class="line">        labels=labels, predictions=predictions[&quot;classes&quot;])&#125;</span><br><span class="line">return tf.estimator.EstimatorSpec(</span><br><span class="line">    mode=mode, loss=loss, eval_metric_ops=eval_metric_ops)</span><br></pre></td></tr></table></figure></p><h2 id="训练模型过程"><a href="#训练模型过程" class="headerlink" title="训练模型过程"></a>训练模型过程</h2><h3 id="创建模型评估器"><a href="#创建模型评估器" class="headerlink" title="创建模型评估器"></a>创建模型评估器</h3><p>创建<code>main()</code>函数，将下面的步骤加入<code>main()</code>函数中。</p><p>创建一个<code>Estimator</code>来评估模型（TensorFlow类，用于执行高级模型训练，评估和推理）。将以下代码添加到main()：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Create the Estimator</span><br><span class="line">mnist_classifier = tf.estimator.Estimator(</span><br><span class="line">    model_fn=cnn_model_fn, model_dir=&quot;./tmp/mnist_convnet_model&quot;)</span><br></pre></td></tr></table></figure><ul><li><code>model_fn</code>指定模型用于训练、评估或预测，传递<code>cnn_model_fn</code>，即分类器函数；</li><li><code>model_dir</code>指定模型数据的保存目录，这里指定一个临时目录，可以更改为需要存储的路径。</li></ul><h3 id="添加输出到日志系统"><a href="#添加输出到日志系统" class="headerlink" title="添加输出到日志系统"></a>添加输出到日志系统</h3><p>由于CNN可能需要一段时间才能进行训练，因此设置一些日志记录，以便在训练期间跟踪进度。可以使用<code>tf.train.SessionRunHook</code>创建一个 <code>tf.train.LoggingTensorHook</code>，记录softmax层的概率值。将以下内容添加到main()：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Set up logging for predictions</span><br><span class="line">tensors_to_log = &#123;&quot;probabilities&quot;: &quot;softmax_tensor&quot;&#125;</span><br><span class="line">logging_hook = tf.train.LoggingTensorHook(</span><br><span class="line">    tensors=tensors_to_log, every_n_iter=50)</span><br></pre></td></tr></table></figure></p><p><code>tensors_to_log</code>是一个字典，用于存储需要输出日志的张量。字典的<code>key</code>是选择的标签，将打印在日志输出中，相应的<code>value</code>是TensorTensorFlow图模型中的张量名称。</p><h3 id="训练过程"><a href="#训练过程" class="headerlink" title="训练过程"></a>训练过程</h3><p>现在，已经准备好训练模型，可以通过创建<code>train_input_fn</code>和调用<code>mnist_classifier</code>的<code>train()</code>函数进行训练。将以下内容添加到<code>main()</code>函数：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Train the model</span><br><span class="line">train_input_fn = tf.estimator.inputs.numpy_input_fn(</span><br><span class="line">    x=&#123;&quot;x&quot;: train_data&#125;,</span><br><span class="line">    y=train_labels,</span><br><span class="line">    batch_size=100,</span><br><span class="line">    num_epochs=None,</span><br><span class="line">    shuffle=True)</span><br><span class="line">mnist_classifier.train(</span><br><span class="line">    input_fn=train_input_fn,</span><br><span class="line">    steps=20000,</span><br><span class="line">    hooks=[logging_hook])</span><br></pre></td></tr></table></figure></p><p>在<code>numpy_input_fn</code>函数中：</p><ul><li>分别将训练特征数据和标签传递给<code>x</code>（作为字典）<code>y</code>；</li><li>设置<code>batch_size</code>的100（每一步在100个样本中训练模型）；</li><li><code>num_epochs=None</code>表示模型将训练到达到指定的步数；</li><li><p><code>shuffle=True</code>表示洗牌训练数据。<br>在<code>mnist_classifier.train</code>函数中：</p></li><li><p>设置<code>steps=20000</code> （模型将训练共20,000步）；</p></li><li>设置<code>hooks</code>为<code>logging_hook</code>，它在训练期间被触发。<br>由于运行输出数据较多，只选取其中一部分展示：</li></ul><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/tensorflow/47979028.jpg" width="75%"><br></center><h2 id="模型评估-1"><a href="#模型评估-1" class="headerlink" title="模型评估"></a>模型评估</h2><p>训练完成后，需要评估模型以确定其在MNIST测试集上的准确性。使用<code>evaluate</code>方法评估模型，和训练模型类似，但只需要将迭代步数改变为1，即只需要执行一次操作。将以下内容添加到main()：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Evaluate the model and print results</span><br><span class="line">eval_input_fn = tf.estimator.inputs.numpy_input_fn(</span><br><span class="line">    x=&#123;&quot;x&quot;: eval_data&#125;,</span><br><span class="line">    y=eval_labels,</span><br><span class="line">    num_epochs=1,</span><br><span class="line">    shuffle=False)</span><br><span class="line">eval_results = mnist_classifier.evaluate(input_fn=eval_input_fn)</span><br><span class="line">print(eval_results)</span><br></pre></td></tr></table></figure></p><p>运行结果：</p><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/tensorflow/30440377.jpg" width="75%"><br></center><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INFO:tensorflow:Saving checkpoints for 20000 into /tmp/mnist_convnet_model/model.ckpt.                                                                                                      </span><br><span class="line">INFO:tensorflow:Loss for final step: 0.0446627.                                                                                                                                             </span><br><span class="line">INFO:tensorflow:Starting evaluation at 2018-04-18-11:59:47                                                                                                                                  </span><br><span class="line">2018-04-18 11:59:47.857775: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1120] Creating TensorFlow device (/device:GPU:0) -&gt; (device: 0, name: Quadro P4000, pci bus id: 0000:01:00.0,</span><br><span class="line"> compute capability: 6.1)                                                                                                                                                                   </span><br><span class="line">INFO:tensorflow:Restoring parameters from /tmp/mnist_convnet_model/model.ckpt-20000                                                                                                         </span><br><span class="line">INFO:tensorflow:Finished evaluation at 2018-04-18-11:59:48                                                                                                                                  </span><br><span class="line">INFO:tensorflow:Saving dict for global step 20000: accuracy = 0.9707, global_step = 20000, loss = 0.100675                                                                                  </span><br><span class="line">&#123;&apos;loss&apos;: 0.10067523, &apos;global_step&apos;: 20000, &apos;accuracy&apos;: 0.97070003&#125;</span><br></pre></td></tr></table></figure><p>备注：</p><p>完整的代码保存在”/home/student/public/deep_learning/TensorFlow/class3“中。</p>]]></content>
      
      <categories>
          
          <category> Framework </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tensorflow </tag>
            
            <tag> 入门教程 </tag>
            
            <tag> CNN </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TensorFlow实现Softmax Regression识别手写数字</title>
      <link href="/2018/12/06/tensorflow/2.2Softmax-Regression/"/>
      <url>/2018/12/06/tensorflow/2.2Softmax-Regression/</url>
      <content type="html"><![CDATA[<h1 id="TensorFlow实现Softmax-Regression识别手写数字"><a href="#TensorFlow实现Softmax-Regression识别手写数字" class="headerlink" title="TensorFlow实现Softmax Regression识别手写数字"></a><font color="blue">TensorFlow实现Softmax Regression识别手写数字</font></h1><h2 id="MNIST数据集"><a href="#MNIST数据集" class="headerlink" title="MNIST数据集"></a>MNIST数据集</h2><p>MNIST（Mixed National Institute of Standards and Technology database）是一个非常简单的机器视觉数据集，它由几万张28像素×28像素的手写数字组成，这些图片只包含灰度值信息。我们的任务是对这些手写数字的图片进行分类，转换为0-9一共10类。<br></p><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/tensorflow/62516735.jpg" width="50%/"><br></center><p>数据集包含：</p><ul><li>train-images-idx3-ubyte 训练数据图像 (60,000)</li><li>train-labels-idx1-ubyte 训练数据label</li><li>t10k-images-idx3-ubyte 测试数据图像 (10,000)</li><li>t10k-labels-idx1-ubyte 测试数据label<br><br>对MNIST数据集加载时，TensorFlow为我们提供了一个方便的封装，可以直接加载MNIST数据成为我们期望的格式。<br><br>对MNIST数据集加载时，TensorFlow为我们提供了一个方便的封装，可以直接加载MNIST数据成为我们期望的格式。<br></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import input_data</span><br><span class="line">mnist = input_data.read_data_sets(&quot;MNIST_data/&quot;, one_hot=True)</span><br></pre></td></tr></table></figure><p>查看MNIST数据集，其图像是28×28像素大小的灰度图片。空白部分全为0，有笔迹的地方根据颜色深浅有0-1之间的取值。相当于每个样本有784（28×28=784）维特征，因此丢弃图片的二维结构信息，把一张图片变为一个很长的1维向量。<br></p><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/tensorflow/90357367.jpg" width="75%/"><br></center><p>训练数据共有55000张灰度图，则训练集的训练数据为60000×784的Tensor，训练数据的Label是一个60000×10的Tensor。对10个类进行one-hot编码，Label是一个10维的向量，只有对应数字正确的位置为1，其他都为0.如数字0，对应Label为[1,0,0,0,0,0,0,0,0,0]；数字8对应Label为[0,0,0,0,0,0,0,0,1,0]。<br></p><h2 id="Softmax-Regression算法"><a href="#Softmax-Regression算法" class="headerlink" title="Softmax Regression算法"></a>Softmax Regression算法</h2><h3 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h3><p>&emsp;&emsp;我们的分类结果共有10个，当模型对一张图片进行预测时，Softmax Regression会对每一种类别估算一个概率。如预测是数字3的概率为80%，是数字5的概率为5%，最后概率最大的数字作为模型的输出。<br><br>&emsp;&emsp;当处理多分类任务时，通常需要使用Softmax Regression 模型。其工作原理很简单，可以判定为某类的特征相加，然后将这些特征转化为判定是这一类的概率。特征可以通过一些简单的方法得到，如对所有像素求加权和，权重是通过数据训练出来的。如某个像素的灰度值大代表很可能是数字n时，这个像素的权重就很大，如果某像素的灰度值大代表不太可能是数字n时，这个像素的权重可能是负的。<br>&emsp;     将这些特征写成如下公式：<br></p><p>$feature_i = \sum\limits_{j}W_{i,j}x_j+bb_j$</p><p>i代表第i类，j代表一张图片的第j个像素。bi是bias，即数据本身的一些偏置项，比如大部分数字都是0，那么0的特征对应的bias就会很大。<br><br>&emsp;&emsp;接下来对所有特征计算softmax。都是计算一个exp函数，再进行标准化，其目的是让所有的类别输出概率值和为1。$$softmax(x)=normalize(exp(x))$$其中判定为第i类的概率就可以由下面的公式得到：<br>    &emsp;$$softmax(x)_i=\frac{exp(x_i)}{\sum\limits_{j}exp(x_j)}$$<br>&emsp;&emsp;先对各个特征求exp函数，然后将其归一化，特征值越大的类，最后输出的概率也越大，使用exp函数保证了所有的特征值概率不可能小于或等于0，将Softmax Regression的计算过程可视化：<br></p><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/tensorflow/38532106.jpg" width="75%/"><br></center><p>将图变为公式，元素相乘变为矩阵乘法：<br><br>$$<br>\begin{bmatrix}y_1\y_2\y_3\end{bmatrix}=softmax\left{\begin{bmatrix}W_{1,1}&amp;W_{1,2}&amp;W_{1,3}\W_{2,1}&amp;W_{2,2}&amp;W_{2,3}\W_{3,1}&amp;W_{3,2}&amp;W_{3,3}\end{bmatrix}\cdot\begin{bmatrix}x_1\x_2\x_3\end{bmatrix}+\begin{bmatrix}b_1\b_2\b_3\end{bmatrix}\right}<br>$$</p><p>则上述矩阵可以表示为：<br></p><p>$$y=softmax(Wx+b)$$<br>&emsp;&emsp;使用TensorFlow实现Softmax Regression。在python中使用Numpy进行矩阵的操作运算，首先创建一个输入的变量：<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line">x = tf.placeholder(&quot;float&quot;, [None, 784])</span><br></pre></td></tr></table></figure><p>None表示样本的个数，这里不限个数的输入。<br></p><p>接下来创建weights和biases变量，并使用公式计算y的值<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">W = tf.Variable(tf.zeros([784,10]))</span><br><span class="line">b = tf.Variable(tf.zeros([10]))</span><br><span class="line">y = tf.nn.softmax(tf.matmul(x,W) + b)</span><br></pre></td></tr></table></figure><h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>为了训练模型，需要定义一个loss function来描述模型对问题的分类精度。为了得到最好的训练效果，希望loss越小越好。对于多分类问题，通常使用交叉熵（cross-entropy）作为损失函数：$$H_{y’}(y)=-\sum\limits_{i}y’_i\log(y_i)$$其中y是预测的概率分布，y’是真实的概率分布。在TensorFlow中定义cross-entropy：<br><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">y_ = tf.placeholder(&quot;float&quot;, [None,10])</span><br><span class="line">cross_entropy = -tf.reduce_sum(y_*tf.log(y))</span><br></pre></td></tr></table></figure></p><h3 id="随机梯度下降算法"><a href="#随机梯度下降算法" class="headerlink" title="随机梯度下降算法"></a>随机梯度下降算法</h3><p>TensorFlow可以根据定义好的计算题自动求导，并根据反向传播算法进行训练，在每一轮迭代时，更新参数来最小化loss。TensorFlow已经封装好了随机梯度下降算法的优化器，我们只需要直接调用<code>tf.train.GradientDescentOptimizer</code>，设置函数的学习率以及优化的目标损失函数。<br><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">train_step = tf.train.GradientDescentOptimizer(0.01).minimize(cross_entropy)</span><br></pre></td></tr></table></figure></p><p>在这里，我们要求TensorFlow用梯度下降算法（gradient descent algorithm）以0.01的学习速率最小化交叉熵。梯度下降算法（gradient descent algorithm）是一个简单的学习过程，TensorFlow只需将每个变量一点点地往使成本不断降低的方向移动。<br></p><h3 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h3><p>定义好所有参数以及优化方法后，在Session中启动模型，并且初始化变量。<br><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">init = tf.initialize_all_variables()</span><br><span class="line">sess = tf.Session()</span><br><span class="line">sess.run(init)</span><br></pre></td></tr></table></figure></p><p>然后开始训练模型，这里我们让模型循环训练1000次。在每次训练时，随机抓取训练数据中的100个样本批处理样本点。<br><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for i in range(1000):</span><br><span class="line">    batch_xs, batch_ys = mnist.train.next_batch(100)</span><br><span class="line">    sess.run(train_step, feed_dict=&#123;x: batch_xs, y_: batch_ys&#125;)</span><br></pre></td></tr></table></figure></p><p>使用一小部分的随机数据来进行训练被称为随机训练（stochastic training），更确切的说是随机梯度下降训练。在理想情况下，我们希望用所有的数据来进行每一步的训练，因为这能得到更好的训练结果，但这需要很大的计算开销。所以，每一次训练使用不同的数据子集，这样做既可以减少计算开销，又可以最大化地学习到数据集的总体特性。<br></p><h2 id="模型评估"><a href="#模型评估" class="headerlink" title="模型评估"></a>模型评估</h2><p>我们可以用预测结果的正确率来判断模型的性能。首先找出那些预测正确的标签。<code>tf.argmax</code>能给出某个tensor对象在某一维上数据最大值所在的索引值。由于标签向量是由0,1组成，因此最大值1所在的索引位置就是类别标签，比如<code>tf.argmax(y,1)</code>返回的是模型对于任一输入x预测到的标签值，而<code>tf.argmax(y_,1)</code>代表实际的正确标签，用<code>tf.equal</code>来检测预测是否和真实标签匹配(索引位置一样表示匹配)。<br><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">correct_prediction = tf.equal(tf.argmax(y,1), tf.argmax(y_,1))</span><br><span class="line">accuracy = tf.reduce_mean(tf.cast(correct_prediction, &quot;float&quot;))</span><br></pre></td></tr></table></figure></p><p>最后，计算训练的模型在测试数据集上的正确率：<br><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print sess.run(accuracy, feed_dict=&#123;x: mnist.test.images, y_: mnist.test.labels&#125;)</span><br></pre></td></tr></table></figure></p><p>最终的结果值大约为91%，其正确率并不是很高，原因在于我们使用的模型十分简单，它并不是一个神经网络模型，在现在的模型基础上增加一层隐藏层，就会变成一个神经网络，且正确率更高。<br></p><p>备注：</p><p>完整的代码保存在”/home/student/public/deep_learning/TensorFlow/class2“中。</p>]]></content>
      
      <categories>
          
          <category> Framework </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tensorflow </tag>
            
            <tag> 入门教程 </tag>
            
            <tag> CNN </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TensorFlow搭建神经网络</title>
      <link href="/2018/12/06/tensorflow/2.1create_neural_network/"/>
      <url>/2018/12/06/tensorflow/2.1create_neural_network/</url>
      <content type="html"><![CDATA[<h1 id="TensorFlow搭建神经网络"><a href="#TensorFlow搭建神经网络" class="headerlink" title=" TensorFlow搭建神经网络"></a><font color="blue"> TensorFlow搭建神经网络</font></h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>使用TensorFlow搭建一个神经网络。在此次实验中，实现TensorFlow模型有两部分</p><ul><li>创建计算图</li><li>运行计算图</li></ul><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><h3 id="导入TensorFlow库"><a href="#导入TensorFlow库" class="headerlink" title="导入TensorFlow库"></a>导入TensorFlow库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import math</span><br><span class="line">import numpy as np</span><br><span class="line">import h5py</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import tensorflow as tf</span><br><span class="line">from tensorflow.python.framework import ops</span><br><span class="line">from tf_utils import load_dataset, random_mini_batches, convert_to_one_hot, predict</span><br><span class="line"></span><br><span class="line">%matplotlib inline</span><br><span class="line">np.random.seed(1)</span><br></pre></td></tr></table></figure><h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><p>此次使用的数据集为手语图片，你需要构建一个算法，以便于从语言障碍人士到不懂手语的人进行沟通。</p><ul><li>训练集：1080张手势图片，每张图片像素为（64×64），手势共有6类，分别表示从0到5的数字（每种有180张图片）</li><li>测试集：120张手势图片，每张图片像素为（64×64），手势共有6类，分别表示从0到5的数字（每种有20张图片）</li></ul><p>请注意，这是SINGS数据集的一个子集，完整的数据集包含更多的图像。<br>以下是每个数字的示例，以及如何表示标签。 这些在将图像的像素降低到64×64像素之前的原始图片。</p><p><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/tensorflow/69143400.jpg" width="75%/"><br></center><br>下列代码用于加载数据集：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 加载数据集</span><br><span class="line">X_train_orig, Y_train_orig, X_test_orig, Y_test_orig, classes = load_dataset()</span><br></pre></td></tr></table></figure></p><p>更改下面代码中的index并运行代码，可视化数据集中的一个样本。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 图片样本</span><br><span class="line">index = 0</span><br><span class="line">plt.imshow(X_train_orig[index])</span><br><span class="line">print (&quot;y = &quot; + str(np.squeeze(Y_train_orig[:, index])))</span><br></pre></td></tr></table></figure></p><p>代码运行结果为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">y = 5</span><br></pre></td></tr></table></figure></p><p>将数据集平坦化，然后通过对数据矩阵除以255对其进行归一化。并且将标签转换为one-hot编码的向量，运行下面的代码执行此操作。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 平坦化数据集</span><br><span class="line">X_train_flatten = X_train_orig.reshape(X_train_orig.shape[0], -1).T</span><br><span class="line">X_test_flatten = X_test_orig.reshape(X_test_orig.shape[0], -1).T</span><br><span class="line"># 归一化数据集</span><br><span class="line">X_train = X_train_flatten/255.</span><br><span class="line">X_test = X_test_flatten/255.</span><br><span class="line"># 将标签转换为one-hot编码向量</span><br><span class="line">Y_train = convert_to_one_hot(Y_train_orig, 6)</span><br><span class="line">Y_test = convert_to_one_hot(Y_test_orig, 6)</span><br><span class="line"></span><br><span class="line">print (&quot;number of training examples = &quot; + str(X_train.shape[1]))</span><br><span class="line">print (&quot;number of test examples = &quot; + str(X_test.shape[1]))</span><br><span class="line">print (&quot;X_train shape: &quot; + str(X_train.shape))</span><br><span class="line">print (&quot;Y_train shape: &quot; + str(Y_train.shape))</span><br><span class="line">print (&quot;X_test shape: &quot; + str(X_test.shape))</span><br><span class="line">print (&quot;Y_test shape: &quot; + str(Y_test.shape))</span><br></pre></td></tr></table></figure></p><p>代码运行结果为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">number of training examples = 1080</span><br><span class="line">number of test examples = 120</span><br><span class="line">X_train shape: (12288, 1080)</span><br><span class="line">Y_train shape: (6, 1080)</span><br><span class="line">X_test shape: (12288, 120)</span><br><span class="line">Y_test shape: (6, 120)</span><br></pre></td></tr></table></figure></p><p>注意：12288=64×64×3。每个图片为64×64像素，3是RGB颜色。<br>目的：搭建一个高精度识别手势的算法。要做到这一点，需要建立一个TensorFlow模型，最后使用softmax层输出。<br>模型：LINEAR  - &gt; RELU  - &gt; LINEAR  - &gt; RELU  - &gt; LINEAR  - &gt; SOFTMAX。</p><h3 id="创建placeholders"><a href="#创建placeholders" class="headerlink" title="创建placeholders"></a>创建placeholders</h3><p>首先为X和Y创建placeholder，在运行session时传递训练数据。<br>练习：补充下面的函数，在TensorFlow中创建placeholder。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># GRADED FUNCTION: create_placeholders</span><br><span class="line"></span><br><span class="line">def create_placeholders(n_x, n_y):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    为session创建placeholder</span><br><span class="line">    </span><br><span class="line">    Arguments:</span><br><span class="line">    n_x -- scalar, 图片向量的大小 (num_px * num_px = 64 * 64 * 3 = 12288)</span><br><span class="line">    n_y -- scalar, 类别数量 (从0到5的数字, 因此为6)</span><br><span class="line">    </span><br><span class="line">    Returns:</span><br><span class="line">    X -- 输入数据集的placeholder, shape：[n_x, None] ，dtype：&quot;float&quot;</span><br><span class="line">    Y -- 输出标签的placeholder, shape：[n_y, None] ，dtype：&quot;float&quot;</span><br><span class="line">    </span><br><span class="line">    Tips:</span><br><span class="line">    - 创建placeholder时使用None可以灵活地处理placeholder的数量，</span><br><span class="line">      因为训练集和测试集的样本数量是不相同的。</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    ### 填写代码 ###</span><br><span class="line">    X = None</span><br><span class="line">    Y = None</span><br><span class="line">    ### 完成代码 ### </span><br><span class="line">    </span><br><span class="line">    return X, Y</span><br></pre></td></tr></table></figure></p><p>检验：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X, Y = create_placeholders(12288, 6)</span><br><span class="line">print (&quot;X = &quot; + str(X))</span><br><span class="line">print (&quot;Y = &quot; + str(Y))</span><br></pre></td></tr></table></figure></p><p>代码运行结果为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X = Tensor(&quot;Placeholder:0&quot;, shape=(12288, ?), dtype=float32)</span><br><span class="line">Y = Tensor(&quot;Placeholder_1:0&quot;, shape=(6, ?), dtype=float32)</span><br></pre></td></tr></table></figure></p><h3 id="初始化参数变量"><a href="#初始化参数变量" class="headerlink" title="初始化参数变量"></a>初始化参数变量</h3><p>接下来需要在TensorFlow中初始化参数。<br>练习：实现下面的功能来初始化tensorflow中的参数。使用Xavier初始化权重，Zero 初始化偏置项。参数的形状如下。给出例子，W1和B1：</p><ul><li>W1 = tf.get_variable(“W1”, [25,12288], initializer =tf.contrib.layers.xavier_initializer(seed = 1))</li><li>b1 = tf.get_variable(“b1”, [25,1], initializer = tf.zeros_initializer())</li></ul><p>为了确保所有人的输出值都相同，使用seed=1。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># GRADED FUNCTION: initialize_parameters</span><br><span class="line"></span><br><span class="line">def initialize_parameters():</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    初始化神经网络的参数，其形状为:</span><br><span class="line">                        W1 : [25, 12288]</span><br><span class="line">                        b1 : [25, 1]</span><br><span class="line">                        W2 : [12, 25]</span><br><span class="line">                        b2 : [12, 1]</span><br><span class="line">                        W3 : [6, 12]</span><br><span class="line">                        b3 : [6, 1]</span><br><span class="line">    </span><br><span class="line">    Returns:</span><br><span class="line">    parameters -- 存储W1, b1, W2, b2, W3, b3张量的字典</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    </span><br><span class="line">    tf.set_random_seed(1)                   # 为了确保所有人的输出值都相同</span><br><span class="line">        </span><br><span class="line">    ### 填写代码 ###</span><br><span class="line">    W1 = None</span><br><span class="line">    b1 = None</span><br><span class="line">    W2 = None</span><br><span class="line">    b2 = None</span><br><span class="line">    W3 = None</span><br><span class="line">    b3 = None</span><br><span class="line">    ### 完成代码 ### </span><br><span class="line"></span><br><span class="line">    parameters = &#123;&quot;W1&quot;: W1,</span><br><span class="line">                  &quot;b1&quot;: b1,</span><br><span class="line">                  &quot;W2&quot;: W2,</span><br><span class="line">                  &quot;b2&quot;: b2,</span><br><span class="line">                  &quot;W3&quot;: W3,</span><br><span class="line">                  &quot;b3&quot;: b3&#125;</span><br><span class="line">    </span><br><span class="line">    return parameters</span><br></pre></td></tr></table></figure></p><p>测试代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tf.reset_default_graph()</span><br><span class="line">with tf.Session() as sess:</span><br><span class="line">    parameters = initialize_parameters()</span><br><span class="line">    print(&quot;W1 = &quot; + str(parameters[&quot;W1&quot;]))</span><br><span class="line">    print(&quot;b1 = &quot; + str(parameters[&quot;b1&quot;]))</span><br><span class="line">    print(&quot;W2 = &quot; + str(parameters[&quot;W2&quot;]))</span><br><span class="line">    print(&quot;b2 = &quot; + str(parameters[&quot;b2&quot;]))</span><br></pre></td></tr></table></figure></p><p>代码运行结果为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">W1 = &lt;tf.Variable &apos;W1:0&apos; shape=(25, 12288) dtype=float32_ref&gt;</span><br><span class="line">b1 = &lt;tf.Variable &apos;b1:0&apos; shape=(25, 1) dtype=float32_ref&gt;</span><br><span class="line">W2 = &lt;tf.Variable &apos;W2:0&apos; shape=(12, 25) dtype=float32_ref&gt;</span><br><span class="line">b2 = &lt;tf.Variable &apos;b2:0&apos; shape=(12, 1) dtype=float32_ref&gt;</span><br></pre></td></tr></table></figure></p><p>此时参数还未进行赋值。</p><h3 id="前向传播"><a href="#前向传播" class="headerlink" title="前向传播"></a>前向传播</h3><p>现在实现TensorFlow前向传播的模块。该函数将接收参数字典并完成正向传播。可以使用的函数是：</p><ul><li>tf.add(…,…) 矩阵加法</li><li>tf.matmul(…,…) 矩阵乘法</li><li>tf.nn.relu(…) ReLu激活函数</li></ul><p>问题：实现神经网络的正向传播。将numpy和TensorFlow进行比较。注意前向传播在z3处停止，因为在TensorFlow中，最后的线性层输出作为损失函数的输入。因此，不需要计算a3.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># GRADED FUNCTION: forward_propagation</span><br><span class="line"></span><br><span class="line">def forward_propagation(X, parameters):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    前向传播模型: LINEAR -&gt; RELU -&gt; LINEAR -&gt; RELU -&gt; LINEAR -&gt; SOFTMAX</span><br><span class="line">    </span><br><span class="line">    Arguments:</span><br><span class="line">    X -- input dataset placeholder, of shape (input size, number of examples)</span><br><span class="line">    parameters -- python字典，包含 &quot;W1&quot;, &quot;b1&quot;, &quot;W2&quot;, &quot;b2&quot;, &quot;W3&quot;, &quot;b3&quot;</span><br><span class="line">                  其形状由initialize_parameters函数给出</span><br><span class="line"></span><br><span class="line">    Returns:</span><br><span class="line">    Z3 -- 最后一个线性层的输出</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    </span><br><span class="line">    # 从&quot;parameters&quot;字典中恢复参数</span><br><span class="line">    W1 = parameters[&apos;W1&apos;]</span><br><span class="line">    b1 = parameters[&apos;b1&apos;]</span><br><span class="line">    W2 = parameters[&apos;W2&apos;]</span><br><span class="line">    b2 = parameters[&apos;b2&apos;]</span><br><span class="line">    W3 = parameters[&apos;W3&apos;]</span><br><span class="line">    b3 = parameters[&apos;b3&apos;]</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">### 填写代码 ###              # Numpy 等式:</span><br><span class="line">    Z1 = None                                              # Z1 = np.dot(W1, X) + b1</span><br><span class="line">    A1 = None                                              # A1 = relu(Z1)</span><br><span class="line">    Z2 = None                                              # Z2 = np.dot(W2, a1) + b2</span><br><span class="line">    A2 = None                                              # A2 = relu(Z2)</span><br><span class="line">    Z3 = None                                              # Z3 = np.dot(W3,Z2) + b3</span><br><span class="line">    ### 完成代码 ### </span><br><span class="line">    </span><br><span class="line">    return Z3</span><br></pre></td></tr></table></figure></p><p>代码运行结果为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Z3 = Tensor(&quot;add_2:0&quot;, shape=(6, ?), dtype=float32)</span><br></pre></td></tr></table></figure></p><p>此时发现前向传播不会输出任何值，在反向传播的过程中可以知道原因。</p><h3 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h3><p>在之前的实验中，代价函数可以根据一行代码给出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(logits = ..., labels = ...))</span><br></pre></td></tr></table></figure></p><p>问题：补充代价函数</p><ul><li>tf.nn.softmax_cross_entropy_with_logits的“logits”和“labels”输入具有的形状应为（样本数，类别数），这里提供已经变形后的Z3和Y</li><li>tf.reduce_mean是对样本进行求和</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># GRADED FUNCTION: compute_cost </span><br><span class="line"></span><br><span class="line">def compute_cost(Z3, Y):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    计算损失</span><br><span class="line">    </span><br><span class="line">    Arguments:</span><br><span class="line">    Z3 -- 前向传播得到的输出 (模型最后一层线性层的输出), 形状为 (6, 样本数)</span><br><span class="line">    Y -- 标签向量placeholder, 和Z3有相同的形状</span><br><span class="line">    </span><br><span class="line">    Returns:</span><br><span class="line">    cost - 代价函数的张量</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    </span><br><span class="line">    # 需要用到 tf.nn.softmax_cross_entropy_with_logits(...,...)</span><br><span class="line">    logits = tf.transpose(Z3)</span><br><span class="line">    labels = tf.transpose(Y)</span><br><span class="line">    </span><br><span class="line">    ### 填写代码 ###   </span><br><span class="line">    cost = None</span><br><span class="line">    ### 完成代码 ### </span><br><span class="line">    </span><br><span class="line">    return cost</span><br></pre></td></tr></table></figure><p>测试代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tf.reset_default_graph()</span><br><span class="line"></span><br><span class="line">with tf.Session() as sess:</span><br><span class="line">    X, Y = create_placeholders(12288, 6)</span><br><span class="line">    parameters = initialize_parameters()</span><br><span class="line">    Z3 = forward_propagation(X, parameters)</span><br><span class="line">    cost = compute_cost(Z3, Y)</span><br><span class="line">    print(&quot;cost = &quot; + str(cost))</span><br></pre></td></tr></table></figure></p><p>代码运行结果为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cost = Tensor(&quot;Mean:0&quot;, shape=(), dtype=float32)</span><br></pre></td></tr></table></figure></p><h3 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h3><p>使用TensorFlow时，所有反向传播的参数更新都使用1行代码处理。计算了代价函数后，创建一个“optimizer”对象，运行tf.session时，对象必须和代价函数同时运行。当它被调用时，优化给定的方法和学习率的代价函数。例如，使用梯度下降法优化代价函数：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">optimizer = tf.train.GradientDescentOptimizer(learning_rate = learning_rate).minimize(cost)</span><br></pre></td></tr></table></figure></p><p>为了运行这个对象，需要：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_ , c = sess.run([optimizer, cost], feed_dict=&#123;X: minibatch_X, Y: minibatch_Y&#125;)</span><br></pre></td></tr></table></figure></p><p>在计算图中，从成本到输入，反向地计算，来更新参数值。<br>注意：在编码时，通常使用“ _ ”作为一次性变量，存储以后不需要使用的值，c为代价的值。</p><h3 id="创建模型"><a href="#创建模型" class="headerlink" title="创建模型"></a>创建模型</h3><p>将上面的模块融合到一起就是一个神经网络的模型。<br>练习：创建model，使用上面完成的函数。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def model(X_train, Y_train, X_test, Y_test, learning_rate = 0.0001,</span><br><span class="line">          num_epochs = 1500, minibatch_size = 32, print_cost = True):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    创建一个三层的TensorFlow神经网络: LINEAR-&gt;RELU-&gt;LINEAR-&gt;RELU-&gt;LINEAR-&gt;SOFTMAX.</span><br><span class="line">    </span><br><span class="line">    Arguments:</span><br><span class="line">    X_train -- 训练集，形状为： (输入特征 = 12288, 训练样本数 = 1080)</span><br><span class="line">    Y_train -- 训练集的标签，形状为 (输出标签 = 6, 训练样本数  = 1080)</span><br><span class="line">    X_test -- 测试集，形状为 (输入特征 = 12288, 测试样本数 =  120)</span><br><span class="line">    Y_test -- 测试集的标签，形状为 (输出标签 = 6, 测试样本数  =  120)</span><br><span class="line">    learning_rate -- 学习率</span><br><span class="line">    num_epochs -- 迭代次数</span><br><span class="line">    minibatch_size -- 小批量的大小</span><br><span class="line">    print_cost -- 每迭代100次打印一次代价值</span><br><span class="line">    </span><br><span class="line">    Returns:</span><br><span class="line">    parameters -- 模型学习得到的参数，可以直接用于预测。</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    </span><br><span class="line">    ops.reset_default_graph()                         </span><br><span class="line">    tf.set_random_seed(1)                             # 便于产生相同的输出</span><br><span class="line">    seed = 3                                          # 便于产生相同的输出</span><br><span class="line">    (n_x, m) = X_train.shape                          # (n_x: 输入样本特征, m : 训练集样本数)</span><br><span class="line">    n_y = Y_train.shape[0]                            # n_y : 输出标签数</span><br><span class="line">    costs = []                                        # 记录cost</span><br><span class="line">    </span><br><span class="line">    # 创建形状为 (n_x, n_y)的placeholder</span><br><span class="line">    ### 填写代码 ###   </span><br><span class="line">    X, Y = None</span><br><span class="line">    ### 完成代码 ###   </span><br><span class="line"></span><br><span class="line">    # 初始化参数</span><br><span class="line">    ### 填写代码 ###   </span><br><span class="line">    parameters = None</span><br><span class="line">    ### 完成代码 ###   </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    # 前向传播: 创建前向传播计算图</span><br><span class="line">    ### 填写代码 ###   </span><br><span class="line">    Z3 = None</span><br><span class="line">    ### 完成代码 ###   </span><br><span class="line">    </span><br><span class="line">    # 代价函数: 在计算图中增加代价函数</span><br><span class="line">    ### 填写代码 ###   </span><br><span class="line">    cost = None</span><br><span class="line">    ### 完成代码 ###   </span><br><span class="line">    </span><br><span class="line">    # 反向传播: 使用 AdamOptimizer优化代价函数。</span><br><span class="line">    ### 填写代码 ###   </span><br><span class="line">    optimizer = None</span><br><span class="line">    ### 完成代码 ###   </span><br><span class="line">    </span><br><span class="line">    # 初始化所有变量</span><br><span class="line">    init = tf.global_variables_initializer()</span><br><span class="line"></span><br><span class="line">    # 运行session计算TensorFlow图</span><br><span class="line">    with tf.Session() as sess:</span><br><span class="line">        </span><br><span class="line">        # 运行初始化</span><br><span class="line">        sess.run(init)</span><br><span class="line">        </span><br><span class="line">        # 循环训练</span><br><span class="line">        for epoch in range(num_epochs):</span><br><span class="line"></span><br><span class="line">            epoch_cost = 0.                       # 定义每次迭代的代价函数</span><br><span class="line">            num_minibatches = int(m / minibatch_size) # 训练集选择的小批量的大小</span><br><span class="line">            seed = seed + 1</span><br><span class="line">            minibatches = random_mini_batches(X_train, Y_train, minibatch_size, seed)</span><br><span class="line"></span><br><span class="line">            for minibatch in minibatches:</span><br><span class="line"></span><br><span class="line">                # 选择一个批量</span><br><span class="line">                (minibatch_X, minibatch_Y) = minibatch</span><br><span class="line">                </span><br><span class="line">                # 运行session执行 &quot;optimizer&quot;最小化 &quot;cost&quot;</span><br><span class="line">                ### 填写代码 ### </span><br><span class="line">                _ , minibatch_cost = None</span><br><span class="line">                ### 完成代码 ### </span><br><span class="line">                </span><br><span class="line">                epoch_cost += minibatch_cost / num_minibatches</span><br><span class="line"></span><br><span class="line">            # 每100次迭代输出一次代价值</span><br><span class="line">            if print_cost == True and epoch % 100 == 0:</span><br><span class="line">                print (&quot;Cost after epoch %i: %f&quot; % (epoch, epoch_cost))</span><br><span class="line">            if print_cost == True and epoch % 5 == 0:</span><br><span class="line">                costs.append(epoch_cost)</span><br><span class="line">                </span><br><span class="line">        # 画出代价值随迭代次数变化的图</span><br><span class="line">        plt.plot(np.squeeze(costs))</span><br><span class="line">        plt.ylabel(&apos;cost&apos;)</span><br><span class="line">        plt.xlabel(&apos;iterations (per tens)&apos;)</span><br><span class="line">        plt.title(&quot;Learning rate =&quot; + str(learning_rate))</span><br><span class="line">        plt.show()</span><br><span class="line"></span><br><span class="line">        # 存储参数变量</span><br><span class="line">        parameters = sess.run(parameters)</span><br><span class="line">        print (&quot;Parameters have been trained!&quot;)</span><br><span class="line"></span><br><span class="line">        # 计算正确率</span><br><span class="line">        correct_prediction = tf.equal(tf.argmax(Z3), tf.argmax(Y))</span><br><span class="line"></span><br><span class="line">        # 计算测试集的正确率</span><br><span class="line">        accuracy = tf.reduce_mean(tf.cast(correct_prediction, &quot;float&quot;))</span><br><span class="line"></span><br><span class="line">        print (&quot;Train Accuracy:&quot;, accuracy.eval(&#123;X: X_train, Y: Y_train&#125;))</span><br><span class="line">        print (&quot;Test Accuracy:&quot;, accuracy.eval(&#123;X: X_test, Y: Y_test&#125;))</span><br><span class="line">        </span><br><span class="line">        return parameters</span><br></pre></td></tr></table></figure></p><p>测试代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">parameters = model(X_train, Y_train, X_test, Y_test)</span><br></pre></td></tr></table></figure></p><p>代码运行结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Train Accuracy: 0.999074</span><br><span class="line">Test Accuracy: 0.725</span><br></pre></td></tr></table></figure></p><ul><li>模型看起来可以很好地训练数据集，但是，由于训练集和测试集的准确率之间差异过大，可以尝试添加L2或Dropout正则化来减少过拟合。</li><li>将Session看作是一个训练模型的代码块，每次都在小批量的训练数据上运行会话训练参数。训练过1500次之后可以得到很好的参数。</li></ul><h3 id="测试自己的图片"><a href="#测试自己的图片" class="headerlink" title="测试自己的图片"></a>测试自己的图片</h3><p>将自己想要测试的图片添加到“images”文件夹中，再运行下列代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import scipy</span><br><span class="line">from PIL import Image</span><br><span class="line">from scipy import ndimage</span><br><span class="line"></span><br><span class="line">### 填写代码 ### (PUT YOUR IMAGE NAME) </span><br><span class="line">my_image = &quot;thumbs_up.jpg&quot;</span><br><span class="line">### 完成代码 ### </span><br><span class="line"></span><br><span class="line">fname = &quot;images/&quot; + my_image</span><br><span class="line">image = np.array(ndimage.imread(fname, flatten=False))</span><br><span class="line">my_image = scipy.misc.imresize(image, size=(64,64)).reshape((1, 64*64*3)).T</span><br><span class="line">my_image_prediction = predict(my_image, parameters)</span><br><span class="line"></span><br><span class="line">plt.imshow(image)</span><br><span class="line">print(&quot;Your algorithm predicts: y = &quot; + str(np.squeeze(my_image_prediction)))</span><br></pre></td></tr></table></figure></p><p>总结：</p><ul><li><p>TensorFlow是用于深度学习的编程框架</p></li><li><p>TensorFlow中的两个主要对象类是张量和操作符。</p></li><li><p>在TensorFlow中编码时，必须采取以下步骤：</p><ul><li>创建一个包含张量（变量，占位符…）和操作（tf.matmul，tf.add，…）的图形</li><li>创建一个会话</li><li>初始化会话</li><li>运行会话以执行图形</li></ul></li><li><p>可以多次执行计算图，如本实验中的model()</p></li><li>在“优化器”对象上运行会话时，会自动完成反向传播和优化</li></ul>]]></content>
      
      <categories>
          
          <category> Framework </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tensorflow </tag>
            
            <tag> 入门教程 </tag>
            
            <tag> CNN </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TensorFlow基础实验一</title>
      <link href="/2018/12/06/tensorflow/1.1TensorFlow_basic_exercise_one/"/>
      <url>/2018/12/06/tensorflow/1.1TensorFlow_basic_exercise_one/</url>
      <content type="html"><![CDATA[<h1 id="TensorFlow基础实验一"><a href="#TensorFlow基础实验一" class="headerlink" title=" TensorFlow基础实验一"></a><font color="blue"> TensorFlow基础实验一</font></h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>通过学习TensorFlow基础入门，掌握TensorFlow的基本使用方法。在此次实验中，你需要掌握这些技巧：</p><ul><li>初始化变量</li><li>创建会话</li><li>训练算法</li><li>搭建一个神经网络</li></ul><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><h3 id="TensorFlow-Library"><a href="#TensorFlow-Library" class="headerlink" title="TensorFlow Library"></a>TensorFlow Library</h3><p>为了使用TensorFlow，首先需要引入TensorFlow库。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import math</span><br><span class="line">import numpy as np</span><br><span class="line">import h5py</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import tensorflow as tf</span><br><span class="line">from tensorflow.python.framework import ops</span><br><span class="line"></span><br><span class="line">np.random.seed(1)</span><br></pre></td></tr></table></figure></p><p>引入相应所需的库之后，可以使用TensorFlow实现不同的应用。首先从一个简单的例子开始，计算训练数据的损失。<br>$loss = \mathcal{L}(\hat{y}, y) = (\hat y^{(i)} - y^{(i)})^2 \tag{1} $</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">y_hat = tf.constant(36, name=&apos;y_hat&apos;)            # 定义 y_hat为常量，设置其值为36</span><br><span class="line">y = tf.constant(39, name=&apos;y&apos;)                    # 定义 y为常量，设置其值为39</span><br><span class="line"></span><br><span class="line">loss = tf.Variable((y - y_hat)**2, name=&apos;loss&apos;)  # 定义损失函数为变量</span><br><span class="line"></span><br><span class="line">init = tf.global_variables_initializer()         # 初始化，在后面用到 (session.run(init))</span><br><span class="line">                                                 # 损失函数将会被初始化并加入计算图中</span><br><span class="line">with tf.Session() as session:                    # 创建session输出结果</span><br><span class="line">    session.run(init)                            # 初始化变量</span><br><span class="line">    print(session.run(loss))                     # 输出损失</span><br></pre></td></tr></table></figure><p>此段代码运行结果为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure></p><p>在TensorFlow中执行程序的一般步骤为：</p><ol><li>创建还未被执行的张量</li><li>写出张量之间的操作，如表达式</li><li>初始化张量</li><li>创建会话（Session）</li><li>运行会话，这时会运行之前写好的操作</li></ol><p>因此，当我们为损失创建一个变量时，我们简单地将损失定义为其他数量的函数，但没有计算它的值。为了计算它，我们必须运行init = tf.global_variables_initializer（）。初始化损失变量，并在最后一行中，我们终于能够计算损失的价并打印其值。</p><h4 id="session"><a href="#session" class="headerlink" title="session"></a>session</h4><p>再来看一个简单的例子。试运行下列代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = tf.constant(2)</span><br><span class="line">b = tf.constant(10)</span><br><span class="line">c = tf.multiply(a,b)</span><br><span class="line">print(c)</span><br></pre></td></tr></table></figure></p><p>此段代码运行结果为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Tensor(&quot;Mul:0&quot;, shape=(), dtype=int32)</span><br></pre></td></tr></table></figure></p><p>这里并没有输出20，输出结果为一个张量，没有shape属性，且类型为“ini32”。当前你的操作只是将其放置在“计算图”中，并没有运行这个计算。为了能实际的进行运算，需要创建一个会话运行它。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sess = tf.Session()</span><br><span class="line">print(sess.run(c))</span><br></pre></td></tr></table></figure></p><p>此段代码运行结果为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">20</span><br></pre></td></tr></table></figure></p><p>总结：记得初始化你的变量，创建一个会话并在会话中运行这些操作。</p><h4 id="placeholder"><a href="#placeholder" class="headerlink" title="placeholder"></a>placeholder</h4><p>接下来，需要了解placeholders。placeholder是一个对象，其值只能在稍后指定。要指定占placeholder的值，可以使用“feed字典”（feed_dict变量）传入值。下面，我们为x创建了一个placeholder。这允许我们稍后在运行会话时传入一个数字。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x = tf.placeholder(tf.int64, name = &apos;x&apos;)</span><br><span class="line">print(sess.run(2 * x, feed_dict = &#123;x: 3&#125;))</span><br><span class="line">sess.close()</span><br></pre></td></tr></table></figure></p><p>此段代码运行结果为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure></p><p>当第一次定义x时，不必为它指定一个值。placeholder只是一个变量，您将在稍后运行会话时将数据分配给该变量。在运行会话时向这些placeholder提供数据。当指定计算所需的操作时，告诉TensorFlow如何构建计算图。计算图可以有一些placeholder，其值将在稍后指定。最后，当你运行会话时，告诉TensorFlow执行计算图。</p><h3 id="线性函数"><a href="#线性函数" class="headerlink" title="线性函数"></a>线性函数</h3><p>首先从简单的线性函数开始，计算这个等式：$Y = WX+b$，其中$W$和$X$都是随机取值的矩阵，$b$是一个数值随机的向量。<br>练习：计算$WX+b$，其中$W$、$X$和$b$取值于随机正态分布。$W$是4×3的矩阵，$X$是3×1的矩阵，$b$为4×1的向量。作为例子，给出定义一个3×1的常量矩阵$X$：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X = tf.constant(np.random.randn(3,1), name = &quot;X&quot;)</span><br></pre></td></tr></table></figure></p><p>你可以使用这些函数：</p><ul><li>tf.matmul(…, …) 矩阵乘法</li><li>tf.add(…, …) 矩阵加法</li><li>np.random.randn(…) 随机初始化<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># GRADED FUNCTION: linear_function</span><br><span class="line"></span><br><span class="line">def linear_function():</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    定义线性函数: </span><br><span class="line">            初始化W为一个4×3的随机张量</span><br><span class="line">            初始化X为一个3×1的随机张量</span><br><span class="line">            初始化b为一个4×1的随机张量</span><br><span class="line">    返回值: </span><br><span class="line">    result -- Y = WX + b </span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    </span><br><span class="line">    np.random.seed(1)</span><br><span class="line">    </span><br><span class="line">    ### 填写代码 ###</span><br><span class="line">    X = None</span><br><span class="line">    W = None</span><br><span class="line">    b = None</span><br><span class="line">    Y = None</span><br><span class="line">    ### 完成代码 ### </span><br><span class="line">    </span><br><span class="line">    # tf.Session()创建会话，使用sess.run(...)计算变量</span><br><span class="line">    </span><br><span class="line">    ### 填写代码 ###</span><br><span class="line">    sess = None</span><br><span class="line">    result = None</span><br><span class="line">    ### 完成代码 ### </span><br><span class="line">    </span><br><span class="line">    # 关闭session </span><br><span class="line">    sess.close()</span><br><span class="line"></span><br><span class="line">    return result</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print( &quot;result = &quot; + str(linear_function()))</span><br></pre></td></tr></table></figure><p>此段代码运行结果为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">result[[-2.15657382] [ 2.95891446] [-1.08926781] [-0.84538042]]</span><br></pre></td></tr></table></figure></p><h3 id="sigmoid函数"><a href="#sigmoid函数" class="headerlink" title="sigmoid函数"></a>sigmoid函数</h3><p>Tensorflow提供了各种常用的神经网络功能，如tf.sigmoid和tf.softmax。 对于这个练习，我们计算输入的S形函数。<br>使用placeholder变量x执行此练习。 运行会话时，应该使用feed字典传入输入z。 在本练习中，需要（i）创建占位符x，（ii）使用tf.sigmoid定义计算sigmoid所需的操作，然后（iii）运行会话。<br>练习：创建sigmoid函数，需要用到下面的函数：</p><ul><li>tf.placeholder(tf.float32, name = “…”)</li><li>tf.sigmoid(…)</li><li>sess.run(…, feed_dict = {x: z})<br>注意：有两种方法创建session<br>方法1：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sess = tf.Session()</span><br><span class="line"># 运行变量初始化及相应运算操作</span><br><span class="line">result = sess.run(..., feed_dict = &#123;...&#125;)</span><br><span class="line">sess.close() # 关闭session</span><br></pre></td></tr></table></figure></li></ul><p>方法2：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with tf.Session() as sess: </span><br><span class="line">    # 运行变量初始化及相应运算操作</span><br><span class="line">    result = sess.run(..., feed_dict = &#123;...&#125;)</span><br><span class="line">    # 此方法可以自动关闭session</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># GRADED FUNCTION: sigmoid</span><br><span class="line"></span><br><span class="line">def sigmoid(z):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    计算z的sigmoid值</span><br><span class="line">    </span><br><span class="line">    Arguments:</span><br><span class="line">    z -- 输入，可以为具体的数值或向量</span><br><span class="line">    </span><br><span class="line">    Returns: </span><br><span class="line">    results -- z的sigmoid值</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    </span><br><span class="line">    ### 填写代码 ### ( approx. 4 lines of code)</span><br><span class="line">    # 为创建一个placeholder为其命名为&apos;x&apos;.</span><br><span class="line">    x = None</span><br><span class="line"></span><br><span class="line">    # 计算sigmoid(x)</span><br><span class="line">    sigmoid = None</span><br><span class="line"></span><br><span class="line">    # 创建session并运行 </span><br><span class="line">    # 使用feed_dict将z的值传递给x </span><br><span class="line">    None</span><br><span class="line">        # 运行session</span><br><span class="line">        result = None</span><br><span class="line">    </span><br><span class="line">    ### 完成代码 ###</span><br><span class="line">    </span><br><span class="line">    return result</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print (&quot;sigmoid(0) = &quot; + str(sigmoid(0)))</span><br><span class="line">print (&quot;sigmoid(12) = &quot; + str(sigmoid(12)))</span><br></pre></td></tr></table></figure><p>此段代码运行结果为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sigmoid(0) = 0.5</span><br><span class="line">sigmoid(12) = 0.999994</span><br></pre></td></tr></table></figure></p><p>总结：需要掌握</p><ol><li>创建placeholder</li><li>指定要计算的操作所对应的计算图</li><li>创建会话</li><li>运行会话，必要时使用feed_dict来指定placeholder变量的值</li></ol><h3 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h3><p>在TensorFlow中可以使用内置函数来计算神经网络的代价函数值。不需要编写公式来实现代价函数。<br>$J = - \frac{1}{m}  \sum_{i = 1}^m  \large ( \small y^{(i)} \log a^{ [2] (i)} + (1-y^{(i)})\log (1-a^{ [2] (i)} )\large )\small\tag{2}$<br>在TensorFlow中仅需一行代码便可以实现上述功能。</p><p>练习：引入交叉熵损失，需要用到下面的函数：</p><ul><li>tf.nn.sigmoid_cross_entropy_with_logits(logits = …,  labels = …)</li></ul><p>代码应输入z，计算sigmoid，得到a值，然后计算交叉熵损失J。所有的操作都可以通过调用一次tf.nn.sigmoid_cross_entropy_with_logits完成，其计算过程为：<br>$- \frac{1}{m}  \sum_{i = 1}^m  \large ( \small y^{(i)} \log \sigma(z^{<a href="i">2</a>}) + (1-y^{(i)})\log (1-\sigma(z^{<a href="i">2</a>})\large )\small\tag{3}$</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># GRADED FUNCTION: cost</span><br><span class="line"></span><br><span class="line">def cost(logits, labels):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    使用交叉熵作为损失函数，并计算其值</span><br><span class="line">    </span><br><span class="line">    Arguments:</span><br><span class="line">    logits -- 包含z的矢量，最后一个线性单元的输出（在最终的sigmoid激活之前）</span><br><span class="line">    labels -- vector of labels y (1 or 0) </span><br><span class="line">    </span><br><span class="line">  Notes：在这里“z”和“y”分别为“logits”和“labels”，在在TensorFlow文档中，logits将输入到z中，并标记为y。</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    Returns:</span><br><span class="line">    cost -- 运行session计算得出的cost</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    </span><br><span class="line">    ### 填写代码 ### </span><br><span class="line">    </span><br><span class="line">    # 为z和y创建placeholder</span><br><span class="line">    z = None</span><br><span class="line">    y = None</span><br><span class="line">    </span><br><span class="line">    # 计算损失函数</span><br><span class="line">    cost = None</span><br><span class="line">    </span><br><span class="line">    # 采用第一种方法创建session</span><br><span class="line">    sess = None</span><br><span class="line">    </span><br><span class="line">    # 运行session</span><br><span class="line">    cost = None</span><br><span class="line">    </span><br><span class="line">    # 采用第一种方法关闭session</span><br><span class="line">    None</span><br><span class="line">    </span><br><span class="line">    ### 完成代码 ###</span><br><span class="line">    </span><br><span class="line">    return cost</span><br></pre></td></tr></table></figure><h3 id="使用one-hot编码"><a href="#使用one-hot编码" class="headerlink" title="使用one hot编码"></a>使用one hot编码</h3><p>经过多次深度学习之后，得到的y向量会有C个值，且C是累=类的数量。如果C为4，那么可能得到以下的y向量，需要按照以下方式转换：</p><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/tensorflow/78291355.jpg" width="75%/"><br></center><p>这被称为“独热”编码，因为在转换的表示中，每列的一个元素恰恰是“热”（意思是设置为1）。要在numpy中进行这种转换，可能需要编写几行代码。在TensorFlow中，可以使用一行代码：</p><ul><li>tf.one_hot(labels, depth, axis)</li></ul><p>练习：执行下面的函数，取一个标签向量和CC类总数，返回一个热独编码。使用tf.one_hot（）来做到这一点。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># GRADED FUNCTION: one_hot_matrix</span><br><span class="line"></span><br><span class="line">def one_hot_matrix(labels, C):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    创建一个矩阵，其中第i行对应于第i个类，第j列对应于第j个训练样例。所以，如果例子j有一个标签i，则输入（i，j）的值为1。</span><br><span class="line">                     </span><br><span class="line">    Arguments:</span><br><span class="line">    labels -- 包含标签的向量</span><br><span class="line">    C -- 类别的数量，one-hot编码的维度</span><br><span class="line">    </span><br><span class="line">    Returns: </span><br><span class="line">    one_hot -- one hot矩阵</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    </span><br><span class="line">    ### 填写代码 ###</span><br><span class="line">    </span><br><span class="line">    # Create a tf.constant equal to C (depth), name it &apos;C&apos;. (approx. 1 line)</span><br><span class="line">    C = None</span><br><span class="line">    </span><br><span class="line">    # Use tf.one_hot, be careful with the axis (approx. 1 line)</span><br><span class="line">    one_hot_matrix = None</span><br><span class="line">    </span><br><span class="line">    # Create the session (approx. 1 line)</span><br><span class="line">    sess = None</span><br><span class="line">    </span><br><span class="line">    # Run the session (approx. 1 line)</span><br><span class="line">    one_hot = None</span><br><span class="line">    </span><br><span class="line">    # Close the session (approx. 1 line). See method 1 above.</span><br><span class="line">    None</span><br><span class="line">    </span><br><span class="line">    ### 完成代码 ###</span><br><span class="line">    </span><br><span class="line">    return one_hot</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">labels = np.array([1,2,3,0,2,1])</span><br><span class="line">one_hot = one_hot_matrix(labels, C = 4)</span><br><span class="line">print (&quot;one_hot = &quot; + str(one_hot))</span><br></pre></td></tr></table></figure><p>此段代码运行结果为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">one_hot = [[ 0.  0.  0.  1.  0.  0.]</span><br><span class="line"> [ 1.  0.  0.  0.  0.  1.]</span><br><span class="line"> [ 0.  1.  0.  0.  1.  0.]</span><br><span class="line"> [ 0.  0.  1.  0.  0.  0.]]</span><br></pre></td></tr></table></figure></p><h3 id="使用0和1初始化"><a href="#使用0和1初始化" class="headerlink" title="使用0和1初始化"></a>使用0和1初始化</h3><p>现在学习如何初始化一个零和一个向量。需要调用的函数是tf.ones（）。要用零初始化，可以使用tf.zeros（）来代替。这些函数输入一个形状，并分别返回一个同样形状其元素值为0和1的数组。</p><p>练习：实现下面的函数来获取形状并返回一个数组（形状的维数）。</p><ul><li>tf.ones(shape)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># GRADED FUNCTION: ones</span><br><span class="line"></span><br><span class="line">def ones(shape):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    创建一个值全为1的数组</span><br><span class="line">    </span><br><span class="line">    Arguments:</span><br><span class="line">    shape -- 数组的形状</span><br><span class="line">        </span><br><span class="line">    Returns: </span><br><span class="line">    ones -- 数组元素仅为1</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    </span><br><span class="line">    ### 填写代码 ###</span><br><span class="line">    </span><br><span class="line">    # 用tf.ones(...)创建“ones”</span><br><span class="line">    ones = None</span><br><span class="line">    </span><br><span class="line">    # 创建session </span><br><span class="line">    sess = None</span><br><span class="line">    </span><br><span class="line">    # 运行session计算ones</span><br><span class="line">    ones = None</span><br><span class="line">    </span><br><span class="line">    # 关闭session</span><br><span class="line">    None</span><br><span class="line">    </span><br><span class="line">    ### 完成代码 ###</span><br><span class="line">    return ones</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print (&quot;ones = &quot; + str(ones([3])))</span><br></pre></td></tr></table></figure><p>此段代码运行结果为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ones = [ 1.  1.  1.]</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> Framework </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tensorflow </tag>
            
            <tag> 入门教程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TensorFlow基础入门</title>
      <link href="/2018/12/06/tensorflow/1.TensorFlow%E5%85%A5%E9%97%A8/"/>
      <url>/2018/12/06/tensorflow/1.TensorFlow%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<h1 id="TensorFlow基础入门"><a href="#TensorFlow基础入门" class="headerlink" title="TensorFlow基础入门"></a><font color="blue">TensorFlow基础入门</font></h1><h2 id="TensorFlow简介"><a href="#TensorFlow简介" class="headerlink" title="TensorFlow简介"></a>TensorFlow简介</h2><p>&emsp;&emsp; TensorFlow是一个采用数据流图（data flow graphs），用于数值计算的开源软件库。最初由Google大脑小组（隶属于Google机器智能研究机构）的研究员和工程师们开发出来，用于机器学习和深度神经网络方面的研究，但这个系统的通用性使其也可广泛用于其他计算领域。<br><br>&emsp;&emsp;TensorFlow既是一个实现机器学习算法的接口，同时也是执行机器学习速算法的框架。它前端支持Python、C++、Go、Java等多种开发语言，后端使用C++、CUDA等写成，其实现的算法可以在众多异构系统移植，如CPU，GPU集群，iOS，Android等。<br></p><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/tensorflow/20181206185930.png" width="20%"><br></center><p>&emsp;&emsp;TensorFlow中的计算可以表示为一个有向图（directed graph），或计算图（computation graph），其中每一个运算操作将作为一个节点，称之为op（operation缩写），节点与节点之间的连接称为边（edge）。在计算图的边中流动（flow）的数据被称&gt;为张量（tensor），因此得名为TensorFlow。每个张量是一个类型化的多维数组。例如,可以将一小组图像集表示为一个四维浮点数数组,这四个维度分别是[batch, height, width, channels]。<br>                                                                                                                             </p><h2 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h2><p>&emsp;&emsp;一个TensorFlow图描述了计算的过程。为了进行计算，图必须在会话里被启动。会话将图的op分发到诸如CPU或GPU之类的设备上，同时提供执行op的方法。这些方法执行后，将产生的tensor返回。在Python语言中，返回的tensor是numpy ndarray对象。<br>                                                                                 </p><h3 id="计算图"><a href="#计算图" class="headerlink" title="计算图"></a>计算图</h3><p>&emsp;&emsp;TensorFlow程序通常被组织成一个构建阶段和一个执行阶段。在构建阶段，op的执行步骤被描述成一个图。在执行阶段，使用会话执行执行图中的op。例如，通常在构建阶段创建一个图来表示和训练神经网络，然后在执行阶段反复执行图中的训练op。<br></p><h4 id="构建图"><a href="#构建图" class="headerlink" title="构建图"></a>构建图</h4><p>&emsp;&emsp;构建图的第一步，是创建源op(source op)。源op不需要任何输入，例如常量(Constant)。源op的输出被传递给其它op做运算。Python库中，op构造器的返回值代表被构造出的op的输出，这些返回值可以传递给其它op构造器作为输入。TensorFlow Python库有一个默认图(default graph)，op构造器可以为其增加节点。这个默认图对许多程序来说已经足够用了。<br><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import tensorflow as tf                                                          </span><br><span class="line">                                                                                 </span><br><span class="line"># 创建一个常量op，产生一个1x2矩阵。这个op被作为一个节点                          </span><br><span class="line"># 加到默认图中.                                                                  </span><br><span class="line">#                                                                                </span><br><span class="line"># 构造器的返回值代表该常量op的返回值.                                            </span><br><span class="line">matrix1 = tf.constant([[3., 3.]])                                                </span><br><span class="line">                                                                                 </span><br><span class="line"># 创建另外一个常量op,产生一个2x1矩阵.                                            </span><br><span class="line">matrix2 = tf.constant([[2.],[2.]])                                               </span><br><span class="line">                                                                                 </span><br><span class="line"># 创建一个矩阵乘法 matmul op，把&apos;matrix1&apos;和&apos;matrix2&apos;作为输入。                   </span><br><span class="line"># 返回值&apos;product&apos;代表矩阵乘法的结果.                                             </span><br><span class="line">product = tf.matmul(matrix1, matrix2)</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;默认图现在有三个节点，两个constant() op，和一个matmul() op。为了真正进行矩阵相乘运算，并得到矩阵乘法的结果，必须在会话里启动这个图。<br>                                                                          </p><h4 id="启动图"><a href="#启动图" class="headerlink" title="启动图"></a>启动图</h4><p>&emsp;&emsp;构造阶段完成后，才能启动图。启动图的第一步是创建一个Session对象，如果无任何创建参数，会话构造器将启动默认图。<br><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 启动默认图.                                                                    </span><br><span class="line">sess = tf.Session()                                                              </span><br><span class="line">                                                                                 </span><br><span class="line"># 调用 sess 的 &apos;run()&apos; 方法来执行矩阵乘法 op, 传入 &apos;product&apos; 作为该方法的参数.   </span><br><span class="line"># 上面提到, &apos;product&apos; 代表了矩阵乘法 op 的输出, 传入它是向方法表明, 我们希望取回 </span><br><span class="line"># 矩阵乘法 op 的输出.                                                            </span><br><span class="line">#                                                                                </span><br><span class="line"># 整个执行过程是自动化的, 会话负责传递 op 所需的全部输入. op 通常是并发执行的.   </span><br><span class="line">#                                                                                </span><br><span class="line"># 函数调用 &apos;run(product)&apos; 触发了图中三个 op (两个常量 op 和一个矩阵乘法 op) 的执行.</span><br><span class="line">#                                                                                </span><br><span class="line"># 返回值 &apos;result&apos; 是一个 numpy `ndarray` 对象.                                   </span><br><span class="line">result = sess.run(product)                                                       </span><br><span class="line">print result                                                                     </span><br><span class="line"># ==&gt; [[ 12.]]                                                                   </span><br><span class="line">                                                                                 </span><br><span class="line"># 任务完成, 关闭会话.                                                            </span><br><span class="line">sess.close()</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;Session对象在使用完后需要关闭以释放资源。除了显式调用close外，也可以使用“with”代码块来自动完成关闭动作。<br><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with tf.Session() as sess:                                                       </span><br><span class="line">result = sess.run([product])                                                     </span><br><span class="line">print result</span><br></pre></td></tr></table></figure></p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>&emsp;&emsp;变量维护图执行过程中的状态信息。下面的例子演示了如何使用变量实现一个简单的计数器。<br><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建一个变量, 初始化为标量 0.                                                  </span><br><span class="line">state = tf.Variable(0, name=&quot;counter&quot;)                                           </span><br><span class="line"># 创建一个 op, 其作用是使 state 增加 1     </span><br><span class="line">                                                                                 </span><br><span class="line">one = tf.constant(1)                                                             </span><br><span class="line">new_value = tf.add(state, one)                                                   </span><br><span class="line">update = tf.assign(state, new_value)                                             </span><br><span class="line">                                                                                 </span><br><span class="line"># 启动图后, 变量必须先经过`初始化` (init) op 初始化,                             </span><br><span class="line"># 首先必须增加一个`初始化` op 到图中.                                            </span><br><span class="line">init_op = tf.initialize_all_variables()                                          </span><br><span class="line">                                                                                 </span><br><span class="line"># 启动图, 运行 op                                                                </span><br><span class="line">with tf.Session() as sess:                                                       </span><br><span class="line">  # 运行 &apos;init&apos; op                                                               </span><br><span class="line">  sess.run(init_op)                                                              </span><br><span class="line">  # 打印 &apos;state&apos; 的初始值                                                        </span><br><span class="line">  print sess.run(state)                                                          </span><br><span class="line">  # 运行 op, 更新 &apos;state&apos;, 并打印 &apos;state&apos;                                        </span><br><span class="line">  for _ in range(3):                                                             </span><br><span class="line">    sess.run(update)                                                             </span><br><span class="line">    print sess.run(state)                                                        </span><br><span class="line">                                                                                 </span><br><span class="line"># 输出:                                                                          </span><br><span class="line">                                                                                 </span><br><span class="line"># 0                                                                              </span><br><span class="line"># 1                                                                              </span><br><span class="line"># 2                                                                              </span><br><span class="line"># 3</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;代码中assign()操作是图所描绘的表达式的一部分，正如add()操作一样。所以在调用run()执行表达式之前，它并不会真正执行赋值操作。<br><br>&emsp;&emsp;通常会将一个统计模型中的参数表示为一组变量。例如，可以将一个神经网络的权重作为某个变量存储在一个tensor中。在训练过程中，通过重复运行训练图，更新这个tensor。<br></p><h3 id="Fetch"><a href="#Fetch" class="headerlink" title="Fetch"></a>Fetch</h3><p>&emsp;&emsp;为了取回操作的输出内容，可以在使用Session对象的run()。调用执行图时，传入一些tensor，这些tensor会帮助你取回结果。在之前的例子里，只取回了单个节点state，但是也可以取回多个tensor:<br><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input1 = tf.constant(3.0)                                                        </span><br><span class="line">input2 = tf.constant(2.0)          </span><br><span class="line">intermed = tf.add(input2, input3)                                                </span><br><span class="line">mul = tf.mul(input1, intermed)                                                   </span><br><span class="line">                                                                                 </span><br><span class="line">with tf.Session():                                                               </span><br><span class="line">  result = sess.run([mul, intermed])                                             </span><br><span class="line">  print result                                                                   </span><br><span class="line">                                                                                 </span><br><span class="line"># 输出:                                                                          </span><br><span class="line"># [array([ 21.], dtype=float32), array([ 7.], dtype=float32)]</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;需要获取的多个tensor值，在op的一次运行中一起获得（而不是逐个去获取tensor）。<br></p><h3 id="Feed"><a href="#Feed" class="headerlink" title="Feed"></a>Feed</h3><p>&emsp;&emsp;上述示例在计算图中引入了tensor，以常量或变量的形式存储。TensorFlow还提供了feed机制，该机制可以临时替代图中的任意操作中的tensor可以对图中任何操作提交补丁，直接插入一个tensor。<br><br>&emsp;    feed使用一个tensor值临时替换一个操作的输出结果。可以提供feed数据作为<code>run()</code>调用的参数。feed只在调用它的方法内有效，方法结束，feed就会消失。最常见的用例是将某些特殊的操作指定为“feed”操作，标记的方法是使用<code>tf.placeholder()</code>为这些操作创建占位符。<br><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input1 = tf.placeholder(tf.types.float32)                                        </span><br><span class="line">input2 = tf.placeholder(tf.types.float32)                                        </span><br><span class="line">output = tf.mul(input1, input2)                                                  </span><br><span class="line">                                                                                 </span><br><span class="line">with tf.Session() as sess:                                                       </span><br><span class="line">  print sess.run([output], feed_dict=&#123;input1:[7.], input2:[2.]&#125;)                 </span><br><span class="line">                                                                                 </span><br><span class="line"># 输出:                                                                          </span><br><span class="line"># [array([ 14.], dtype=float32)]</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;如果没有正确提供feed，<code>placeholder()</code>操作将会产生错误。  <br> </p>]]></content>
      
      <categories>
          
          <category> Framework </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tensorflow </tag>
            
            <tag> 入门教程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>传统图像特征点提取算法</title>
      <link href="/2018/12/05/computer_version/tradition-surf/"/>
      <url>/2018/12/05/computer_version/tradition-surf/</url>
      <content type="html"><![CDATA[<h1 id="传统图像特征点提取算法"><a href="#传统图像特征点提取算法" class="headerlink" title="传统图像特征点提取算法"></a>传统图像特征点提取算法</h1><p>计算机视觉中，很大一部分研究集中在图像特征提取和特征生成算法上。对图像的优化，不同于一般数学问题的优化方法，图像的优化是对像素点，在某一个小的邻域内，进行特征的提取或者图像的分析，该优化主要是进行局部区域的优化，要寻找<strong>局部极值</strong>，而不像传统的优化算法那样进行全局的优化求解。由于相同物体在不同状态下所产生的图像不同，使得不同图像具有不同亮度，不同旋转方向和不同尺度的差异。想要提取出具有代表性且性质鲁棒的特征点，一直是学术研究的焦点之一。</p><h2 id="SIFT与SURF的关系"><a href="#SIFT与SURF的关系" class="headerlink" title="SIFT与SURF的关系"></a>SIFT与SURF的关系</h2><p><strong>SIFT</strong>（Scale invariant feature Transform）算法是由David Lowe提出的<strong>尺度不变特征转换</strong>算法，其目标是解决低层次特征提取及其图像匹配中的实际问题。该算法是一种基于尺度空间，对图像缩放变换保持不变性的图像局部特征描述子。其主要分为三部分进行图像的特征点提取和描述。</p><p>SIFT算法优点：</p><ul><li>特征稳定，对旋转、尺度变换、亮度保持不变性</li><li>对视角变换、噪声也有一定程度的稳定性</li></ul><p>SIFT算法缺点：</p><ul><li>实时性不高</li><li>对于边缘光滑目标的特征点提取能力较弱，不够优化</li></ul><p>并且。因此，Bay于2006年提出了<strong>SURF</strong>（Speeded Up Robust Features）特征检测算法(发布于ECCV)。该算法具有较好的<strong>尺度不变性</strong>和<strong>旋转不变性</strong>，并且具有快速的计算能力，一直是图像拼接、图像检测和恢复等应用采用的主流算法之一。</p><p>SURF算法是对SIFT算法的加强版本，同时能够加速提取更加鲁棒的特征，是SIFT算子的速度的三倍以上，并且提取出的特征点更有代表性。同时也对描述子的生成以及特征点的匹配进行了优化。其主要采用了<strong>Harr特征</strong>以及<strong>积分图像</strong>，加快了程序搜索和运行的时间，优化了特征点提取的理论算法。</p><h2 id="SIFT算法"><a href="#SIFT算法" class="headerlink" title="SIFT算法"></a>SIFT算法</h2><p>Sift全称尺度不变特征变换，是1999年Lowe提出的，是一种基于尺度空间的，对图像缩放、旋转、甚至仿射变换保持不变性的图像局部特征描述算子。</p><p>SIFT算法流程：</p><ul><li>尺度空间局部极值点定位</li><li>关键点精确定位</li><li>关键点方向确定</li><li>生成特征向量</li></ul><h3 id="尺度空间局部极值点定位"><a href="#尺度空间局部极值点定位" class="headerlink" title="尺度空间局部极值点定位"></a>尺度空间局部极值点定位</h3><p>Sift的特征点是在DOG金字塔尺度空间中提取的，尺度空间的构建涉及到高斯卷积、图像下采样和高斯差分操作。在尺度空间中先初步提取出在尺度空间和二维图像空间上都是局部极值点的兴趣点，再滤除掉能量低的不稳定的和错误的兴趣点，得到最终稳定的特征点。</p><h4 id="尺度空间"><a href="#尺度空间" class="headerlink" title="尺度空间"></a>尺度空间</h4><p>特征点检测需要知道特征点的位置和尺度，因为真实世界中的物体只有在一定的尺度下才有意义，寻找的特征点需要找到连续的尺度空间下位置不发生变化的点。构建尺度空间的目的就是找到在尺度变化中具有不变性的位置，可以使用连续的尺度变化，即在尺度空间中所有可能的尺度变化中找到稳定的特征点，通过这种方式找到的极点可以保证在图像缩放和旋转变化中具有不变性。 </p><p>设$I(x,y)$为原始图像，$G(x,y, \sigma)$是尺度空间可变的高斯函数，则一个图像的尺度空间可以定义为：<br>$$<br>L(x,y,\sigma)=G(x,y,\sigma)∗I(x,y)<br>$$</p><ul><li>$\sigma$表示尺度空间大小。$\sigma$越大，图像越模糊，表示图像概貌；$\sigma$越小，图像越清晰，表示图像细节；</li></ul><p>其中高斯函数定义为：<br>$$<br>G(x,y,\sigma)=\frac{1}{2π\sigma^2}e^{− \frac{(x^2+y^2)}{2\sigma^2}}<br>$$<br>经过一系列的尺度空间变换和二倍的下采样，最终得到高斯金字塔。 </p><p>公式(1)中的图像$I(x,y)$具有无限的分辨率，也就是说他的尺度$σ=0$，即$I(x,y)=L(x,y,0)$。也就是说公式(1)得到的尺度空间图像$L(x,y,\sigma)$是由尺度尺度空间为0的图像$L(x,y,0)$生成的，但是现实生活中是不存在尺度空间为0，即具有无限分辨率的图像的。在Lowe的论文中，他们给定原图一个很小的尺度空间，为0.5。因此由一个小尺度空间图像$L(x,y,\sigma_1)$生成一个大的尺度空间图像$L(x,y,\sigma_2)​$的过程为:<br>$$<br>L(x,y,\sigma _2) = G(x,y,\sqrt{\sigma^2_2 − \sigma^2_1} )∗L(x,y,\sigma _1)<br>$$</p><p>由于实际中尺度为0的图像是无法得到的，因此我们得到的尺度图像的基准图像一定是由公式(3)得到的。</p><h4 id="高斯差分"><a href="#高斯差分" class="headerlink" title="高斯差分"></a>高斯差分</h4><p>为了在尺度空间中找到稳定不变的极值点，在SIFT算法中使用了高斯差分(DOG)函数$D(x,y,\sigma)$，定义为:<br>$$<br>\begin{align<em>}<br>D(x,y,\sigma) &amp;= [D(x,y,k\sigma) - D(x,y,\sigma)]</em>I(x,y)\<br>              &amp;= L(x,y, k\sigma) - L(x, y, \sigma)<br>\end{align*}<br>$$</p><p>其中$kσ$和$σ$是连续的两个图像的平滑尺度，所得到的差分图像在高斯差分金字塔中。 </p><p>选择高斯差分函数的原因：</p><ul><li>计算简单，因为$ L(x, y, \sigma)$可以由上一步计算得到，$D(x,y,\sigma)$只需要进行减法计算</li><li>LoG（Laplacian of Gaussian）高斯拉普拉斯算子，即图像的二阶导数，能够在不同的尺度下检测到图像的斑点特征，从而检测到图像中尺度变化下的位置不动点，但是LoG的运算效率不高</li><li>通过前人的实验证明LoG提取的特征稳定性最强</li></ul><p>而DoG是LoG的近似。DoG和LoG的关系如下述所示：</p><p>$$<br>\begin{align<em>}<br>\sigma \nabla ^2 G &amp;= \frac{\partial G}{\partial \sigma}\<br>&amp;\approx \frac{G(x,y,k\sigma)−G(x,y,\sigma)}{k\sigma−\sigma}<br>\end{align</em>}<br>$$</p><p>因此，有：<br>$$<br>G(x,y,k\sigma)−G(x,y,\sigma) \approx(k-1) \sigma ^2 \nabla ^2 G<br>$$<br>$\sigma ^2 \nabla ^2 G$正是尺度归一化算子的表达形式。在所有的尺度中$k−1$是一个常数，当$k$趋近于1的时候误差趋近于0，但实际上这种误差对于极值的位置检测并没有什么影响 。（==这里不是很懂==）</p><h4 id="高斯图像金字塔"><a href="#高斯图像金字塔" class="headerlink" title="高斯图像金字塔"></a>高斯图像金字塔</h4><p>高斯图像金子塔和差分金字塔如图所示：</p><div align="center"><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/computerVersion/94956855.jpg" width="90%"><br></div><h2 id="SURF算法过程"><a href="#SURF算法过程" class="headerlink" title="SURF算法过程"></a>SURF算法过程</h2><h3 id="构建积分图像"><a href="#构建积分图像" class="headerlink" title="构建积分图像"></a>构建积分图像</h3><p>在一个特征点$x=(x,y)$的领域上，计算其积分图像$I(x,y)$：<br>$$<br>I_{\Sigma }(x)=\sum_{i=0}^{i \leq x} \sum_{j=0}^{j \leq y}I(i,j)<br>$$</p>]]></content>
      
      <categories>
          
          <category> Computer Version </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 传统图像算法 </tag>
            
            <tag> 图像特征点提取 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>人脸关键点检测</title>
      <link href="/2018/11/08/computer_version/face-keypoint-detection/"/>
      <url>/2018/11/08/computer_version/face-keypoint-detection/</url>
      <content type="html"><![CDATA[<h1 id="人脸关键点检测"><a href="#人脸关键点检测" class="headerlink" title="人脸关键点检测"></a>人脸关键点检测</h1><p>关于人脸识别和表情分类的一些<a href="https://zhuanlan.zhihu.com/p/31638581" target="_blank" rel="noopener">论文</a></p><h2 id="人脸关键点检测介绍"><a href="#人脸关键点检测介绍" class="headerlink" title="人脸关键点检测介绍"></a>人脸关键点检测介绍</h2><p>人脸关键点检测也称为人脸关键点检测、定位或者人脸对齐，是指给定人脸图像，定位出人脸面部的关键区域位置，包括眉毛、眼睛、鼻子、嘴巴、脸部轮廓等。</p><p>关键点的集合称作形状(shape)，形状包含了关键点的位置信息，而这个位置信息一般可以用两种形式表示，第一种是关键点的位置相对于整张图像，第二种是关键点的位置相对于人脸框(标识出人脸在整个图像中的位置)。把第一种形状称作绝对形状，它的取值一般介于 $[0 \sim h]$或$[0 \sim w]$，第二种形状我们称作相对形状，它的取值一般介于 0 到 1。这两种形状可以通过人脸框转换。</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>人脸关键点检测分为三种：</p><ul><li>基于ASM(Active Shape Model)和AAM (Active Appearnce Model) 的传统方法、参数化方法</li><li>基于CSR(Cascaded Shape Regression)的方法、非参数化方法</li><li>基于深度学习、非参数化方法</li></ul><p>基于参数化形状模型的方法可依据其外观模型的不同，可进一步分为，基于局部的方法和基于全局的方法；对于非参数化进一步可分为基于样例的方法、基于图模型的方法、基于级联回归的方法和基于深度学习的方法。</p><h3 id="人脸关键点评价标准"><a href="#人脸关键点评价标准" class="headerlink" title="人脸关键点评价标准"></a>人脸关键点评价标准</h3><p>目前主要的衡量标准是算法所获取的关键点位置与真实关键点位置之间的偏差。在评价偏差时，由于不同人脸图像的实际大小难免会有所差异，为便于在同样的尺度下比较算法性能，需要采用一定的数据归一化策略。 目前主流的方法是基于两眼间的距离进行人脸大小的标准化：<br>$$<br>e_x = \frac{||\hat{\mathbf{x}}- \mathbf{x} ^{GT}||} {D_{IOD}}<br>$$<br>其中分子$D_{IOD}$ 表示估计值与真实值的欧式距离，分母$||\hat{\mathbf{x}}- \mathbf{x} ^{GT}||$ 表示双眼距离，即两眼中心的欧式距离。也有采用边界框对角线作为归一化因子来评价偏差。</p><h3 id="人脸常用数据库"><a href="#人脸常用数据库" class="headerlink" title="人脸常用数据库"></a>人脸常用数据库</h3><p>数据库可以分为两类：主动式捕获的数据和被动式捕获的数据。主动式捕获的数据是在实验室里，对光照变化、遮挡、头部姿态和面部表情可控的情况下，对固定人员进行照片采集。被动式捕获的数据则是在社交网站等一些环境不可控的条件下采集而得。</p><ul><li>主动式数据</li></ul><ol><li>CMU Multi-PIE：在2004年10月至2005年3月的四次会议中收集的，支持在姿态、光照和表情变化条件下识别人脸的算法的开发。 该数据库包含337个主题和超过750,000个305GB数据的图像。 共记录了六种不同的表情：中性，微笑，惊奇，斜视，厌恶和尖叫。 在15个视图和19个不同照明条件下记录受试者，这个数据库的一个子集被标记为68点或39点。</li><li>XM2VTS：收集了295人的2360个彩色图像，声音文件和3D人脸模型，这2360个彩色图像标有68个关键点。 </li><li>AR：包含超过4000个彩色图像，对应126人（70名男性和56名女性）的脸部。图像是在可控的条件下，以不同的面部表情，光照条件和遮挡（太阳镜和围巾）拍摄的。Ding and Martinez手动为每张脸部图像标注了130个关键点。</li><li>IMM：包含240张40个人的彩色图像（7名女性和33名男性）。 每张图像都对眉毛、眼睛、鼻子、嘴巴和下巴进行标注，共计58个标记点。 </li><li>MUCT：由276个人的3755张图像组成，每张图像有76个关键点。 这个数据库中的面孔在不同的光照、不同的年龄和不同的种族的条件下拍摄。 </li><li>PUT：采集了部分光照条件可控的100个人，且沿着俯仰角和偏航角旋转的9971张高分辨率图像（2048×1536），每张图像都标有30个关键点。</li></ol><ul><li>被动式数据</li></ul><ol><li>BioID：记录在室内实验室环境中，但使用“真实世界”的条件。 该数据库包含23个主题的1521个灰度人脸图像，每张图像标记20个关键点。 </li><li>LFW：包含从网上收集的5724个人的13,233幅面部图像，其中1680人在数据集中有两张或更多的照片。虽然，这个数据库没有提供标记点，但可以从其余网站上获取。 </li><li>AFLW(Annotated Facial Landmarks in the Wild) ：是一个大规模、多视角和真实环境下的人脸数据库。图像是从图片分享网站Flickr上收集，该数据库共包含25,993张图像，每张图像标有21个关键点。 </li><li>LFPW(Labeled Face Parts in the Wild)：由1400个面部图像（1100作为训练集，其他300个图像作为测试集）组成。所有数据均从google, Flickr和Yahoo上获取，每张图像标记35个关键点，但在文献中，通常采用29个关键点。 </li><li>AFW(Annotated Faces in the Wild)：包含205个图像，特点是：背景高度混乱，人脸比例和姿势都有很大的变化，每张图像均有6个关键点和边界框。 </li><li>300-W(300 Faces in-the-Wild Challenge)：一个混合数据库，由多个已发布数据库（LFPW，Helen，AFW和XM2VTS）的面部图像和一个新收集的数据库IBUG组成。 所有这些图像都重新标注了68个关键点。</li></ol><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="ASM检测方法"><a href="#ASM检测方法" class="headerlink" title="ASM检测方法"></a>ASM检测方法</h4><p>ASM(Active Shape Model)是由Cootes于1995年提出的经典的人脸关键点检测算法，主动形状模型即通过形状模型对目标物体进行抽象，ASM是一种基于点分布模型（Point Distribution Model, PDM）的算法。在PDM中，外形相似的物体，例如人脸、人手、心脏、肺部等的几何形状可以通过若干关键点（landmarks）的坐标依次串联形成一个形状向量来表示。ASM算法需要通过人工标定的方法先标定训练集，经过训练获得形状模型，再通过关键点的匹配实现特定物体的匹配。</p><p>其检测过程主要分为两步：</p><ul><li>训练<ul><li>图像预处理：<ul><li>搜集n个训练样本（n=400）， 手动标记脸部关键点；</li><li>将训练集中关键点的坐标串成特征向量</li><li>对形状进行归一化和对齐（对齐采用Procrustes方法）</li><li>对齐后的形状特征做PCA处理</li></ul></li><li>为关键点构建局部特征（在每次迭代搜索过程中每个关键点可以寻找新的位置）：<ul><li>局部特征一般用梯度特征，以防光照变化</li><li>有的方法沿着边缘的法线方向提取，有的方法在关键点附近的矩形区域提取</li></ul></li></ul></li><li>搜索<ul><li>计算眼睛（或者眼睛和嘴巴）的位置，做简单的尺度和旋转变化，对齐人脸</li><li>在对齐后的各个点附近搜索，匹配每个局部关键点（常采用马氏距离），得到初步形状</li><li>用平均人脸（形状模型）修正匹配结果</li><li>迭代直到收敛</li></ul></li></ul><p>优点：模型简单直接，架构清晰明确，易于理解和应用，而且对轮廓形状有着较强的约束</p><p>缺点：其近似于穷举搜索的关键点定位方式在一定程度上限制了其运算效率</p><h4 id="AAM"><a href="#AAM" class="headerlink" title="AAM"></a>AAM</h4><p>AAM（Active Appearance Models）。1998年，Cootes对ASM进行改进，不仅采用形状约束，而且又加入整个脸部区域的纹理特征，提出了AAM算法[2]。AAM于ASM一样，主要分为两个阶段，模型建立阶段和模型匹配阶段。其中模型建立阶段包括对训练样本分别建立形状模型(Shape Model)和纹理模型(Texture Model)，然后将两个模型进行结合，形成AAM模型。</p><h4 id="CPR"><a href="#CPR" class="headerlink" title="CPR"></a>CPR</h4><p>2010年，Dollar提出CPR（Cascaded Pose Regression, 级联姿势回归），CPR通过一系列回归器将一个指定的初始预测值逐步细化，每一个回归器都依靠前一个回归器的输出来执行简单的图像操作，整个系统可自动的从训练样本中学习。<br>人脸关键点检测的目的是估计向量<br>$$<br>S = (x_1, x_2, ···, x_k, ···, x_K) \in R^{2K}<br>$$<br>其中K表示关键点的个数，由于每个关键点有横纵两个坐标，所以S的长度为2K。CPR检测一共有T个阶段，在每个阶段中首先进行特征提取，得到<br>$$<br>f_t = \phi (I, S_t)<br>$$<br> 这里特征使用的是shape-indexed features，也可以使用诸如HOG、SIFT等人工设计的特征，或者其他可学习特征（learning based features），然后通过训练得到的回归器$r_t$来估计增量$\Delta S$( update vector)<br>$$<br>\Delta S = r_t(\phi (I, S_t))<br>$$<br>把$\Delta S$加到前一个阶段的$ S$上得到新的$S$，这样通过不断的迭代即可以得到最终的S(shape)。<br>$$<br>S_{t+1} = S_{t} + \Delta S<br>$$</p><h4 id="DCNN"><a href="#DCNN" class="headerlink" title="DCNN"></a>DCNN</h4><p>2013 年，Sun 等人 首次将 CNN 应用到人脸关键点检测，提出一种级联的 CNN（拥有三个层级）——DCNN(Deep Convolutional Network)，此种方法属于级联回归方法。作者通过精心设计拥有三个层级的级联卷积神经网络，不仅改善初始不当导致陷入局部最优的问题，而且借助于 CNN 强大的特征提取能力，获得更为精准的关键点检测。</p><div align="center"><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/computerVersion/06230452.png" width="90%"><br></div><p>如上图所示，DCNN由三个level构成。level-1是3个CNN网络；level-2是10个CNN块构成，每个关键点采用两个CNN；level-3结构类似于level-2，都为10个CNN。</p><p>Level-1的三个CNN分别为 F1（Face 1）、EN1（Eye，Nose）、NM1（Nose，Mouth）。F1 输入尺寸为 39<em>39，输出 5 个关键点的坐标；EN1 输入尺寸为 39</em>31，输出是 3 个关键点的坐标；NM11 输入尺寸为 39*31，输出是 3 个关键点；Level-1 的输出为三个 CNN 输出取平均。</p><p>Level-2，由 10 个 CNN 构成，输入尺寸均为 15*15，每两个组成一对，一对 CNN 对一个关键点进行预测，预测结果同样是采取平均。</p><p>Level-3 与 Level-2 一样，由 10 个 CNN 构成，输入尺寸均为 15*15，每两个组成一对。Level-2 和 Level-3 是对 Level-1 得到的粗定位进行微调，得到精细的关键点定位。</p><p>Level-1 之所以比 Level-2 和 Level-3 的输入要大，是因为作者认为，由于人脸检测器的原因，边界框的相对位置可能会在大范围内变化，再加上面部姿态的变化，最终导致输入图像的多样性，因此在 Level-1 应该需要有足够大的输入尺寸。Level-1 与 Level-2 和 Level-3 还有一点不同之处在于，Level-1 采用的是局部权值共享（Lcally Sharing Weights），作者认为传统的全局权值共享是考虑到，某一特征可能在图像中任何位置出现，所以采用全局权值共享。然而，对于类似人脸这样具有固定空间结构的图像而言，全局权值共享就不奏效了。因为眼睛就是在上面，鼻子就是在中间，嘴巴就是在下面的。所以作者采用局部权值共享，通过实验证明了局部权值共享给网络带来性能提升。</p><p>DCNN 采用级联回归的思想，从粗到精的逐步得到精确的关键点位置，不仅设计了三级级联的卷积神经网络，还引入局部权值共享机制，从而提升网络的定位性能。最终在数据集 BioID 和 LFPW 上均获得当时最优结果。速度方面，采用 3.3GHz 的 CPU，每 0.12 秒检测一张图片的 5 个关键点。</p><h4 id="Face-DCNN"><a href="#Face-DCNN" class="headerlink" title="Face++ DCNN"></a>Face++ DCNN</h4><p>2013 年，Face++在 DCNN 模型上进行改进，提出从粗到精的人脸关键点检测算法，实现了 68 个人脸关键点的高精度定位。该算法将人脸关键点分为内部关键点和轮廓关键点，内部关键点包含眉毛、眼睛、鼻子、嘴巴共计 51 个关键点，轮廓关键点包含 17 个关键点。</p><p>针对内部关键点和外部关键点，该算法并行的采用两个级联的 CNN 进行关键点检测，网络结构如图所示：</p><div align="center"><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/computerVersion/92897228.jpg" width="90%"><br></div><p>针对内部 51 个关键点，采用四个层级的级联网络进行检测。其中，Level-1 主要作用是获得面部器官的边界框；Level-2 的输出是 51 个关键点预测位置，这里起到一个粗定位作用，目的是为了给 Level-3 进行初始化；Level-3 会依据不同器官进行从粗到精的定位；Level-4 的输入是将 Level-3 的输出进行一定的旋转，最终将 51 个关键点的位置进行输出。针对外部 17 个关键点，仅采用两个层级的级联网络进行检测。Level-1 与内部关键点检测的作用一样，主要是获得轮廓的 bounding box；Level-2 直接预测 17 个关键点，没有从粗到精定位的过程，因为轮廓关键点的区域较大，若加上 Level-3 和 Level-4，会比较耗时间。最终面部 68 个关键点由两个级联 CNN 的输出进行叠加得到。</p><p>算法创新点：</p><ol><li>把人脸的关键点定位问题，划分为内部关键点和轮廓关键点分开预测，有效的避免了 loss 不均衡问题</li><li>在内部关键点检测部分，并采用 DCNN 的方法，将每个关键点采用两个 CNN 进行预测，而是每个器官采用一个 CNN 进行预测，从而减少计算量</li><li>相比于 DCNN，没有直接采用人脸检测器返回的结果作为输入，而是增加一个边界框检测层（Level-1），可以大大提高关键点粗定位网络的精度。</li></ol><h4 id="TCDNN"><a href="#TCDNN" class="headerlink" title="TCDNN"></a>TCDNN</h4><p>2014 年，Zhang 等人将 MTL（Multi-Task Learning）应用到人脸关键点检测中，提出 TCDCN（Tasks-Constrained Deep Convolutional Network）。作者认为，在进行人脸关键点检测任务时，结合一些辅助信息可以帮助更好的定位关键点，这些信息如，性别、是否带眼镜、是否微笑和脸部的姿势等等。作者将人脸关键点检测（5 个关键点）与性别、是否带眼镜、是否微笑及脸部的姿势这四个子任务结合起来构成一个多任务学习模型，模型框架如图所示。</p><div align="center"><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/computerVersion/15813947.jpg" width="90%"><br></div><p>网络输入为40×40的灰度图，通过CNN后得到2×2×64的特征图，再通过一层含有100个神经元的全连接层输出最终提取到的共享特征。该特征为所有任务共享，对于关键点检测问题，就采用线性回归模型；对于分类问题，就采用逻辑回归。</p><p>在传统 MLT 中，各任务重要程度是一致的，其目标方程如下：<br>$$<br>\arg\min \sum_{t-1}^{T}\sum_{i=1}^{N} \ell(y_i^t, f(\mathbf{x}<em>i^t; \mathbf{w}^t)) + \mathit{\Phi}(\mathbf {w}^t) \<br>{ \mathbf {w}^t}</em>{t=1}^T<br>$$<br>其中，</p><ul><li>$f(\mathbf{x}_i^t; \mathbf{w}^t)$表示输入矩阵$\mathbf{x}_i^t$与权值矩阵$ \mathbf{w}^t$运算后得到的输出</li><li>$\ell(.)$表示损失函数</li><li>$\mathit{\Phi}(\mathbf {w}^t)$表示正则化</li></ul><p>对于各任务 t 而言，其重要性是相同的，但是在多任务学习中，往往不同任务的学习难易程度不同，若采用相同的损失权重，会导致学习任务难以收敛。文章针对多任务学习中，不同学习难度问题进行了优化，提出带权值的目标函数：<br>$$<br>\mathop{\arg\min}<em>{\mathbf{w}^r, {\mathbf{w}^a }</em>{a\in A}} \ \ \sum_{i=1}^{N} \ell(y_i^t, f(\mathbf{x}<em>i^t; \mathbf{w}^t)) + \sum</em>{i = 1}^{N}\sum_{a\in A}\lambda ^a \ell(y_i^a, f(\mathbf{x}<em>i^a; \mathbf{w}^a))<br>$$<br>式中前一项为人脸关键点检测的损失函数，第二项表示其他任务的损失函数，$\lambda ^a$为任务$a$的重要程度。在论文中，四个子任务分别为：性别、是否带眼镜、微笑、脸部姿势，因此，优化目标函数为：<br>$$<br>\mathop{\arg\min}</em>{\mathbf{w}^r, {\mathbf{w}^a }<em>{a\in A}} \ \<br>\frac{1}{2}\sum</em>{i=1}^{N} |(y_i^t, f(\mathbf{x}_i^t; \mathbf{w}^t)|^2 </p><ul><li>\sum_{i = 1}^{N}\sum_{a\in A}\lambda ^a y_i^a \log( p (y_i^a| \mathbf{x}_i^a; \mathbf{w}^a)) </li><li>\sum_{t = 1}^T | \mathbf{w}^a |_2^2<br>$$<br>分类任务采用交叉熵损失函数。</li></ul><p>针对多任务学习的另外一个问题——各任务收敛速度不同，本文提出一种新的提前停止（Early Stopping）方法。当某个子任务达到最好表现以后，这个子任务就对主任务已经没有帮助，就可以停止这个任务。</p><p>TCDCN 采用多任务学习方法对人脸关键点进行检测，针对多任务学习在人脸关键点检测任务中的两个主要问题：不同任务学习难易程度不同以及不同任务收敛速度不同，分别提出了新目标函数和提前停止策略加以改进，最终在 AFLW 和 AFW 数据集上获得领先的结果。同时对比于级联 CNN 方法，在 Intel Core i5 cpu 上，级联 CNN 需要 0.12s，而 TCDCN 仅需要 17ms，速度提升七倍有余。</p><h4 id="MTCNN"><a href="#MTCNN" class="headerlink" title="MTCNN"></a>MTCNN</h4><p>2016 年，Zhang 等人提出一种多任务级联卷积神经网络（MTCNN, Multi-task Cascaded Convolutional Networks）用以同时处理人脸检测和人脸关键点定位问题。作者认为人脸检测和人脸关键点检测两个任务之间往往存在着潜在的联系，然而大多数方法都未将两个任务有效的结合起来，本文为了充分利用两任务之间潜在的联系，提出一种多任务级联的人脸检测框架，将人脸检测和人脸关键点检测同时进行。</p><p>MTCNN 包含三个级联的多任务卷积神经网络，分别是 Proposal Network (P-Net)、Refine Network (R-Net)、Output Network (O-Net)，每个多任务卷积神经网络均有三个学习任务，分别是人脸分类、边框回归和关键点定位。网络结构如图所示：</p><div align="center"><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/computerVersion/14009657.jpg" width="90%"><br></div><p>MTCNN 实现人脸检测和关键点定位分为三个阶段。首先由 P-Net 获得了人脸区域的候选窗口和边界框的回归向量，并用该边界框做回归，对候选窗口进行校准，然后通过非极大值抑制（NMS）来合并高度重叠的候选框。然后将 P-Net 得出的候选框作为输入，输入到 R-Net，R-Net 同样通过边界框回归和 NMS 来去掉那些 false-positive 区域，得到更为准确的候选框；最后，利用 O-Net 输出 5 个关键点的位置。</p><p>在具体训练过程中，作者就多任务学习的损失函数计算方式进行相应改进。在多任务学习中，当不同类型的训练图像输入到网络时，有些任务是不进行学习的，因此相应的损失应为 0。例如，当训练图像为背景（Non-face）时，边界框和关键点的 loss 应为 0，文中提供计算公式自动确定 loss 的选取，公式为：<br>$$<br>\min \sum_{i = 1}^{N} \sum_{j \in { det, box, landmark}} \alpha_j \beta_i^j L_i^j<br>$$<br>其中</p><ul><li>$\alpha_j$表示第$j$个任务的重要程度，在P-Net中，$\alpha_{det} = 1$ ，$\alpha_{box} = 0.5$，$\alpha_{landmark} = 0.5$；在R-Net中$\alpha_{det} = 1$ ，$\alpha_{box} = 0.5$，$\alpha_{landmark} = 1$。在R-Net中将$\alpha_{landmark} $增大，因为需要对关键点进行检测，所以相应增大任务重要性</li><li>$\beta_i^j \in (0, 1)$作为样本类型指示器</li></ul><p>为了提升网络性能，需要挑选出困难样本（Hard Sample），传统方法是通过研究训练好的模型进行挑选，而本文提出一种能在训练过程在线挑选困难样本的方法。在 mini-batch 中，对每个样本的损失进行排序，挑选前 70% 较大的损失对应的样本作为困难样本，同时在反向传播时，忽略那 30% 的样本，因为那 30% 样本对更新作用不大。</p><h4 id="TCNN"><a href="#TCNN" class="headerlink" title="TCNN"></a>TCNN</h4><p>TCNN（Tweaked Convolutional Neural Networks）2016 年，Wu 等人研究了 CNN 在人脸关键点定位任务中到底学习到的是什么样的特征，在采用 GMM（Gaussian Mixture Model, 混合高斯模型）对不同层的特征进行聚类分析，发现网络进行的是层次的，由粗到精的特征定位，越深层提取到的特征越能反应出人脸关键点的位置。针对这一发现，提出了 TCNN（Tweaked Convolutional Neural Networks），其网络结构如图所示：</p><div align="center"><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/computerVersion/89918024.jpg" width="90%"><br></div><p>左边为Vanilla CNN，针对 $FC_5$ 得到的特征进行 K 个类别聚类，将训练图像按照所分类别进行划分，用以训练所对应的 $FC_6^K$。测试时，图片首先经过 Vanilla CNN 提取特征，即 $FC_5$  的输出。将 $FC_5$ 输出的特征与 K 个聚类中心进行比较，将  $FC_5$ 输出的特征划分至相应的类别中，然后选择与之相应的 $FC_6$ 进行连接，最终得到输出。</p><p>作者对 Vanilla CNN 中间各层特征进行聚类分析，并统计出关键点在各层之间的变化程度。越深层提取到的特征越紧密，因此越深层提取到的特征越能反应出人脸关键点的位置。作者在采用 K=64 时，对所划分簇的样本进行平均后绘图如下：</p><div align="center"><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/computerVersion/62921355.jpg" width="50%"><br></div><p>从图上可发现，每一个簇的样本反应了头部的某种姿态，甚至出现了表情和性别的差异。因此可推知，人脸关键点的位置常常和人脸的属性相关联。因此为了得到更准确的关键点定位，作者使用具有相似特征的图片训练对应的回归器，最终在人脸关键点检测数据集 AFLW,AFW 和 300W 上均获得当时最佳效果。</p><h2 id="DAN"><a href="#DAN" class="headerlink" title="DAN"></a>DAN</h2><h3 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h3><p>DAN是一种人脸对齐的方法，采用级联神经网络结构，充分利用人脸的全局信息，而不是局部信息，避免局部最小化。</p><ol><li>参考CSR框架，通过前向传播提取特征，训练前向传播的backbone网络得到关键点位的偏差，替代CSR中的回归器</li><li>用级联结构来实现CSR中的迭代</li><li>利用人脸所有信息$T(I)$、$H(I)$、$F(I)$作为输入，得到关键点偏差</li><li>构造级联网络结构</li><li>分级训练网络，每一级网络loss不收敛后再训练下一级网络</li></ol><h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h3><p>2017 年，Kowalski 等人提出一种新的级联深度神经网络——DAN（Deep Alignment Network），以往级联神经网络输入的是图像的某一部分，与以往不同，DAN 各阶段网络的输入均为整张图片。当网络均采用整张图片作为输入时，DAN 可以有效的克服头部姿态以及初始化带来的问题，从而得到更好的检测效果。之所以 DAN 能将整张图片作为输入，是因为其加入了关键点热图（Landmark Heatmaps），关键点热图的使用是本文的主要创新点。DAN 基本框架如图所示：</p><div align="center"><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/computerVersion/55049944.jpg" width="80%"><br></div><p>DAN 包含多个阶段，每一个阶段含三个输入和一个输出，输入分别是被矫正过的图片、关键点热图和由全连接层生成的特征图，输出是面部形状（Face Shape）。其中，CONNECTION LAYER 的作用是将本阶段得输出进行一系列变换，生成下一阶段所需要的三个输入，具体操作如下图所示：</p><div align="center"><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/computerVersion/83789038.jpg" width="50%"><br></div><p>第一阶段的输入仅有原始图片和 $S_0$。面部关键点的初始化即为 $S_0$，是由所有关键点取平均得到，第一阶段输出 $S_1$。对于第二阶段， $S_1$经第一阶段的 CONNECTION LAYERS 进行转换，分别得到转换后图片 $T_2(I)$、 $S_1$ 所对应的热图  $H_2$ 和第一阶段 $fc_1$层输出，这三个正是第二阶段的输入。如此周而复始，直到最后一个阶段输出 $S_N$。</p><p>DAN 要做的“IMAGE TRANSFORM“，就是图片矫正， DAN 对姿态变换具有很好的适应能力，或许就得益于这个“IMAGE TRANSFORM“。$S_t$公式为：<br>$$<br>S_t = T_t^{-1}(T_t(S_{t-1}) + \Delta S_t)<br>$$</p><p>Feed forward NN网络参数为：</p><table><thead><tr><th style="text-align:center">Name</th><th style="text-align:center">Shape-in</th><th style="text-align:center">Shape-out</th><th style="text-align:center">Kernel</th></tr></thead><tbody><tr><td style="text-align:center">conv1a</td><td style="text-align:center">112×112×1</td><td style="text-align:center">112×112×64</td><td style="text-align:center">3×3×1,1</td></tr><tr><td style="text-align:center">conv1b</td><td style="text-align:center">112×112×64</td><td style="text-align:center">112×112×64</td><td style="text-align:center">3×3×64,1</td></tr><tr><td style="text-align:center">pool1</td><td style="text-align:center">112×112×64</td><td style="text-align:center">56×56×64</td><td style="text-align:center">2×2×1,2</td></tr><tr><td style="text-align:center">conv2a</td><td style="text-align:center">56×56×64</td><td style="text-align:center">56×56×128</td><td style="text-align:center">3×3×64,1</td></tr><tr><td style="text-align:center">conv2b</td><td style="text-align:center">56×56×128</td><td style="text-align:center">56×56×128</td><td style="text-align:center">3×3×128,1</td></tr><tr><td style="text-align:center">pool2</td><td style="text-align:center">56×56×128</td><td style="text-align:center">28×28×128</td><td style="text-align:center">2×2×1,2</td></tr><tr><td style="text-align:center">conv3a</td><td style="text-align:center">28×28×128</td><td style="text-align:center">28×28×256</td><td style="text-align:center">3×3×128,1</td></tr><tr><td style="text-align:center">conv3b</td><td style="text-align:center">28×28×256</td><td style="text-align:center">28×28×256</td><td style="text-align:center">3×3×256,1</td></tr><tr><td style="text-align:center">pool3</td><td style="text-align:center">28×28×256</td><td style="text-align:center">14×14×256</td><td style="text-align:center">2×2×1,2</td></tr><tr><td style="text-align:center">conv4a</td><td style="text-align:center">14×14×256</td><td style="text-align:center">14×14×512</td><td style="text-align:center">3×3×256,1</td></tr><tr><td style="text-align:center">conv4b</td><td style="text-align:center">14×14×512</td><td style="text-align:center">14×14×512</td><td style="text-align:center">3×3×512,1</td></tr><tr><td style="text-align:center">pool4</td><td style="text-align:center">14×14×512</td><td style="text-align:center">7×7×512</td><td style="text-align:center">2×2×1,2</td></tr><tr><td style="text-align:center">fc1</td><td style="text-align:center">7×7×512</td><td style="text-align:center">1×1×256</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">fc2</td><td style="text-align:center">1×1×256</td><td style="text-align:center">1×1×136</td><td style="text-align:center">-</td></tr></tbody></table><p>Feed Forward NN的输入是经过“IMAGE TRANSFORM“之后得到的偏移量$\Delta S_t$，它是在新特征空间下的偏移量，在经过偏移后再经过反变换$T_t^{-1}(·)$，将其还原到原始空间。</p><p>关键点热度图的计算就是一个中心衰减，关键点处值最大，越远则值越小，公式如下：<br>$$<br>H(x, y) = \frac{1}{1 + \mathop {\min}_{S_i \in T_t(S_{t-1})} \ \ |(x, y)-S_i |}<br>$$<br>从$fc_1$层生成特种图的目的是人为给 CNN 增加上一阶段信息。总而言之，DAN 是一个级联思想的关键点检测方法，通过引入关键点热图作为补充，DAN 可以从整张图片进行提取特征，从而获得更为精确的定位。</p><h2 id="EmotionalDAN"><a href="#EmotionalDAN" class="headerlink" title="EmotionalDAN"></a>EmotionalDAN</h2>]]></content>
      
      <categories>
          
          <category> Computer Version </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CV </tag>
            
            <tag> face detection </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>深度学习中数据预处理方法</title>
      <link href="/2018/11/08/deep_learning/data-normalization/"/>
      <url>/2018/11/08/deep_learning/data-normalization/</url>
      <content type="html"><![CDATA[<h1 id="深度学习中数据预处理方法"><a href="#深度学习中数据预处理方法" class="headerlink" title="深度学习中数据预处理方法"></a>深度学习中数据预处理方法</h1><p>数据预处理在众多深度学习算法中都起着重要作用，通常预处理包括数据归一化和白化。</p><h2 id="数据归一化（Normalization）"><a href="#数据归一化（Normalization）" class="headerlink" title="数据归一化（Normalization）"></a>数据归一化（Normalization）</h2><p>数据归一化（Data Normalization）是数据预处理的第一步，有很多方法，如常见的高斯归一化、最大最小值归一化等，而在深度学习中常用的是以下几种：</p><h3 id="简单缩放（Simple-Rescaling）"><a href="#简单缩放（Simple-Rescaling）" class="headerlink" title="简单缩放（Simple Rescaling）"></a>简单缩放（Simple Rescaling）</h3><p>简单缩放，对数据的每一个维度的值重新调节（这些维度可能是相互独立的），使得最终的数据向量落在 [0,1]或[ − 1,1] 的区间内（根据数据情况而定），以满足应用需求。</p><p>例如，在sparse auto-encoder中，由于网络的输出和输入是近似相等的，而隐含层和输出层神经元通常采用的是sigmoid函数作为激活函数，该函数值域为[0,1]，因此为了保证输出等于输入，通常需要将输入缩放至[0,1]这个范围，然后再进行训练。在处理自然图像时，我们获得的像素值在 [0,255] 区间中，常用的处理是将这些像素值除以 255，使它们缩放到 [0,1] 中。</p><p>使用Tensorflow可以进行如下处理：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">image = tf.cast(image, tf.float32) * (<span class="number">1.</span> / <span class="number">255</span>) - <span class="number">0.5</span></span><br><span class="line"><span class="comment"># image 参数表示一个三维的张量(tensor) 分别对应图像高、宽、通道数目(height, width, channels)</span></span><br></pre></td></tr></table></figure></p><h3 id="逐样本均值消减（Per-example-mean-subtraction）"><a href="#逐样本均值消减（Per-example-mean-subtraction）" class="headerlink" title="逐样本均值消减（Per-example mean subtraction）"></a>逐样本均值消减（Per-example mean subtraction）</h3><p>逐样本均值消减，也称为移除直流分量（remove DC），当数据平稳（stationary），即数据每一个维度的统计都服从相同分布，可以考虑在每个样本上减去数据的统计平均值(逐样本计算，即分别计算各样本的均值，然后各样本减去其对应的均值)。</p><p>自然图像具有平稳的性质，所以这种归一化方法也是比较常用的。这种归一化可以移除图像的平均亮度值 (intensity)。很多情况下我们对图像的照度并不感兴趣，而更多地关注其内容，这时对每个数据点移除像素的均值是有意义的。若图像是自然灰度图像，由于灰度图像具有平稳特性，通常可选择这种方法，即移除直流分量（逐样本移除直流分量后还可以继续逐样本除以各样本的标准差，不过这一步通常不做,因为其平稳特性）。</p><p>注意：虽然该方法广泛地应用于图像，但在处理彩色图像时需要格外小心，具体来说，是因为不同色彩通道中的像素并不都存在平稳特性</p><p>对自然图像应用PCA算法时候，通常也会这样处理。在深度学习图像预处理时，可以使用如下代码：<br>使用Tensorflow框架<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tf.image.per_image_standardization(image)</span><br><span class="line"><span class="comment"># image 参数表示一个三维的张量(tensor) 分别对应图像高、宽、通道数目(height, width, channels)</span></span><br></pre></td></tr></table></figure></p><p>使用opencv：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">img_dir=<span class="string">'/image/path'</span></span><br><span class="line">img_list=os.listdir(img_dir)</span><br><span class="line">img_size=<span class="number">224</span></span><br><span class="line">sum_r=<span class="number">0</span></span><br><span class="line">sum_g=<span class="number">0</span></span><br><span class="line">sum_b=<span class="number">0</span></span><br><span class="line">count=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> img_name <span class="keyword">in</span> img_list:</span><br><span class="line">    img_path=os.path.join(img_dir,img_name)</span><br><span class="line">    img=cv2.imread(img_path)</span><br><span class="line">    img=cv2.cvtColor(img,cv2.COLOR_BGR2RGB)</span><br><span class="line">    img=cv2.resize(img,(img_size,img_size))</span><br><span class="line">    sum_r=sum_r+img[:,:,<span class="number">0</span>].mean()</span><br><span class="line">    sum_g=sum_g+img[:,:,<span class="number">1</span>].mean()</span><br><span class="line">    sum_b=sum_b+img[:,:,<span class="number">2</span>].mean()</span><br><span class="line">    count=count+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">sum_r=sum_r/count</span><br><span class="line">sum_g=sum_g/count</span><br><span class="line">sum_b=sum_b/count</span><br><span class="line">img_mean=[sum_r,sum_g,sum_b]</span><br><span class="line"><span class="keyword">print</span> img_mean</span><br></pre></td></tr></table></figure></p><h3 id="特征标准化（Feature-Standardization）"><a href="#特征标准化（Feature-Standardization）" class="headerlink" title="特征标准化（Feature Standardization）"></a>特征标准化（Feature Standardization）</h3><p>特征标准化的目的是使数据集中所有特征都具有零均值和单位方差，即数据的每一个维度具有零均值和单位方差，这也是比较常见的一种归一化方法，比如使用SVM时候也要进行类似处理。在实际应用中，特征标准化的具体做法是：首先计算每一个维度上数据的均值（使用全体数据计算），之后在每一个维度上都减去该均值。下一步便是在数据的每一维度上除以该维度上数据的标准差。</p><p>例如$X$是一个训练样本集，包含m个训练样本且每个训练样本的维数是n。应用特征标准化时先计算各行数据的均值，然后样本集$X$减去该均值得到零均值化后的样本集$X^{‘}$。之后$X^{‘}$的各行除以该行数据的标准差就会得到特征标准化后的样本。</p><p>若输入是自然彩色图像，由于色彩通道间并不存在平稳特性，因此通常对数据进行特征缩放（使像素值位于 [0,1] 区间）。然后再进行PCA/ZCA白化等操作，在白化前需进行特征分量均值归零（即使特征的每一个维度具有零均值，通常不需要除以各维度数据的标准差，因为各维度标准差很接近）。在UFLDL教程的练习中（linear decoder）采用的是这种方法，而在有些论文中，也会采用第二种方法（逐样本去均值和除以标准差），如论文“An Analysis of Single-Layer Networks in Unsupervised Feature Learning”，这样在后续白化处理时是不是还需要再对各维度进行零均值化（因为计算协方差矩阵时需要这一步）。</p><h2 id="PCA-ZCA白化"><a href="#PCA-ZCA白化" class="headerlink" title="PCA/ZCA白化"></a>PCA/ZCA白化</h2><p>在做完简单的归一化后，白化通常会被用来作为接下来的预处理步骤，它会使我们的算法工作得更好。实际上许多深度学习算法都依赖于白化来获得好的特征。</p><p>在进行 PCA/ZCA 白化时，首先使特征零均值化是很有必要的，这保证了$ \frac{1}{m} \sum_i x^{(i)} = 0$。特别地，这一步需要在计算协方差矩阵前完成。（唯一例外的情况是已经进行了逐样本均值消减，并且数据在各维度上或像素上是平稳的。）接下来在 PCA/ZCA 白化中我们需要选择合适的 <code>epsilon</code>（回忆一下，这是规则化项，对数据有低通滤波作用）。 选取合适的 <code>epsilon</code> 值对特征学习起着很大作用，下面讨论在两种不同场合下如何选取 <code>epsilon</code>：</p><h3 id="基于重构的模型"><a href="#基于重构的模型" class="headerlink" title="基于重构的模型"></a>基于重构的模型</h3><p>在基于重构的模型中(包括自编码器，稀疏编码，受限 Boltzman 机（RBM），k-均值（K-Means）)，经常倾向于选取合适的 <code>epsilon</code> 以使得白化达到低通滤波的效果。（注：通常认为数据中的高频分量是噪声，低通滤波的作用就是尽可能抑制这些噪声，同时保留有用的信息。在 PCA 等方法中，假设数据的信息主要分布在方差较高的方向，方差较低的方向是噪声（即高频分量），因此后文中 <code>epsilon</code> 的选择与特征值有关）。一种检验 <code>epsilon</code> 是否合适的方法是用该值对数据进行 ZCA 白化，然后对白化前后的数据可视化。如果 <code>epsilon</code> 值过低，白化后的数据会显得噪声很大；相反，如果 <code>epsilon</code> 值过高，白化后的数据与原始数据相比就过于模糊。一种直观上得到 <code>epsilon</code> 大小的方法是以图形方式画出数据的特征值，选取的 <code>epsilon</code> 应大于大多数较小的、反映数据中噪声的特征值。</p><p>在基于重构的模型中，损失函数有一项是用于惩罚那些与原始输入数据差异较大的重构结果（注：以自动编码机为例，要求输入数据经过编码和解码之后还能尽可能的还原输入数据）。如果 <code>epsilon</code> 太小，白化后的数据中就会包含很多噪声，而模型要拟合这些噪声，以达到很好的重构结果。因此，对于基于重构的模型来说，对原始数据进行低通滤波就显得非常重要。</p><ul><li>如果数据已被缩放到合理范围(如[0,1])，可以从<code>epsilon = 0.01</code>或<code>epsilon = 0.1</code>开始调节<code>epsilon</code>。</li></ul><h3 id="基于正交化ICA的模型"><a href="#基于正交化ICA的模型" class="headerlink" title="基于正交化ICA的模型"></a>基于正交化ICA的模型</h3><p>对基于正交化ICA的模型来说，保证输入数据尽可能地白化（即协方差矩阵为单位矩阵）非常重要。这是因为：这类模型需要对学习到的特征做正交化，以解除不同维度之间的相关性（详细内容请参考 ICA 一节）。因此在这种情况下，<code>epsilon</code> 要足够小（如 <code>epsilon = 1e − 6</code>）。</p><ul><li>在使用分类框架时，我们应该只基于训练集上的数据计算PCA/ZCA白化矩阵。需要保存以下两个参数留待测试集合使用：(a)用于零均值化数据的平均值向量；(b)白化矩阵。测试集需要采用这两组保存的参数来进行相同的预处理。</li></ul><h2 id="具体应用"><a href="#具体应用" class="headerlink" title="具体应用"></a>具体应用</h2><h3 id="自然灰度图像"><a href="#自然灰度图像" class="headerlink" title="自然灰度图像"></a>自然灰度图像</h3><p>灰度图像具有平稳特性，我们通常在第一步对每个数据样本分别做均值消减（即减去直流分量），然后采用 PCA/ZCA 白化处理，其中的 <code>epsilon</code> 要足够大以达到低通滤波的效果。</p><h3 id="自然彩色图像"><a href="#自然彩色图像" class="headerlink" title="自然彩色图像"></a>自然彩色图像</h3><p>对于彩色图像，色彩通道间并不存在平稳特性。因此我们通常首先对数据进行特征缩放（使像素值位于 [0,1] 区间），然后使用足够大的 <code>epsilon</code> 来做 PCA/ZCA。在进行 PCA 变换前需要对特征进行分量均值归零化。</p><h3 id="MINIS手写数据集"><a href="#MINIS手写数据集" class="headerlink" title="MINIS手写数据集"></a>MINIS手写数据集</h3><p>MNIST 数据集的像素值在 [0,255] 区间中。我们首先将其缩放到 [0,1] 区间。实际上，进行逐样本均值消去也有助于特征学习。注：也可选择以对 MNIST 进行 PCA/ZCA 白化，但这在实践中不常用。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Deep Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 神经网络 </tag>
            
            <tag> 数据预处理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>迁移学习--样本自适应</title>
      <link href="/2018/11/08/deep_learning/transfer-learning/"/>
      <url>/2018/11/08/deep_learning/transfer-learning/</url>
      <content type="html"><![CDATA[<h1 id="迁移学习——样本自适应"><a href="#迁移学习——样本自适应" class="headerlink" title="迁移学习——样本自适应"></a>迁移学习——样本自适应</h1><h2 id="DaNN"><a href="#DaNN" class="headerlink" title="DaNN"></a>DaNN</h2><p>2014年提出(Domain adaptive Neural Networks for Object Recognition)</p><h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h3><p>两层神经元组成：特征层和分类器层 </p><h3 id="创新点"><a href="#创新点" class="headerlink" title="创新点"></a>创新点</h3><p>在特征层加入MMD适配层，用以计算源域和目标域的距离，网络的优化目标为：</p><ul><li>在有label的源域数据上的分类误差$\ell_{C}$</li><li>对两个domain数据的判别误差$\ell_{D}$</li></ul><p>因此，优化目标为：$\ell=\ell_{C} + \lambda \ell_{D}$，其中$\lambda$为网络适配权重参数。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>由于网络太浅，表征能力有限，故无法很有效地解决domain adaptation问题（通俗点说就是精度不高）。<br>因此，后续的研究者大多数都基于其思想进行扩充，如将浅层网络改为更深层的AlexNet、ResNet、VGG等；<br>如将MMD换为多核的MMD等。</p><h3 id="MMD"><a href="#MMD" class="headerlink" title="MMD"></a>MMD</h3><p>最大均值差异（Maximum mean discrepancy），度量在再生希尔伯特空间中两个分布的距离，是一种核学习方法。</p><p>两个随机变量的距离为：<br>$$<br>\begin{equation}<br>MMD[\mathfrak{F},X,Y]=[\frac{1}{m^{2}}\sum_{i,j=1}^{m}k(x_{i},y_{j}) - \frac{2}{mn}\sum_{i,j=1}^{m,n}k(x_{i},y_{j}) + \frac{1}{n^{2}}\sum_{i,j=1}^{n}k(x_{i},y_{j})]^{\frac{1}{2}}<br>\end{equation}<br>$$<br>其中</p><ul><li>$k()$是映射关系，类似于SVM中的核函数，把原变量映射到高维空间;</li><li>X，Y为两种分布的样本，</li><li>$\mathfrak{F}$表示映射函数集 </li></ul><p>基于两个分布的样本，通过寻找在样本空间上的映射函数k，求不同分布的样本在k上的函数值的均值，通过把两个均值作差可以得到两个分布对应于k的mean discrepancy。寻找一个k使得这个mean discrepancy有最大值，就得到了MMD。<br>最后取MMD作为检验统计量（test statistic），从而判断两个分布是否相同。如果这个值足够小，就认为两个分布相同，否则就认为它们不相同。更加简单的理解就是：求两堆数据在高维空间中的均值的距离。<br>近年来，MMD越来越多地应用在迁移学习中。在迁移学习环境下训练集和测试集分别取样自分布p和q，两类样本集不同但相关。可以利用深度神经网络的特征变换能力，来做特征空间的变换，直到变换后的特征分布相匹配，这个过程可以是source domain一直变换直到匹配target domain。匹配的度量方式就是MMD。</p><h2 id="DDC-Deep-Domain-Confusion"><a href="#DDC-Deep-Domain-Confusion" class="headerlink" title="DDC(Deep Domain Confusion)"></a>DDC(Deep Domain Confusion)</h2><p>Deep Domain Confusion: Maximizing for Domain Invariance发表于2014年。DDC针对预训练的AlexNet（8层）网络，在第7层（也就是feature层，softmax的上一层）加入了MMD距离来减小source和target之间的差异。</p><div align="center"><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/deepLearning/66547922.jpg" alt="DDC structure" title="DDC structure" width="50%/"><br></div><p>DDC在原有的AlexNet结构中，对网络的fc7添加一层适配器(Adaption layer)，单独考察网络对源域和目标域的判断能力。若判别能力很差就认为网络学到的特征不足以将两个领域数据区分开，有助于学习到对领域不敏感的特征表示。DDC是深度网络应用于迁移学习领域的经典作品。</p><h2 id="DAN-Deep-Adaptation-Networks"><a href="#DAN-Deep-Adaptation-Networks" class="headerlink" title="DAN(Deep Adaptation Networks)"></a>DAN(Deep Adaptation Networks)</h2><p>DAN（2015）是在DDC的基础上发展而来，解决了DDC的两个问题：</p><ul><li>DDC只适配一层网络，效果不够好，因为不同层都是可以迁移的，因此DAN可以多适配几层</li><li>DDC只用了单一核的MMD，这个核可能不是最优的核，因此采用多核的MMD，即MK-MMD。</li></ul><p>DAN的网络结构为：</p><div align="center"><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/deepLearning/12001851.jpg" alt="DAN structure" title="DAN structure" width="80%/"><br></div><h3 id="多核MMD（Multi-kernel-MMD）"><a href="#多核MMD（Multi-kernel-MMD）" class="headerlink" title="多核MMD（Multi-kernel MMD）"></a>多核MMD（Multi-kernel MMD）</h3><p>MMD主要思想是把source和target用相同的映射方法映射到同一个再生核希尔伯特空间（RKHS）中，然后求映射后两部分的均值差异，作为两部分数据的差异。在MMD中这个核函数是固定的，在实现时可以选择是高斯核还是线性核使用单一的核函数，无法确定哪个核函数好。因此使用多个核构造总的核。</p><p>对于两个概率分布$p$，$q$，它们之间的MK-MMD为：<br>$$<br>d^2_k(p,q) \triangleq ||E_p[\phi(\mathbf{x}_s)]-E_q[\phi(\mathbf{x}<em>t)]||^2</em>{\mathcal{H}}<br>$$<br>多个核一起定义的kernel为：<br>$$<br>\mathcal{K} \triangleq \left{k= \sum_{u=1}^{m}\beta_u k_u : \beta_u \ge 0, \forall u \right}<br>$$</p><p>用$m$个不同的kernel加权，权重为$\beta_u$，得到的$\mathcal{K}$表征能力比单核更强。</p><h3 id="多层适配"><a href="#多层适配" class="headerlink" title="多层适配"></a>多层适配</h3><p>DDC方法中，只适配AlexNet的第七层，DAN仍然基于AlexNet网络，适配最后三个全连接层。因为网络的迁移能力在这三层会task-spacific，类似于Inception、ResNet等，在迁移学习时，只学习最后一层全连接层的参数，经过softmax层后得到分类信息。</p><h3 id="优化目标"><a href="#优化目标" class="headerlink" title="优化目标"></a>优化目标</h3><p>DAN方法，基于AlexNet网络，探索source和target之间的适配关系。任何一个方法都有优化的目标。DAN也不例外。它的优化目标由两部分组成：损失函数和分布距离。基本上所有的机器学习方法都会定义一个损失函数，它来度量预测值和真实值的差异。分布距离就是面提到的MK-MMD距离。于是，DAN的优化目标就是：</p><p>$$<br>\min_\Theta \frac{1}{n_a} \sum_{i=1}^{n_a} J(\theta(\mathbf{x}^a_i),y^a_i) + \lambda \sum_{l=l_1}^{l_2}d^2_k(\mathcal{D}^l_s,\mathcal{D}^l_t)<br>$$</p><ul><li>$\Theta$表示所有权重和bias参数，是需要学习得到的目标参数；</li><li>$l_1$、$l_2$表示网络适配从第六层到第八层，前面的网络不进行适配；</li><li>$\mathbf{x}_a$，$n_a$表示source和target中所有的label数据集合；</li><li>$\lambda$为惩罚系数；</li><li>$J(.)$定义一个损失函数，一般使用cross-entropy。</li></ul><p>损失函数的前面部分是网络参数$\Theta$，后面部分为MMD的距离参数$\beta$</p><h4 id="网络参数学习"><a href="#网络参数学习" class="headerlink" title="网络参数学习"></a>网络参数学习</h4><p>对$\Theta$的学习依赖于MK-MMD距离的计算。通过kernel trick（类比于以前的MMD距离）总是可以把MK-MMD展开成一堆内积的形式。然而，数据之间两两计算内积是非常复杂的，时间复杂度为$O(n^2)$，这个在深度学习中的开销非常大。<br>因此，提出对MK-MMD的无偏估计：</p><p>$$<br>d^2_k(p,q)=\frac{2}{n_s}\sum_{i=1}^{n_s/2}g_k(\mathbf{z}_i)\<br>\mathbf{z}<em>i \triangleq (\mathbf{x}^s</em>{2i-1},\mathbf{x}^s_{2i},\mathbf{x}^t_{2i-1},\mathbf{x}^t_{2i})<br>$$</p><p>将kernel作用到$\mathbf{z}_i$上，变为：<br>$$<br>g_k(\mathbf{z}<em>i) \triangleq k(\mathbf{x}^s</em>{2i-1},\mathbf{x}^s_{2i})+k(\mathbf{x}^t_{2i-1},\mathbf{x}^t_{2i})-k(\mathbf{x}^s_{2i-1},\mathbf{x}^t_{2i})-k(\mathbf{x}^s_{2i},\mathbf{x}^t_{2i-1})<br>$$<br>只计算了连续的一对数据的距离，再乘以2，这样就可以把时间复杂度降低到$O(n)$。在具体进行SGD的时候，需要对所有的参数求导：对$\Theta$求导。在实际用multiple-kernel的时候，作者用多个高斯核。</p><h2 id="Beyond-Sharing-Weights-for-Deep-Domain-Adaptation"><a href="#Beyond-Sharing-Weights-for-Deep-Domain-Adaptation" class="headerlink" title="Beyond Sharing Weights for Deep Domain Adaptation"></a>Beyond Sharing Weights for Deep Domain Adaptation</h2><p>发表于2016年，提出了在适配层中target和source不共享参数的思想。与以往的Domain adaptation在Deep Learing中的运用不同，这篇论文提出，在source domain和target domain之间使用不同的参数而非共享参数（不是所有的layers都不共享参数，有些层还是共享了）。他们提出在试验中这种网络的表现会好于那些使用共享参数的网络。</p><p>其网络结构为双流结构：</p><div align="center"><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/deepLearning/65970249.jpg" alt="BSW for DDA" title="BSW for DDA" width="70%/"><br></div><p>该结构引入loss防止两个分支对应的权重差异过大。</p><h2 id="Deep-CORAL-Correlation-Alignment-for-Deep-Domain-Adaptation"><a href="#Deep-CORAL-Correlation-Alignment-for-Deep-Domain-Adaptation" class="headerlink" title="Deep CORAL: Correlation Alignment for Deep Domain Adaptation"></a>Deep CORAL: Correlation Alignment for Deep Domain Adaptation</h2><p>这篇文章发表于2016年，主要提出一个CORAL loss，通过对source domain和target domain进行线性变换将各自的二阶统计量对齐。<br>$$<br>L_{CORAL} = \frac{1}{4d^2} ||C_S - C_T||^2 \<br>C_S = \frac{1}{n_S - 1}(D_S^TD_S - \frac{1}{n_S} (1^TD_S)^T (1^TD_S)) \<br>C_T = \frac{1}{n_T - 1}(D_T^TD_T - \frac{1}{n_T} (1^TD_T)^T (1^TD_T))<br>$$<br>其中</p><ul><li><p>$n_S$，$n_T$为source domain和target domain的batch size；</p></li><li><p>$d$为特征的维度；</p></li><li>$1^T$为一个全1的向量</li></ul><p>其网络结构为：</p><div align="center"><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/deepLearning/32435164.jpg" alt="Deep CORAL" title="Deep CORAL" width="80%/"><br></div><h2 id="Deep-Domain-Adaptation-by-Geodesic-Distance-Minimization"><a href="#Deep-Domain-Adaptation-by-Geodesic-Distance-Minimization" class="headerlink" title="Deep Domain Adaptation by Geodesic Distance Minimization"></a>Deep Domain Adaptation by Geodesic Distance Minimization</h2><p>文章发表于2017年，在CORAL loss的基础上将其改进为Log-CORAL loss。表示两个协方差矩阵的log之间的欧氏距离。公式为：<br>$$<br>L_{LogCORAL} = \frac{1}{4d^2} ||log(C_S) - log(C_T)||^2 \<br>$$<br>其网络结构为：</p><div align="center"><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/deepLearning/24542894.jpg" alt="Log-CORAL loss" title="Log-CORAL loss" width="80%/"><br></div><p>特征迁移目前都是小网络进行尝试，常用的特征分布的度量标准是MMD和CORAL等，但其在网络中的位置，以及损失核K的选取都很关键，并且发现多应用于FC层，哪些层应该或不应该共享其权重的最佳选择取决于实际的应用。 </p><p>FC可在模型表示能力迁移过程中充当“防火墙”的作用。具体来讲，假设在ImageNet上预训练得到的模型为M ，则ImageNet可视为源域（迁移学习中的source domain）。微调（fine tuning）是深度学习领域最常用的迁移学习技术。针对微调，若目标域（target domain）中的图像与源域中图像差异巨大（如相比ImageNet，目标域图像不是物体为中心的图像，而是风景照），不含FC的网络微调后的结果要差于含FC的网络。因此FC可视作模型表示能力的“防火墙”，特别是在源域与目标域差异较大的情况下，FC可保持较大的模型capacity从而保证模型表示能力的迁移。（冗余的参数并不一无是处。）</p><h2 id="多领域适应"><a href="#多领域适应" class="headerlink" title="多领域适应"></a>多领域适应</h2><p>《Deep Cocktail Network: Multi-source Unsupervised Domain Adaptation with Category Shift》发表于2018年。</p>]]></content>
      
      <categories>
          
          <category> Deep Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CV </tag>
            
            <tag> transfer learning </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leedcode4</title>
      <link href="/2018/11/08/leetCode/leedcode4/"/>
      <url>/2018/11/08/leetCode/leedcode4/</url>
      <content type="html"><![CDATA[<h1 id="114-Flatten-Binary-Tree-to-Linked-List"><a href="#114-Flatten-Binary-Tree-to-Linked-List" class="headerlink" title="114. Flatten Binary Tree to Linked List"></a>114. Flatten Binary Tree to Linked List</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a binary tree, flatten it to a linked list in-place.<br>For example, given the following tree:<br>    1<br>   / \<br>  2   5<br> / \   \<br>3   4   6<br>The flattened tree should look like:</p><p>1<br> \<br>  2<br>   \<br>    3<br>     \<br>      4<br>       \<br>        5<br>         \<br>          6</p><h2 id="Hints"><a href="#Hints" class="headerlink" title="Hints"></a>Hints</h2><p>If you notice carefully in the flattened tree, each node’s right child points to the next node of a pre-order traversal.</p><h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><p>非递归的先序遍历，使用栈临时存储节点，先存右子节点，再存左子节点</p><h1 id="4-Median-of-Two-Sorted-Arrays"><a href="#4-Median-of-Two-Sorted-Arrays" class="headerlink" title="4. Median of Two Sorted Arrays"></a>4. Median of Two Sorted Arrays</h1><p>There are two sorted arrays nums1 and nums2 of size m and n respectively.</p><p>Find the median of the two sorted arrays. The overall run time complexity should be$ O(log (m+n))$.</p><p>You may assume nums1 and nums2 cannot be both empty.</p><h2 id="Method-1"><a href="#Method-1" class="headerlink" title="Method"></a>Method</h2><p>cut A and B into two parts:</p><table><thead><tr><th style="text-align:center">left_part</th><th style="text-align:center">right_part</th></tr></thead><tbody><tr><td style="text-align:center">A[0], A[1], …, A[i-1]</td><td style="text-align:center">A[i], A[i+1], …, A[m-1]</td></tr><tr><td style="text-align:center">B[0], B[1], …, B[j-1]</td><td style="text-align:center">B[j], B[j+1], …, B[n-1]</td></tr></tbody></table><p>there is two conditions we should make sure:</p><ul><li><code>len(left_part) == len(right_part)</code></li><li><code>max(left_part) &lt;= min(right_part)</code></li></ul><p>so, for the aboving condition, the equivalent should be：<br>$$<br>i + j = m - i + n - j \quad and \quad m \leq n\<br>B[j -1] \leq A[i] \quad and \quad A[i - 1] \leq B[j]<br>$$<br>the condition $m \leq n$ means $j \geq 0$。</p><p>then the median of two arrays is:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">median = (max(left_part) + min(right_part)) / 2    // when m + n is even</span><br><span class="line">median = max(A[i-1], B[j-1])                       // when m + n is odd</span><br></pre></td></tr></table></figure><p>the mission can be solved by the following steps:</p><ul><li>find min(len(array1), len(array2)) and set it to m</li><li>searching i in [0, m] to find the ‘i’ that:<ul><li><code>B[j - 1] &lt;= A[i]</code> and <code>A[i -1] &lt;= B[j]</code> where <code>j =  (m + n + 1)/2 - i</code></li></ul></li></ul><p>if the time complexity is $ O(log (min(m+n)))$,we should use binary search to find the ‘i’</p><h2 id="Pseudo-code"><a href="#Pseudo-code" class="headerlink" title="Pseudo-code"></a>Pseudo-code</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;1&gt; Set imin = 0, imax = m, then start searching in [imin, imax]</span><br><span class="line">&lt;2&gt; Set i = (imin + imax)/2, j = (m + n + 1)/2 - i</span><br><span class="line">&lt;3&gt; Now we have len(left_part)==len(right_part). And there are only 3 situations</span><br><span class="line">     that we may encounter:</span><br><span class="line">     &lt;a&gt; B[j-1] &lt;= A[i] and A[i-1] &lt;= B[j]</span><br><span class="line">         means we have found the object &apos;i&apos;, stop searching</span><br><span class="line">     &lt;b&gt; B[j-1] &gt; A[i]</span><br><span class="line">         means A[i] is too small, &apos;i&apos; should be increased, so set:</span><br><span class="line">         imin = i + 1;</span><br><span class="line">         go to &lt;2&gt;</span><br><span class="line">     &lt;c&gt; A[i-1] &gt; B[j]</span><br><span class="line">         means A[i-1] is too big, &apos;i&apos; should be decreased, so set:</span><br><span class="line">         imax = i - 1;</span><br><span class="line">         go to &lt;2&gt;</span><br></pre></td></tr></table></figure><p>when it comes to eadge values  <strong>i=0,i=m,j=0,j=n</strong>, where<strong> A[i-1],B[j-1],A[i],B[j]</strong> may not exist.</p>]]></content>
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leedcode4</title>
      <link href="/2018/11/08/offer_problem/leedcode4/"/>
      <url>/2018/11/08/offer_problem/leedcode4/</url>
      <content type="html"><![CDATA[<h1 id="114-Flatten-Binary-Tree-to-Linked-List"><a href="#114-Flatten-Binary-Tree-to-Linked-List" class="headerlink" title="114. Flatten Binary Tree to Linked List"></a>114. Flatten Binary Tree to Linked List</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a binary tree, flatten it to a linked list in-place.<br>For example, given the following tree:<br>    1<br>   / \<br>  2   5<br> / \   \<br>3   4   6<br>The flattened tree should look like:</p><p>1<br> \<br>  2<br>   \<br>    3<br>     \<br>      4<br>       \<br>        5<br>         \<br>          6</p><h2 id="Hints"><a href="#Hints" class="headerlink" title="Hints"></a>Hints</h2><p>If you notice carefully in the flattened tree, each node’s right child points to the next node of a pre-order traversal.</p><h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><p>非递归的先序遍历，使用栈临时存储节点，先存右子节点，再存左子节点</p><h1 id="4-Median-of-Two-Sorted-Arrays"><a href="#4-Median-of-Two-Sorted-Arrays" class="headerlink" title="4. Median of Two Sorted Arrays"></a>4. Median of Two Sorted Arrays</h1><p>There are two sorted arrays nums1 and nums2 of size m and n respectively.</p><p>Find the median of the two sorted arrays. The overall run time complexity should be$ O(log (m+n))$.</p><p>You may assume nums1 and nums2 cannot be both empty.</p><h2 id="Method-1"><a href="#Method-1" class="headerlink" title="Method"></a>Method</h2><p>cut A and B into two parts:</p><table><thead><tr><th style="text-align:center">left_part</th><th style="text-align:center">right_part</th></tr></thead><tbody><tr><td style="text-align:center">A[0], A[1], …, A[i-1]</td><td style="text-align:center">A[i], A[i+1], …, A[m-1]</td></tr><tr><td style="text-align:center">B[0], B[1], …, B[j-1]</td><td style="text-align:center">B[j], B[j+1], …, B[n-1]</td></tr></tbody></table><p>there is two conditions we should make sure:</p><ul><li><code>len(left_part) == len(right_part)</code></li><li><code>max(left_part) &lt;= min(right_part)</code></li></ul><p>so, for the aboving condition, the equivalent should be：<br>$$<br>i + j = m - i + n - j \quad and \quad m \leq n\<br>B[j -1] \leq A[i] \quad and \quad A[i - 1] \leq B[j]<br>$$<br>the condition $m \leq n$ means $j \geq 0$。</p><p>then the median of two arrays is:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">median = (max(left_part) + min(right_part)) / 2    // when m + n is even</span><br><span class="line">median = max(A[i-1], B[j-1])                       // when m + n is odd</span><br></pre></td></tr></table></figure><p>the mission can be solved by the following steps:</p><ul><li>find min(len(array1), len(array2)) and set it to m</li><li>searching i in [0, m] to find the ‘i’ that:<ul><li><code>B[j - 1] &lt;= A[i]</code> and <code>A[i -1] &lt;= B[j]</code> where <code>j =  (m + n + 1)/2 - i</code></li></ul></li></ul><p>if the time complexity is $ O(log (min(m+n)))$,we should use binary search to find the ‘i’</p><h2 id="Pseudo-code"><a href="#Pseudo-code" class="headerlink" title="Pseudo-code"></a>Pseudo-code</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;1&gt; Set imin = 0, imax = m, then start searching in [imin, imax]</span><br><span class="line">&lt;2&gt; Set i = (imin + imax)/2, j = (m + n + 1)/2 - i</span><br><span class="line">&lt;3&gt; Now we have len(left_part)==len(right_part). And there are only 3 situations</span><br><span class="line">     that we may encounter:</span><br><span class="line">     &lt;a&gt; B[j-1] &lt;= A[i] and A[i-1] &lt;= B[j]</span><br><span class="line">         means we have found the object &apos;i&apos;, stop searching</span><br><span class="line">     &lt;b&gt; B[j-1] &gt; A[i]</span><br><span class="line">         means A[i] is too small, &apos;i&apos; should be increased, so set:</span><br><span class="line">         imin = i + 1;</span><br><span class="line">         go to &lt;2&gt;</span><br><span class="line">     &lt;c&gt; A[i-1] &gt; B[j]</span><br><span class="line">         means A[i-1] is too big, &apos;i&apos; should be decreased, so set:</span><br><span class="line">         imax = i - 1;</span><br><span class="line">         go to &lt;2&gt;</span><br></pre></td></tr></table></figure><p>when it comes to eadge values  <strong>i=0,i=m,j=0,j=n</strong>, where<strong> A[i-1],B[j-1],A[i],B[j]</strong> may not exist.</p>]]></content>
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>友元、this指针、常量</title>
      <link href="/2018/08/22/c++/c-2-2/"/>
      <url>/2018/08/22/c++/c-2-2/</url>
      <content type="html"><![CDATA[<h1 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h1><h2 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h2><p>一个类的友元函数可以访问该类的私有成员</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCar</span>;</span> <span class="comment">//提前声明CCar类, 以便后面CDriver类使用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDriver</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">ModifyCar</span><span class="params">(CCar * pCar)</span> </span>; <span class="comment">//改装汽车</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCar</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> price;</span><br><span class="line"> <span class="function"><span class="keyword">friend</span> <span class="keyword">int</span> <span class="title">MostExpensiveCar</span><span class="params">(CCar cars[], <span class="keyword">int</span> total)</span></span>; <span class="comment">//声明友元</span></span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">void</span> CDriver::ModifyCar(CCar * pCar); <span class="comment">//声明友元</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//汽车改装后价值增加</span></span><br><span class="line"><span class="keyword">void</span> CDriver::ModifyCar(CCar * pCar)&#123;</span><br><span class="line">pCar-&gt;price += <span class="number">1000</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求最贵汽车的价格</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MostExpensiveCar</span><span class="params">(CCar cars[], <span class="keyword">int</span> total)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmpMax = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cars[i].price &gt; tmpMax)</span><br><span class="line">            tmpMax = cars[i].price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmpMax;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以将一个类的成员函数定义为另一个类的友元函数</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">void</span> B::function();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式使得在class A中也可以通过class B的function访问到B的私有成员。</p><h2 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h2><p>类A如果是B的友元类，那么A的成员函数就可以访问B的私有成员</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCar</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">CDiver</span>;</span>    <span class="comment">// 声明CDiver为友元类</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDiver</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    CCar myCar;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ModifyCar</span><span class="params">()</span></span>&#123;</span><br><span class="line">        myCar.price += <span class="number">1000</span>; <span class="comment">//  CDriver是CCar的友元类,可以访问其私有成员</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>友元类之间的关系不能传递，也无法继承，也就是如果A是B的友元，B是C的友元，那么不能说A是C的友元。</p><hr><h1 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h1><p>this指针的作用是指向成员函数所作用的对象。非静态成员函数中可以直接使用this来代表指向该函数作用的对象的指针。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> real, imag;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;real&lt;&lt;<span class="string">","</span>&lt;&lt;imag;&#125;</span><br><span class="line">    Complex(<span class="keyword">double</span> r, <span class="keyword">double</span> i):real(r), imag(i)&#123;&#125;</span><br><span class="line">    <span class="function">Complex <span class="title">AddOne</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 因为this指针作用于当前指向的对象</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;real++;           <span class="comment">// 等价于 real++</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;Print();          <span class="comment">// 等价于 Print()</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用时：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Complex c1(1, 1), c2(0, 0);</span><br><span class="line">    c2 = c1.AddOne();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c++编译时相当于需要把它转换成c语言，转换后的代码为：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> real;</span><br><span class="line">    <span class="keyword">double</span> imag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(struct Complex *<span class="keyword">this</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">this</span>-&gt;real&lt;&lt;<span class="string">","</span>&lt;&lt;<span class="keyword">this</span>-&gt;imag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Complex</span><span class="params">(struct Complex *<span class="keyword">this</span>, <span class="keyword">double</span> r, <span class="keyword">double</span>, i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;real = r;</span><br><span class="line">    <span class="keyword">this</span>-&gt;imag = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">struct Complex <span class="title">AddOne</span><span class="params">(struct Complex *<span class="keyword">this</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;real++;</span><br><span class="line">    <span class="keyword">this</span>-&gt;Print(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Complex</span> <span class="title">complex1</span>;</span></span><br><span class="line">    Complex(&amp; complex1, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Complex</span> <span class="title">complex2</span>;</span></span><br><span class="line">    Complex(&amp; complex2, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    complex2 = AddOne(&amp; complex1);</span><br><span class="line">    Print(&amp; complex2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在程序中c2的实部为2，虚部为1，输出结果为</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2,1</span><br></pre></td></tr></table></figure><h2 id="this指针作用"><a href="#this指针作用" class="headerlink" title="this指针作用"></a>this指针作用</h2><p>在编译时，如果对象是空，即this指针作用的对象为NULL，</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Hello"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A *p = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;Hello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在编译时，如果对象是空，即this指针作用的对象为NULL，程序仍然会执行第10行代码<code>p-&gt;Hello()</code>程序，因为在编译时，翻译为：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Hello</span><span class="params">(A * <span class="keyword">this</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Hello"</span>&lt;&lt;end</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A *p = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;Hello(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下程序不会产生错误。</p><p>在下面的情况下，程序会出错：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">"Hello"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A *p = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;Hello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，编译翻译为c语言时，变为：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Hello</span><span class="params">(A * <span class="keyword">this</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">this</span>-&gt;i&lt;&lt;<span class="string">"Hello"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A *p = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;Hello(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里this是个空指针，因此<code>this-&gt;i</code>这句会编译错误。</p><h2 id="this指针和静态成员函数"><a href="#this指针和静态成员函数" class="headerlink" title="this指针和静态成员函数"></a>this指针和静态成员函数</h2><p>静态成员函数中不能使用this指针，因为静态成员函数不具体作用于某个对象，因此在翻译时，静态成员函数的真实的参数个数就是程序中写出的参数个数。</p><hr><h1 id="常量及常引用"><a href="#常量及常引用" class="headerlink" title="常量及常引用"></a>常量及常引用</h1><h2 id="常量对象"><a href="#常量对象" class="headerlink" title="常量对象"></a>常量对象</h2><p>如果不希望某个对象的值被改变，则定义该对象的时候可以在前面加const关键字。</p><p>如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetValue</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> Demo Obj;              <span class="comment">// 常量对象</span></span><br></pre></td></tr></table></figure><p>obj初始化完成之后就无法再修改其值。</p><h2 id="常量成员函数"><a href="#常量成员函数" class="headerlink" title="常量成员函数"></a>常量成员函数</h2><p>在类的成员函数说明后面可以加const关键字，则该成员函数成为常量成员函数。</p><p>如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sample</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> value;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetValue</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; &#125;;</span><br><span class="line">Sample() &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> Sample::GetValue() <span class="keyword">const</span>&#123;</span><br><span class="line">value = <span class="number">0</span>; <span class="comment">// wrong</span></span><br><span class="line">func(); <span class="comment">//wrong</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常量成员函数执行期间不应修改其所作用的对象。因此，在常量成员函数中不能修改成员变量的值（静态成员变量除外），也不能调用同类的非常量成员函数(静态成员函数除外）。</p><p>在main函数中，常量对象用法：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> Sample sample;</span><br><span class="line">    sample.value = <span class="number">100</span>;   <span class="comment">// erro常量对象不可被修改 </span></span><br><span class="line">    sample.func();        <span class="comment">// erro常量对象不可调用非常量函数</span></span><br><span class="line">    sample.GetValue();    <span class="comment">// ok常量对象可以执行常量成员函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个成员函数，名字和参数表都一样，但是一个是const,一个不是，算重载。</p><p>如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTest</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    CTest()&#123;n=<span class="number">1</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetValue</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> n;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetValue</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">2</span> * n;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> CTest objTest1;</span><br><span class="line">    CTest objTest2;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;objTest1.GetValue()&lt;&lt;<span class="string">","</span>&lt;&lt;objTest2.GetValue();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1,2</span><br></pre></td></tr></table></figure><h2 id="常引用"><a href="#常引用" class="headerlink" title="常引用"></a>常引用</h2><p>引用前面可以加const关键字，称为常引用。不能通过常引用，修改其引用的变量。</p><p>如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp; r = n;</span><br><span class="line">r = <span class="number">6</span>;    <span class="comment">// error</span></span><br><span class="line">n = <span class="number">4</span>;    <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p>常引用经常被用来作为函数的参数，因为在写函数的时候，若把对象作为函数参数，生成这个参数对象需要调用复制构造函数，增加了时间和空间的开销。因此，使用对象的引用作为参数，节省开销。</p><p>对象引用作为函数参数有一定的风险性，若函数中不小心修改了形参的值，那么实参也会发生改变，如果不想让实参发生变化，可以将形参写为<code>const Object &amp; o</code>可以确保不会出现无意中更改o值的语句。</p><hr><h1 id="测验"><a href="#测验" class="headerlink" title="测验"></a>测验</h1><ol start="3"><li>以下关于 this 指针的说法中不正确的是：</li></ol><ul><li style="list-style: none"><input type="checkbox"> 在构造函数内部可以使用this指针</li><li style="list-style: none"><input type="checkbox"> 成员函数内的this 指针，指向成员函数所作用的对象</li><li style="list-style: none"><input type="checkbox" checked> const成员函数内部不可以使用this 指针</li><li style="list-style: none"><input type="checkbox"> 在析构函数内部可以使用 this 指针</li></ul><ol start="4"><li>以下程序，哪个是不正确的？</li></ol><ul><li style="list-style: none"><input type="checkbox"> A</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span> <span class="keyword">int</span> v; &#125;;</span><br><span class="line">A a; </span><br><span class="line">    a.v = <span class="number">3</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li style="list-style: none"><input type="checkbox"> B</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span> <span class="keyword">public</span>: <span class="keyword">int</span> v; A * p;&#125;;</span><br><span class="line">A a; </span><br><span class="line">    a.p = &amp; a; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li style="list-style: none"><input type="checkbox"> C</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span> <span class="keyword">public</span>: <span class="keyword">int</span> v; &#125;;</span><br><span class="line">A * p = <span class="keyword">new</span> A;</span><br><span class="line">p-&gt;v = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li style="list-style: none"><input type="checkbox" checked> D</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span> <span class="keyword">public</span>: <span class="keyword">int</span> v; A * p;&#125;;</span><br><span class="line">A a; </span><br><span class="line">    a.p = <span class="keyword">new</span> A; </span><br><span class="line">    <span class="keyword">delete</span> a.p;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="编程作业"><a href="#编程作业" class="headerlink" title="编程作业"></a>编程作业</h1><h2 id="程序填空"><a href="#程序填空" class="headerlink" title="程序填空"></a>程序填空</h2><ol><li>下面程序输出结果是：</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">5</span><br></pre></td></tr></table></figure><p>填空：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="comment">// 此处代码填空</span></span><br><span class="line">    A(<span class="keyword">int</span> n=<span class="number">0</span>)&#123;val = n;&#125;</span><br><span class="line">    <span class="function">A &amp; <span class="title">GetObj</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">        <span class="comment">// 填空完成</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a.val&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    a.GetObj() = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a.val&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空缺处代码为：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">A(<span class="keyword">int</span> n=<span class="number">0</span>)&#123;</span><br><span class="line">    val = n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">A &amp; <span class="title">GetObj</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>下面程序的输出是：</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><p>请补足Sample类的成员函数。不能增加成员变量。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sample</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    Sample(<span class="keyword">int</span> n):v(n) &#123; &#125;</span><br><span class="line"><span class="comment">// 在此处补充你的代码</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Sample <span class="title">a</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    Sample b = a;     <span class="comment">// 初始化b，调用复制构造函数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; b.v;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空缺处代码为：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Sample(Sample &amp; o)&#123;</span><br><span class="line">    v = o.v * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>下面程序的输出结果是：</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5,5</span><br><span class="line">5,5</span><br></pre></td></tr></table></figure><p>请填空：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    Base(<span class="keyword">int</span> n):k(n) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Big</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> v; </span><br><span class="line">    Base b;</span><br><span class="line"><span class="comment">// 在此处补充你的代码</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Big <span class="title">a1</span><span class="params">(<span class="number">5</span>)</span></span>; </span><br><span class="line">    Big a2 = a1;              <span class="comment">// 初始化a2，调用复制构造函数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a1.v &lt;&lt; <span class="string">","</span> &lt;&lt; a1.b.k &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a2.v &lt;&lt; <span class="string">","</span> &lt;&lt; a2.b.k &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空缺处代码为：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Big(<span class="keyword">int</span> n):v(n), b(n)&#123;&#125;      <span class="comment">// 初始化列表，对v,b初始化</span></span><br><span class="line"><span class="comment">// 下面这种方法会编译报错，编译器不知道如何对封闭类Big的Base对象b进行初始化</span></span><br><span class="line"><span class="comment">//Big(Big &amp; big)&#123;</span></span><br><span class="line"><span class="comment">//    v = big.v;</span></span><br><span class="line"><span class="comment">//    b = big.b;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure><h2 id="程序设计"><a href="#程序设计" class="headerlink" title="程序设计"></a>程序设计</h2><p>魔兽世界之一：备战</p><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>魔兽世界的西面是红魔军的司令部，东面是蓝魔军的司令部。两个司令部之间是依次排列的若干城市。</p><p>红司令部，City 1，City 2，……，City n，蓝司令部</p><p>两军的司令部都会制造武士。武士一共有 dragon 、ninja、iceman、lion、wolf 五种。每种武士都有编号、生命值、攻击力这三种属性。</p><p>双方的武士编号都是从1开始计算。红方制造出来的第n个武士，编号就是n。同样，蓝方制造出来的第n个武士，编号也是n。武士在刚降生的时候有一个生命值。在每个整点，双方的司令部中各有一个武士降生。</p><p>红方司令部按照iceman、lion、wolf、ninja、dragon的顺序循环制造武士。</p><p>蓝方司令部按照lion、dragon、ninja、iceman、wolf的顺序循环制造武士。</p><p>制造武士需要生命元。</p><p>制造一个初始生命值为m的武士，司令部中的生命元就要减少m个。</p><p>如果司令部中的生命元不足以制造某个按顺序应该制造的武士，那么司令部就试图制造下一个。如果所有武士都不能制造了，则司令部停止制造武士。</p><p>给定一个时间，和双方司令部的初始生命元数目，要求你将从0点0分开始到双方司令部停止制造武士为止的所有事件按顺序输出。</p><p>一共有两种事件，其对应的输出样例如下：</p><p>1) 武士降生</p><p>输出样例： 004 blue lion 5 born with strength 5,2 lion in blue headquarter</p><p>表示在4点整，编号为5的蓝魔lion武士降生，它降生时生命值为5，降生后蓝魔司令部里共有2个lion武士。（为简单起见，不考虑单词的复数形式）注意，每制造出一个新的武士，都要输出此时司令部里共有多少个该种武士。</p><p>2) 司令部停止制造武士</p><p>输出样例： 010 red headquarter stops making warriors</p><p>表示在10点整，红方司令部停止制造武士</p><p>输出事件时：</p><p>首先按时间顺序输出；</p><p>同一时间发生的事件，先输出红司令部的，再输出蓝司令部的。</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>第一行是一个整数，代表测试数据组数。</p><p>每组测试数据共两行。</p><p>第一行：一个整数M。其含义为， 每个司令部一开始都有M个生命元( 1 &lt;= M &lt;= 10000)。</p><p>第二行：五个整数，依次是 dragon 、ninja、iceman、lion、wolf 的初始生命值。它们都大于0小于等于10000。</p><p>例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">20</span><br><span class="line">3 4 5 6 7</span><br></pre></td></tr></table></figure><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>对每组测试数据，要求输出从0时0分开始，到双方司令部都停止制造武士为止的所有事件。</p><p>对每组测试数据，首先输出”Case:n” n是测试数据的编号，从1开始 。</p><p>接下来按恰当的顺序和格式输出所有事件。每个事件都以事件发生的时间开头，时间以小时为单位，有三位。</p><p>例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Case:1</span><br><span class="line">000 red iceman 1 born with strength 5,1 iceman in red headquarter</span><br><span class="line">000 blue lion 1 born with strength 6,1 lion in blue headquarter</span><br><span class="line">001 red lion 2 born with strength 6,1 lion in red headquarter</span><br><span class="line">001 blue dragon 2 born with strength 3,1 dragon in blue headquarter</span><br><span class="line">002 red wolf 3 born with strength 7,1 wolf in red headquarter</span><br><span class="line">002 blue ninja 3 born with strength 4,1 ninja in blue headquarter</span><br><span class="line">003 red headquarter stops making warriors</span><br><span class="line">003 blue iceman 4 born with strength 5,1 iceman in blue headquarter</span><br><span class="line">004 blue headquarter stops making warriors</span><br></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Warrior</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> color;</span><br><span class="line">    <span class="keyword">int</span> HP;</span><br><span class="line">    Warrior(<span class="built_in">string</span> c, <span class="keyword">int</span> i)&#123;</span><br><span class="line">        color = c;</span><br><span class="line">        HP = HPs[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dragon</span>:</span> <span class="keyword">public</span> Warrior&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Dragon(<span class="built_in">string</span> color):warrior(color, <span class="number">0</span>)&#123;&#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ninja</span>:</span> <span class="keyword">public</span> Warrior&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Ninja(<span class="built_in">string</span> color):warrior(color, <span class="number">1</span>)&#123;&#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Iceman</span>:</span> <span class="keyword">public</span> Warrior&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Iceman(<span class="built_in">string</span> color):warrior(color, <span class="number">2</span>)&#123;&#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lion</span>:</span> <span class="keyword">public</span> Warrior&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Lion(<span class="built_in">string</span> color):warrior(color, <span class="number">3</span>)&#123;&#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wolf</span>:</span> <span class="keyword">public</span> Warrior&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Wolf(<span class="built_in">string</span> color):warrior(color, <span class="number">4</span>)&#123;&#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Headquart</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> power;</span><br><span class="line">    <span class="built_in">string</span> color;</span><br><span class="line">    <span class="keyword">int</span> numberOfWarriors;</span><br><span class="line">    <span class="keyword">bool</span> carryOn;</span><br><span class="line">    <span class="keyword">int</span> each[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">int</span> current;</span><br><span class="line">    <span class="keyword">int</span> selectType;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Headquart(<span class="keyword">int</span> p, <span class="built_in">string</span> c)&#123;</span><br><span class="line">        color = c;</span><br><span class="line">        power = p;</span><br><span class="line">        carrayOn = <span class="literal">true</span>;</span><br><span class="line">        numberOfWarriors = <span class="number">0</span>;</span><br><span class="line">        current = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line">            each[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">getCarrayOn</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> carrayOn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">create</span><span class="params">(<span class="built_in">string</span> c)</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;c;</span><br><span class="line">        <span class="keyword">int</span> HPOrder[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( c==<span class="string">"red"</span> )</span><br><span class="line">                HPOrder[i] = HPs[redOrder[i]];</span><br><span class="line">            <span class="keyword">if</span> (c==<span class="string">"blue"</span>)</span><br><span class="line">                HPOrder[i] = HPs[blueOrder[i]];</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span>(power &lt; minHP)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"headquarter stops making warriors"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            carryOn = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(power &gt;= minHP)&#123;</span><br><span class="line">            <span class="keyword">if</span>(power &gt;= HPOrder[current])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(current == <span class="number">4</span>)</span><br><span class="line">                current = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                current++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">"red"</span>)</span><br><span class="line">            select = redOrder[current];</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">"blue"</span>)</span><br><span class="line">            select = blueOrder[current];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">string</span> warriors[<span class="number">5</span>] = &#123; <span class="string">" dragon "</span>,<span class="string">" ninja "</span>,<span class="string">" iceman "</span>,<span class="string">" lion "</span>,<span class="string">" wolf "</span> &#125;;</span><br><span class="line">        <span class="keyword">switch</span>(select)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">new</span> Dragon(c);</span><br><span class="line">                each[<span class="number">0</span>]++;</span><br><span class="line">                power = power - HPs[<span class="number">0</span>];</span><br><span class="line">                <span class="comment">// TODO  这里优化</span></span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Programming Language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 北大课程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>类成员变量</title>
      <link href="/2018/08/21/c++/c-2-1/"/>
      <url>/2018/08/21/c++/c-2-1/</url>
      <content type="html"><![CDATA[<h1 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h1><p>静态成员：在说明前面加了static关键字的成员。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CRectangle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="keyword">int</span> w, h;</span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">int</span> nTotalArea; <span class="comment">//静态成员变量</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">int</span> nTotalNumber;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> CRectangle(<span class="keyword">int</span> w_,<span class="keyword">int</span> h_);</span><br><span class="line">~CRectangle();</span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintTotal</span><span class="params">()</span></span>; <span class="comment">//静态成员函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="静态成员和普通成员区别"><a href="#静态成员和普通成员区别" class="headerlink" title="静态成员和普通成员区别"></a>静态成员和普通成员区别</h2><ul><li>普通成员变量每个对象有各自的一份</li><li>静态成员变量一共就一份，为所有对象共享</li><li>静态成员不需要通过对象就可以访问</li></ul><p>当使用sizeof运算时，不会计算静态成员变量的size，如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyclass</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">sizeof</span>(CMclass);    <span class="comment">// 等于4，不计算静态成员变量的值</span></span><br></pre></td></tr></table></figure><ul><li>普通成员函数必须具体作用于某个对象</li><li>静态成员函数并不具体作用于某个对象</li></ul><p>静态成员变量本质上是全局变量，哪怕一个对象都不存在，类的静态成员变量也存在。相同，静态成员函数本质上是全局函数。设置静态成员这种机制的目的是将和某些类紧密相关的全局变量和函数写到类里面，看上去像一个整体，易于维护和理解。</p><p>例：</p><p>考虑一个需要随时知道矩形总数和总面积的图形处理程序，可以用全局变量来记录总数和总面积，但此时的弊端就是无法直观看出两个全局变量跟矩形类之间的关系，且其他类的全局函数也可以访问这个变量，不安全。</p><p>因此，用静态成员将这两个变量封装进类中，更容易<br>理解和维护。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CRectangle</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> w, h;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> nTotalArea;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> nTotalNumber;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    CRectangle(<span class="keyword">int</span> w_, <span class="keyword">int</span> h_);</span><br><span class="line">    ~CRectangle();</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintTotal</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CRectangle::CRectangle(<span class="keyword">int</span> w_, <span class="keyword">int</span> h_)&#123;</span><br><span class="line">    w = w_;</span><br><span class="line">    h = h_;</span><br><span class="line">    nTotalNumber++;</span><br><span class="line">    nTotalArea += w * h;</span><br><span class="line">&#125;</span><br><span class="line">CRectangle::~CRectangle()&#123;</span><br><span class="line">    nTotalNumber--;</span><br><span class="line">    nTotalArea -= w * h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> CRectangle::PrintTotal()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;nTotalNumber&lt;&lt;<span class="string">","</span>&lt;&lt;nTotalArea&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用的时候，必须在定义类的文件中对静态成员变量进行声明或初始化，否则编译通过但链接不通过。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> CRectangle::nTotalNumber = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> CRectangle::nTotalArea = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CRectangle r1(3, 3), r2(2, 2);</span><br><span class="line">    <span class="comment">// cout&lt;&lt;CRectangle::nTotalNumber;</span></span><br><span class="line">    CRectangle::PrintTotal();</span><br><span class="line">    r1.PrintTotal();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三行代码在外部直接访问类的私有变量，无法通过编译。</p><ul><li>在静态成员函数中，不能访问非静态成员变量，也不能调用非静态成员函数<br>如果在<code>PrintTotal()</code>静态成员函数中<code>cout&lt;&lt;w&lt;&lt;endle</code>时编译错误 </li></ul><p>其输出为：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>,<span class="number">13</span></span><br><span class="line"><span class="number">2</span>,<span class="number">13</span></span><br><span class="line"><span class="number">1</span>,<span class="number">9</span></span><br><span class="line"><span class="number">0</span>,<span class="number">0</span></span><br></pre></td></tr></table></figure><p>上面的CRectangle类写法有很大的缺陷，即忽略了复制构造函数，因为在使用CRectangle类时，有时会调用复制构造函数，生成临时的隐藏CRectangle对象，有两种情况：</p><ul><li>调用一个以CRectangle类对象作为参数的函数时</li><li>调用一个以CRectangle类对象作为返回值的函数时</li></ul><p>临时对象在消亡时会调用析构函数，减少nTotalNumber 和nTotalArea的值，可是这些临时对象在生成时却没有增加nTotalNumber 和 nTotalArea的值。</p><p>解决办法：为CRectangle类写一个复制构造函数。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CRectangle::CRectangle(CRectangle &amp; r )&#123;</span><br><span class="line">    w = r.w; </span><br><span class="line">    h = r.h;</span><br><span class="line">    nTotalNumber ++;</span><br><span class="line">    nTotalArea += w * h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="成员对象和封闭类"><a href="#成员对象和封闭类" class="headerlink" title="成员对象和封闭类"></a>成员对象和封闭类</h1><p>成员对象：一个类的成员变量是另一个类的对象</p><p>封闭类（Enclosing）：包含成员对象的类</p><p>如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTyre</span>&#123;</span>                  <span class="comment">// 轮胎类</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> radius;</span><br><span class="line">    <span class="keyword">int</span> width;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    CTyre(<span class="keyword">int</span> r, <span class="keyword">int</span> w):radius(r), width(w)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CEngine</span>&#123;</span>                <span class="comment">// 引擎类</span></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCar</span>&#123;</span>                  <span class="comment">// 封闭类</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line">    CTyre tyre;          <span class="comment">// 成员对象轮胎</span></span><br><span class="line">    CEngine engine;      <span class="comment">// 成员对象引擎</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    CCar(<span class="keyword">int</span> p, <span class="keyword">int</span> tr, <span class="keyword">int</span> tw);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 初始化列表，初始化tyre</span></span><br><span class="line">CCar::CCar(<span class="keyword">int</span> p, <span class="keyword">int</span> tr, <span class="keyword">int</span> tw):price(p), tyre(tr, tw)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">CCar <span class="title">car</span><span class="params">(<span class="number">20000</span>, <span class="number">17</span>, <span class="number">225</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>CTyre</code>类中，编写构造函数时，使用初始化列表的方式对<code>radius</code>和<code>width</code>进行初始化。使用这样的方式的好处是进行复制的风格更好。</p><p>如果CCar类不定义构造函数，则在执行<code>CCar car</code>时会编译错误，因为编译器不知道<code>car.tyre</code>该如何初始化，但<code>car.engine</code>的初始化没有问题。</p><h2 id="封闭类构造函数"><a href="#封闭类构造函数" class="headerlink" title="封闭类构造函数"></a>封闭类构造函数</h2><p>定义封闭类的构造函数时，添加初始化列表的方法为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">类名::构造函数(参数表):成员变量1(参数表),成员变量2(参数表),...&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成员对象初始化列表中的参数可以是任意复杂的表达式，也可以使函数、变量、表达式中的函数</p><h3 id="构造函数调用顺序"><a href="#构造函数调用顺序" class="headerlink" title="构造函数调用顺序"></a>构造函数调用顺序</h3><p>当封闭类对象生成的时候，类的构造函数的调用顺序为：</p><ol><li>执行所有成员对象的构造函数</li><li>执行封闭类的构造函数</li></ol><p>成员对象的构造函数调用顺序和成员对象在封闭类中的声明顺序一致，和在成员初始化列表中的出现顺序无关。</p><p>当封闭类对象消亡时，类的析构函数调用顺序为：</p><ol><li>执行封闭类的析构函数</li><li>执行成员对象的析构函数</li></ol><p>构造函数和析构函数的调用顺序刚好相反。</p><p>例：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTyre</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    CTyre() &#123; </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"CTyre constructor"</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">        &#125;</span><br><span class="line"> ~CTyre() &#123; </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"CTyre destructor"</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CEngine</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">CEngine() &#123; </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"CEngine constructor"</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">        &#125;</span><br><span class="line">~CEngine() &#123; </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"CEngine destructor"</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCar</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    CEngine engine;</span><br><span class="line">    CTyre tyre;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    CCar()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"CCar constructor"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~CCar()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"CCar destructor"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CCar car;</span><br><span class="line">    reurn <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先执行成员对象的构造函数，根据声明的顺序，分别调用<code>CEngine</code>和<code>CTyre</code>的构造函数，最后执行封闭类<code>CCar</code>封闭类自身的构造函数。析构函数的调用顺序与构造函数调用顺序相反，因此输出为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CEngine constructor</span><br><span class="line">CTyre constructor</span><br><span class="line">CCar constructor</span><br><span class="line">CCar destructor</span><br><span class="line">CTyre destructor</span><br><span class="line">CEngine destructor</span><br></pre></td></tr></table></figure><h1 id="测验"><a href="#测验" class="headerlink" title="测验"></a>测验</h1><ol><li>如果某函数的返回值是个对象，则该函数被调用时，返回的对象</li></ol><ul><li style="list-style: none"><input type="checkbox" checked> 是通过复制构造函数初始化的</li><li style="list-style: none"><input type="checkbox"> 不需要初始化</li><li style="list-style: none"><input type="checkbox"> 是通过无参数的构造函数初始化的</li><li style="list-style: none"><input type="checkbox"> 用哪个构造函数初始化取决于函数中 return 语句是怎么写的</li></ul><ol start="2"><li>以下说法正确的是：</li></ol><ul><li style="list-style: none"><input type="checkbox"> const成员函数不能作用于非 const 对象</li><li style="list-style: none"><input type="checkbox"> 静态成员变量每个对象有各自的一份</li><li style="list-style: none"><input type="checkbox" checked> 在静态成员函数中不能使用 this 指针</li><li style="list-style: none"><input type="checkbox"> 在静态成员函数中可以调用同类的其他任何成员函数const成员函数不能作用于非 const 对象</li></ul>]]></content>
      
      <categories>
          
          <category> Programming Language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 北大课程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>c++类和函数</title>
      <link href="/2018/08/06/c++/c-1-2/"/>
      <url>/2018/08/06/c++/c-1-2/</url>
      <content type="html"><![CDATA[<h1 id="内联函数、重载函数"><a href="#内联函数、重载函数" class="headerlink" title="内联函数、重载函数"></a>内联函数、重载函数</h1><p>在调用一个函数的时候，需要首先要把参数放到栈中， 返回地址也要放到栈中。 这个函数执行完返回以后，要从栈中取出返回地址，再跳转到返回地址去执行。 </p><h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><ul><li>函数调用是有时间开销的。如果函数本身只有几条语句，执行非常快，而且函数被反复执行很多次，相比之下调用函数所产生的这个开销就会显得比较大。</li><li>为了减少函数调用的开销，引入了内联函数机制。编译器处理对内联函数的调用语句时，将整个函数的代码插入到调用语句处，而不会产生调用函数的语句。</li></ul><p>定义内联函数时，在定义前面加上<code>inline</code>关键字。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &gt; b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="内联成员函数"><a href="#内联成员函数" class="headerlink" title="内联成员函数"></a>内联成员函数</h3><p>其定义方式可以为：</p><ul><li><code>inline</code>+成员函数</li><li>在类定义内部定义整个函数体</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>;   <span class="comment">// 第一种方式</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;&#125;;        <span class="comment">// 第二种方式</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> B::func1()&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>一个或多个函数，名字相同，参数个数或参数类型相同，叫做函数的重载。<br>如下面函数为重载函数：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">double</span> f1, <span class="keyword">double</span> f2)</span></span>&#123;&#125;</span><br><span class="line">Max(<span class="number">3.4</span>, <span class="number">2.5</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> n1, <span class="keyword">int</span> n2)</span></span>&#123;&#125;</span><br><span class="line">Max(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> n1, <span class="keyword">int</span> n2, <span class="keyword">int</span> n3)</span></span>&#123;&#125;</span><br><span class="line">Max(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">Max(<span class="number">3</span>, <span class="number">2.4</span>)       <span class="comment">// 编译错误（二义性）</span></span><br></pre></td></tr></table></figure></p><p>其优点是：</p><ul><li>简化函数命名规则</li><li>编译器只需要根据语句中的实参个数和类型判断应调用的函数</li></ul><h3 id="成员函数的重载"><a href="#成员函数的重载" class="headerlink" title="成员函数的重载"></a>成员函数的重载</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Location</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">int</span> y = <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">valueX</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">            x = val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">valueX</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>valueX()</code>为成员函数重载，使用时仍然可以参数缺省。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> Location::init(<span class="keyword">int</span> X, <span class="keyword">int</span> Y)&#123;</span><br><span class="line">    x = X;</span><br><span class="line">    y = Y</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> main()&#123;</span><br><span class="line">    Location A;</span><br><span class="line">    A.init(<span class="number">3</span>);    <span class="comment">// 将x的值初始化为3，y缺省为0</span></span><br><span class="line">    A.valueX(<span class="number">5</span>);  <span class="comment">// 调用赋值接口，将x的值变为5</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;A.valueX();  <span class="comment">// 调用get接口获取x的值，输出5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数缺省"><a href="#函数缺省" class="headerlink" title="函数缺省"></a>函数缺省</h2><p>C++中，定义函数时，可以让<strong>最右边的连续若干个参数</strong>有缺省值，调用函数时，若相应位置不写参数，参数就是缺省值。 如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> x2 = <span class="number">2</span>, <span class="keyword">int</span> x3 = <span class="number">3</span>)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">func(<span class="number">10</span>);                   <span class="comment">// 等效于func(10, 2, 3)</span></span><br><span class="line">func(<span class="number">10</span>, <span class="number">8</span>);                <span class="comment">// 等效于func(10, 8, 3)</span></span><br><span class="line">func(<span class="number">10</span>, , <span class="number">8</span>);              <span class="comment">// 编译错误，缺省参数只能是在最右边的连续参数</span></span><br></pre></td></tr></table></figure><p>其优点为：</p><ul><li>函数参数可缺省的目的在于提高程序的可扩充性。</li><li>如果某个写好的函数要添加新的参数，而原先那些调用该函数的语句，未必需要使用新增的参数，为了避免对原先那些函数调用语句的修改，就可以使用缺省参数。</li></ul><h3 id="成员函数缺省"><a href="#成员函数缺省" class="headerlink" title="成员函数缺省"></a>成员函数缺省</h3><p>使用缺省参数时，需要避免函数重载时的二义性。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Location</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">int</span> y = <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">valueX</span><span class="params">(<span class="keyword">int</span> val = <span class="number">0</span>)</span></span>&#123;</span><br><span class="line">            x = val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">valueX</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用时：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Location A;</span><br><span class="line">    A.valueX();    <span class="comment">// 此时会编译错误，报错为产生二义性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="程序设计方法"><a href="#程序设计方法" class="headerlink" title="程序设计方法"></a>程序设计方法</h1><h2 id="类基础"><a href="#类基础" class="headerlink" title="类基础"></a>类基础</h2><p>类定义变量的过程为实例化。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CRectangle</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> w, h;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> w_, <span class="keyword">int</span> h_)</span></span>&#123;</span><br><span class="line">            w = w_;</span><br><span class="line">            h = h_;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">area</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> w * h;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">perimeter</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span> * (w + h);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;               <span class="comment">// ;必须有</span></span><br></pre></td></tr></table></figure></p><p>对象之间可以用 ‘=’ 进行赋值 ，不能用 ‘==’, ‘!=’, ‘&gt;’, ‘&lt;’, ‘&gt;=’, ‘&lt;=’进行比较 ，除非运算符进行重载</p><h3 id="访问类成员变量"><a href="#访问类成员变量" class="headerlink" title="访问类成员变量"></a>访问类成员变量</h3><ol><li>对象名.成员名</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CRectangle r1, r2;</span><br><span class="line">r1.w = <span class="number">5</span>;            <span class="comment">// 每个对象有各自的存储空间</span></span><br><span class="line">r2.init(<span class="number">3</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li>指针-&gt;成员名</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CRectangle r1, r2;</span><br><span class="line">CRectangle *p1 = &amp; r1;</span><br><span class="line">CRectangle *p2 = &amp; r2;</span><br><span class="line">p1-&gt;w = <span class="number">5</span>;</span><br><span class="line">p2-&gt;inti(<span class="number">3</span>, <span class="number">4</span>);    <span class="comment">// init作用在p2指向的对象上</span></span><br></pre></td></tr></table></figure><ol start="3"><li>引用名.成员名</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CRectangle r2;</span><br><span class="line">CRectangle &amp; rr = r2;</span><br><span class="line">rr.w = <span class="number">5</span>;</span><br><span class="line">rr.init(<span class="number">3</span>, <span class="number">4</span>)     <span class="comment">// /rr的值变了，r2的值也变</span></span><br></pre></td></tr></table></figure><h3 id="类的成员函数"><a href="#类的成员函数" class="headerlink" title="类的成员函数"></a>类的成员函数</h3><p>成员函数体和类的定义可以分开写：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CRectangle</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> w, t;</span><br><span class="line">        <span class="comment">// 成员函数在这里声明</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">area</span><span class="params">()</span></span>; </span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">perimeter</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> w_, <span class="keyword">int</span> h_)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义可以在类外</span></span><br><span class="line"><span class="keyword">int</span> CRectangle::area()&#123;</span><br><span class="line">    <span class="keyword">return</span> w * h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> CRectangle::perimeter()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * (w + h);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> CRectangle::init(<span class="keyword">int</span> w_, <span class="keyword">int</span> h_)&#123;</span><br><span class="line">    w = w_;</span><br><span class="line">    h = h_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类的构造函数"><a href="#类的构造函数" class="headerlink" title="类的构造函数"></a>类的构造函数</h4><p>类的构造函数是成员函数的一种，但需要遵循特殊的规律：</p><ul><li>名字与类名相同，可以有参数，不能有返回值（void也不行）</li><li>其作用是初始化对象，比如给成员变量赋初始值<ul><li>对象生成时自动调用构造函数，对象一旦生成，就无法再执行构造函数</li><li>一个类可以有多个构造函数</li></ul></li><li>如果定义类时未写构造函数，编译器自动生成一个无参数的构造函数，不做任何操作；</li><li>如果定义类时定义了构造函数，编译器不生成无参数构造函数</li></ul><h5 id="构造函数作用"><a href="#构造函数作用" class="headerlink" title="构造函数作用"></a>构造函数作用</h5><ol><li>执行必要的初始化工作 </li><li>有时对象没被初始化就使用，会导致程序出错 </li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    doubel real, imag;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Set</span><span class="params">(<span class="keyword">double</span> r, <span class="keyword">double</span> i)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 编译器自动生成默认构造函数 </span></span><br><span class="line"></span><br><span class="line">Complex c1;                  <span class="comment">// 默认构造函数被调用 </span></span><br><span class="line">Complex *pc = <span class="keyword">new</span> Complex;   <span class="comment">// 默认构造函数被调用</span></span><br></pre></td></tr></table></figure><p>编写构造函数时：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">double</span> real, imag;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Complex(<span class="keyword">double</span> r, <span class="keyword">double</span> i = <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Complex::Complex(<span class="keyword">double</span> r, <span class="keyword">double</span> i)&#123;</span><br><span class="line">    real = r;</span><br><span class="line">    imag = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Complex c1;                 <span class="comment">// error, 缺少构造函数的参数 </span></span><br><span class="line">Complex *pc = <span class="keyword">new</span> Complex;  <span class="comment">// error, 缺少构造函数的参数 </span></span><br><span class="line"></span><br><span class="line"><span class="function">Complex <span class="title">c2</span><span class="params">(<span class="number">2</span>)</span></span>;              <span class="comment">// 构造函数重载</span></span><br><span class="line">Complex c2(2, 4), c3(3, 7);</span><br><span class="line">Complex *pc = <span class="keyword">new</span> Complex(<span class="number">5</span>, <span class="number">9</span>);</span><br></pre></td></tr></table></figure><p>有多个构造函数的情况：多个构造函数重载</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span> </span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">    <span class="keyword">double</span> real, imag; </span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Set</span><span class="params">( <span class="keyword">double</span> r, <span class="keyword">double</span> i )</span></span>;</span><br><span class="line">    Complex(<span class="keyword">double</span> r, <span class="keyword">double</span> i ); </span><br><span class="line">    Complex(<span class="keyword">double</span> r ); </span><br><span class="line">    Complex(Complex c1,  Complex c2);  </span><br><span class="line">&#125;; </span><br><span class="line">Complex::Complex(<span class="keyword">double</span> r, <span class="keyword">double</span> i) &#123;  <span class="comment">// 构造函数1</span></span><br><span class="line">    real = r; </span><br><span class="line">    imag = i; </span><br><span class="line">&#125; </span><br><span class="line">Complex::Complex(<span class="keyword">double</span> r) &#123;   <span class="comment">// 构造函数2</span></span><br><span class="line">    real = r; </span><br><span class="line">    imag = <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line">Complex::Complex (Complex c1,  Complex c2)&#123;  <span class="comment">// 构造函数3</span></span><br><span class="line">    real = c1.real+c2.real; </span><br><span class="line">    imag = c1.imag+c2.imag; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例化时：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">3</span>)</span></span>;         <span class="comment">// 调用构造函数2，整型可以自动转换为double类型</span></span><br><span class="line"><span class="function">Complex <span class="title">c2</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span></span>;      <span class="comment">// 调用构造函数1</span></span><br><span class="line"><span class="function">Complex <span class="title">c3</span><span class="params">(c1, c2)</span></span>;    <span class="comment">// 调用构造函数3</span></span><br></pre></td></tr></table></figure><p>构造函数最好是public的，private构造函数不能直接用来初始化对象。</p><h5 id="构造函数在数组中的使用"><a href="#构造函数在数组中的使用" class="headerlink" title="构造函数在数组中的使用"></a>构造函数在数组中的使用</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CSample</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x; </span><br><span class="line">    <span class="keyword">public</span>:   </span><br><span class="line">    CSample()&#123; </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Constructor 1 Called"</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    CSample(<span class="keyword">int</span> n) &#123; </span><br><span class="line">            x = n; </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Constructor 2 Called"</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">        &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>实例化时：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CSample array1[<span class="number">2</span>];          </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"step1"</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">    </span><br><span class="line">    CSample array2[<span class="number">2</span>] = &#123;<span class="number">4</span>,<span class="number">5</span>&#125;; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"step2"</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">    </span><br><span class="line">    CSample array3[<span class="number">2</span>] = &#123;<span class="number">3</span>&#125;; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"step3"</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">    </span><br><span class="line">    CSample * array4 =  <span class="keyword">new</span> CSample[<span class="number">2</span>]; </span><br><span class="line">    <span class="keyword">delete</span> []array4; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Constructor 1 Called</span><br><span class="line">Constructor 1 Called</span><br><span class="line">step1</span><br><span class="line">Constructor 2 Called</span><br><span class="line">Constructor 2 Called</span><br><span class="line">step2</span><br><span class="line">Constructor 2 Called</span><br><span class="line">Constructor 1 Called</span><br><span class="line">step3</span><br><span class="line">Constructor 1 Called</span><br><span class="line">Constructor 1 Called</span><br></pre></td></tr></table></figure><p>另一个例子：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    Test(<span class="keyword">int</span> n)&#123; &#125;             <span class="comment">// (1)</span></span><br><span class="line">    Test(<span class="keyword">int</span> n, <span class="keyword">int</span> m)&#123; &#125;      <span class="comment">// (2)  </span></span><br><span class="line">    Test()&#123; &#125;                   <span class="comment">// (3) </span></span><br><span class="line">&#125;; </span><br><span class="line">Test array1[<span class="number">3</span>] = &#123;<span class="number">1</span>, Test(<span class="number">1</span>,<span class="number">2</span>)&#125;; </span><br><span class="line"><span class="comment">// 三个元素分别用(1),(2),(3)初始化  </span></span><br><span class="line">Test array2[<span class="number">3</span>] = &#123;Test(<span class="number">2</span>,<span class="number">3</span>), Test(<span class="number">1</span>,<span class="number">2</span>), <span class="number">1</span>&#125;; </span><br><span class="line"><span class="comment">// 三个元素分别用(2),(2),(1)初始化  </span></span><br><span class="line">Test *pArray[<span class="number">3</span>] = &#123;<span class="keyword">new</span> Test(<span class="number">4</span>), <span class="keyword">new</span> Test(<span class="number">1</span>,<span class="number">2</span>)&#125;; </span><br><span class="line"><span class="comment">//两个元素分别用(1),(2) 初始化</span></span><br></pre></td></tr></table></figure><p>第三个定义了一个指针数组，不会引发Test构造函数被调用，因为其每个元素都是指针，并不是对象，因此没有进行实例化。对于这个指针数组，可以不进行初始化操作。当<code>new</code>出来两个对象后，<code>new</code>表达式的返回值为<code>Test *</code>类型的指针。该表达式只生成了两个对象，而不是三个。<code>pArray[2]</code>是一个未经初始化的指针。</p><h4 id="复制构造函数"><a href="#复制构造函数" class="headerlink" title="复制构造函数"></a>复制构造函数</h4><p>复制构造函数（copy constructor）只有一个参数，即对同类对象的<strong>引用</strong>，不能直接为同类的对象。</p><p>形如：</p><p><code>X::X(X &amp;)</code>或<code>X::X(const X &amp;)</code>,二者选一。后者能以常量对象作为参数。</p><p>若未定义复制构造函数，编译器生成默认复制构造函数，默认复制构造函数完成复制功能。</p><p>例：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> real, imag;</span><br><span class="line">&#125;;</span><br><span class="line">Complex c1;             <span class="comment">// 调用缺省无参构造函数</span></span><br><span class="line"><span class="function">Complex <span class="title">c2</span><span class="params">(c1)</span></span>;         <span class="comment">// 调用缺省的复制构造函数，将c2初始化为和c1相同</span></span><br></pre></td></tr></table></figure><p>当定义了复制构造函数之后，编译器不会自动生成复制构造函数。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> real, imag;</span><br><span class="line">    Complex()&#123;&#125;</span><br><span class="line">    Complex(<span class="keyword">const</span> Complex &amp; c)&#123;</span><br><span class="line">        real = c.real;</span><br><span class="line">        imag = c.imag;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Copy constructor called"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Complex c1;          <span class="comment">// 直接调用第一个构造函数</span></span><br><span class="line"><span class="function">Complex <span class="title">c2</span><span class="params">(c1)</span></span>;      <span class="comment">// 初始化c2，调用自定义的复制构造函数</span></span><br></pre></td></tr></table></figure></p><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ol><li>当用一个对象去初始化同类的另一个对象时。</li></ol><p>如上面例子中用c1初始化c2。其中<code>Complex c2 = c1</code>也是初始化语句，等价于<code>Complex c2(c1)</code>，是非赋值语句。</p><ol start="2"><li>如果某函数有一个参数是类 A 的对象，该函数被调用时，类A的复制构造函数被调用</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    A()&#123;&#125;;</span><br><span class="line">    A(A &amp; a)&#123;               <span class="comment">// 自定义的复制构造函数，未进行复制工作</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Copy constructor called"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">(A a1)</span></span>&#123;&#125;           <span class="comment">// 形参a1使用自定义复制构造函数初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a2;</span><br><span class="line">    Func(a2);              <span class="comment">// 调用该函数时，调用A的复制构造函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时的形参a1和实参a2的值可能不相同，因为自定义的复制构造函数没有进行复制工作。当未自定义复制构造函数时，形参a1的值和实参a2的值是相等的，因为编译器自动生成的复制构造函数会进行复制工作。<br>输出结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Copy constructor called</span><br></pre></td></tr></table></figure></p><ol start="3"><li>如果函数的返回值是类A的对象，则函数返回时，A的复制构造函数被调用<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    A(<span class="keyword">int</span> n)&#123;v = n;&#125;</span><br><span class="line">    A(<span class="keyword">const</span> A &amp; a)&#123;</span><br><span class="line">        v = a.v;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Copy constructor called"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">A <span class="title">Func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">b</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;Func().v&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>调用<code>Func()</code>函数时，首先需要生成临时返回值对象，调用复制构造函数，初始化临时返回对象，形参为b，因此输出“Copy constructor called”，且这里复制构造函数对v的值进行了复制操作，因此输出“4”。因此函数的返回值可能和b不是相等的，这取决于复制构造函数的写法。<br>输出结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Copy constructor called</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h4 id="类型转换构造函数"><a href="#类型转换构造函数" class="headerlink" title="类型转换构造函数"></a>类型转换构造函数</h4><p>类型转换构造函数的目的是实现类型的自动转化。<br>特点：</p><ul><li>只有一个参数</li><li>不是复制构造函数</li><li>编译系统自动调用转换构造函数同时创建临时变量</li></ul><p>例：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> real, imag;</span><br><span class="line">    Complex(<span class="keyword">int</span> i)&#123;           <span class="comment">// 类型转换构造函数</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"IntConstructor called"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        real = i;</span><br><span class="line">        imag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Complex(<span class="keyword">double</span> r, <span class="keyword">double</span> i)&#123;  <span class="comment">// 传统构造函数</span></span><br><span class="line">        real = r;</span><br><span class="line">        imag = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">7</span>, <span class="number">8</span>)</span></span>;            <span class="comment">// 调用传统构造函数初始化c1</span></span><br><span class="line">    Complex c2 = <span class="number">12</span>;             <span class="comment">// 初始化c2，调用类型转换构造函数</span></span><br><span class="line">    c1 = <span class="number">9</span>;                      <span class="comment">// 赋值语句，编译器自动调用类型转换构造函数，此时已9作为实参，调用类型转换构造函数，生成临时对象，赋值给c1</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;c1.real&lt;&lt;<span class="string">","</span>&lt;&lt;c1.imag&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IntConstructor called</span><br><span class="line">IntConstructor called</span><br><span class="line">9,0</span><br></pre></td></tr></table></figure></p><h4 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h4><ul><li>析构函数是成员函数的一种</li><li>名字与类名相同，形如<code>~X()</code></li><li>没有参数和返回值</li><li>一个类最多只有一个析构函数</li></ul><p>析构函数在对象消亡时会自动被调用，释放给类分配的对象空间。未定义析构函数时，编译器会自动生成缺省析构函数，但该析构函数不涉及释放用户申请的内存释放等清理工作。当自定义析构函数时，编译器不会生成缺省构造函数。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> * p;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    String()&#123;</span><br><span class="line">        p = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    ~String();</span><br><span class="line">&#125;;</span><br><span class="line">String::~String()&#123;</span><br><span class="line">    <span class="keyword">delete</span> [] p;    <span class="comment">// 自定义析构函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在初始化构造函数时，new了一个char型数组，分配了一个空间。调用析构函数时，需要将new出来的空间delete掉。</p><h5 id="析构函数和数组"><a href="#析构函数和数组" class="headerlink" title="析构函数和数组"></a>析构函数和数组</h5><p>在对象数组生命周期结束时，对象数组的每一个元素的析构函数都会被调用。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ctest</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ~Ctest()&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Destructor called"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Ctest <span class="built_in">array</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"End Main"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在程序结束之前，编译器会调用析构函数，因为是两个对象，因此会执行两次析构函数，最后输出为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">End Main</span><br><span class="line">Destructor called</span><br><span class="line">Destructor called</span><br></pre></td></tr></table></figure></p><h5 id="delete运算符"><a href="#delete运算符" class="headerlink" title="delete运算符"></a>delete运算符</h5><p><code>delete</code>运算符会导致析构函数的调用<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Ctest * pTest;</span><br><span class="line">pTest = <span class="keyword">new</span> Ctest;          <span class="comment">// 构造函数调用</span></span><br><span class="line"><span class="keyword">delete</span> pTest;               <span class="comment">// 析构函数调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组delete运算符</span></span><br><span class="line">pTest = <span class="keyword">new</span> Ctest[<span class="number">3</span>];      <span class="comment">// 构造函数调用3次</span></span><br><span class="line"><span class="keyword">delete</span> [] pTest;           <span class="comment">// 析构函数调用3次</span></span><br></pre></td></tr></table></figure></p><h4 id="构造函数和析构函数调用例子"><a href="#构造函数和析构函数调用例子" class="headerlink" title="构造函数和析构函数调用例子"></a>构造函数和析构函数调用例子</h4><p>定义一个Demo类，并定义构造函数和析构函数。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Demo(<span class="keyword">int</span> i)&#123;</span><br><span class="line">            id = i;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"id="</span>&lt;&lt;id&lt;&lt;<span class="string">"Constructed"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Demo()&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"id="</span>&lt;&lt;id&lt;&lt;<span class="string">"Destructed"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Demo <span class="title">d1</span><span class="params">(<span class="number">1</span>)</span></span>;      <span class="comment">// 定义全局变量Demo对象，调用构造函数初始化输出“id=1 Constructed”</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Demo <span class="title">d2</span><span class="params">(<span class="number">2</span>)</span></span>;            <span class="comment">// 定义静态局部变量，调用构造函数初始化d2，输出“id=2 Constructed”，静态变量消亡是在程序结束时，因此出了Func函数后仍然不会调用d2的析构函数</span></span><br><span class="line">    <span class="function">Demo <span class="title">d3</span><span class="params">(<span class="number">3</span>)</span></span>;                  <span class="comment">// 定义d3局部变量，调用构造函数输出“id=3 Constructed”，在出Func函数，即其作用域时，调用析构函数，输出“id=3 Destructed”</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; “Func” &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Demo <span class="title">d4</span><span class="params">(<span class="number">4</span>)</span></span>;   <span class="comment">// 局部变量Demo对象，调用构造函数初始化输出“id=4 Constructed”</span></span><br><span class="line">    d4 = <span class="number">6</span>;       <span class="comment">// 调用类型转换构造函数，需要生成临时Demo对象，输出“id=6 Constructed”,赋值完成后需要调用析构函数销毁临时Demo对象，因此输出“id=6 Destructed”</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; “main” &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#123; <span class="function">Demo <span class="title">d5</span><span class="params">(<span class="number">5</span>)</span></span>;&#125;  <span class="comment">// 添加自身作用域，表示d5只在作用域中存在，因此需要调用构造函数，输出“id=5 Constructed”，在作用域结束时，调用析构函数，输出“id=5 Destructed”</span></span><br><span class="line">    Func();        <span class="comment">// 进入Func函数中</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; “main ends” &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在main函数结束后，会依次析构局部变量、局部静态变量、全局变量。<br>最终的输出结果为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id=1 Constructed</span><br><span class="line">id=4 Constructed</span><br><span class="line">id=6 Constructed</span><br><span class="line">id=6 Destructed</span><br><span class="line">main</span><br><span class="line">id=5 Constructed</span><br><span class="line">id=5 Destructed</span><br><span class="line">id=2 Constructed</span><br><span class="line">id=3 Constructed</span><br><span class="line">Func</span><br><span class="line">id=3 Destructed</span><br><span class="line">main ends</span><br><span class="line">id=6 Destructed</span><br><span class="line">id=2 Destructed</span><br><span class="line">id=1 Destructed</span><br></pre></td></tr></table></figure></p><h3 id="类成员的访问权限"><a href="#类成员的访问权限" class="headerlink" title="类成员的访问权限"></a>类成员的访问权限</h3><p>通过关键字，可以定义类成员在什么位置允许访问。关键字分为三种：</p><ul><li>private：私有成员，只能在成员函数内被访问到；缺省为私有成员</li><li>public：公有成员，在任意位置可以被访问</li><li>protected：保护成员，在被继承时使用</li></ul><p>根据当前位置的不同，访问到类的成员也不同</p><ul><li>在类成员函数的内部：当前对象的全部属性、函数；同类其他对象的全部属性、函数</li><li>在类的成员函数外部：只能访问该对象的公有成员</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CEmployee</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">char</span> szName[<span class="number">30</span>];</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> salary;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">char</span> *name)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">getName</span><span class="params">(<span class="keyword">char</span> *name)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">averageSalary</span><span class="params">(CEmployee e1, CEmployee e2)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CEmployee::setName(<span class="keyword">char</span> *name)&#123;</span><br><span class="line">    <span class="built_in">strcpy</span>(szName, name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> CEmployee::getName(<span class="keyword">char</span> *name)&#123;</span><br><span class="line">    <span class="built_in">strcpy</span>(name, szName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> CEmployee::averageSalary(CEmployee e1,CEmployee e2)&#123; </span><br><span class="line">    salary = (e1.salary + e2.salary )/<span class="number">2</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">    CEmployee e; </span><br><span class="line">    <span class="built_in">strcpy</span>(e.szName, <span class="string">"Tom1234567889"</span>);  <span class="comment">// 编译错误, 不能访问私有成员</span></span><br><span class="line">    e.setName( <span class="string">"Tom"</span>);                  <span class="comment">// 编译正确</span></span><br><span class="line">    e.salary = <span class="number">5000</span>;                    <span class="comment">// 编译正确 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置私有成员的目的是，强制对成员变量的访问一定要通过成员函数进行，可以将私有成员隐藏起来。 </p><hr><h1 id="第一周作业"><a href="#第一周作业" class="headerlink" title="第一周作业"></a>第一周作业</h1><h2 id="测验"><a href="#测验" class="headerlink" title="测验"></a>测验</h2><ol><li>以下说法正确的是：</li></ol><ul><li style="list-style: none"><input type="checkbox"> 每个对象内部都有成员函数的实现代码</li><li style="list-style: none"><input type="checkbox"> 类的成员函数之间可以互相调用</li><li>[X] 一个类的私有成员函数内部不能访问本类的私有成员变量</li><li style="list-style: none"><input type="checkbox"> 编写一个类时，至少要写一个成员函数</li></ul><ol start="2"><li>以下对类A的定义，哪个是正确的？</li></ol><ul><li style="list-style: none"><input type="checkbox" checked> A</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> v;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">A::<span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">()</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><ul><li style="list-style: none"><input type="checkbox"> B                        // 缺少“；”</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line"><span class="keyword">int</span> v;</span><br><span class="line"><span class="keyword">public</span> : </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li style="list-style: none"><input type="checkbox"> C</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> v;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">A next;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li style="list-style: none"><input type="checkbox"> D</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> v;</span><br><span class="line">A *next;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="3"><li>假设有以下类A:</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123; <span class="keyword">return</span> a * a; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以下程序片段，哪个是不正确的？</p><ul><li style="list-style: none"><input type="checkbox"> <code>A a; A &amp; r = a; r.func(5);</code></li><li style="list-style: none"><input type="checkbox"> <code>A *p = new A; p-&gt;func(5);</code></li><li style="list-style: none"><input type="checkbox"> <code>A a; a.func(5);</code></li><li style="list-style: none"><input type="checkbox" checked> <code>A a, b; if( a!= b ) a.func(5);</code></li></ul><ol start="4"><li>以下程序，哪个是不正确的？</li></ol><ul><li style="list-style: none"><input type="checkbox"> A</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span> </span><br><span class="line">        <span class="keyword">public</span>: </span><br><span class="line">        <span class="keyword">int</span> v; </span><br><span class="line">    &#125;;</span><br><span class="line">A * p = <span class="keyword">new</span> A;</span><br><span class="line">p-&gt;v = <span class="number">4</span>; </span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li style="list-style: none"><input type="checkbox"> B                        // 缺少“；”</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">        <span class="keyword">public</span>: </span><br><span class="line">        <span class="keyword">int</span> v;</span><br><span class="line">        A * p;</span><br><span class="line">    &#125;;</span><br><span class="line">A a; </span><br><span class="line">    a.p = <span class="keyword">new</span> A; </span><br><span class="line">    <span class="keyword">delete</span> a.p;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li style="list-style: none"><input type="checkbox" checked> C</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">        <span class="keyword">public</span>: </span><br><span class="line">        <span class="keyword">int</span> v; </span><br><span class="line">        A * p;</span><br><span class="line">    &#125;;</span><br><span class="line">A a; </span><br><span class="line">    a.p = &amp; a; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li style="list-style: none"><input type="checkbox"> D</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span> <span class="keyword">int</span> v; &#125;;</span><br><span class="line">A a; </span><br><span class="line">    a.v = <span class="number">3</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>以下说法中正确的是：</li></ol><ul><li style="list-style: none"><input type="checkbox"> 构造函数的返回值类型是 void</li><li style="list-style: none"><input type="checkbox"> 一个类只能定义一个构造函数，但可以定义多个析构函数</li><li style="list-style: none"><input type="checkbox" checked> 一个类只能定义一个析构函数，但可以定义多个构造函数</li><li style="list-style: none"><input type="checkbox"> 一个类一定会有无参构造函数构造函数的返回值类型是 void</li></ul><ol start="6"><li>对于通过 new 运算符生成的对象</li></ol><ul><li style="list-style: none"><input type="checkbox"> 在程序结束时自动析构</li><li style="list-style: none"><input type="checkbox" checked> 在执行 delete 操作时会析构，如果没有执行delete操作，则在程序结束时自动析构</li><li style="list-style: none"><input type="checkbox"> 执行 delete 操作时才能析构</li><li style="list-style: none"><input type="checkbox"> 在包含该 new 语句的函数返回时自动析构</li></ul><h2 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>在一个学生信息处理程序中，要求实现一个代表学生的类，并且所有成员变量都应该是私有的。</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>姓名，年龄，学号，第一学年平均成绩，第二学年平均成绩，第三学年平均成绩，第四学年平均成绩。</p><p>其中姓名、学号为字符串，不含空格和逗号；年龄为正整数；成绩为非负整数。</p><p>各部分内容之间均用单个英文逗号”,”隔开，无多余空格。</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>一行，按顺序输出：姓名，年龄，学号，四年平均成绩（向下取整）。</p><p>各部分内容之间均用单个英文逗号”,”隔开，无多余空格。</p><h3 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h3><p>输入：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Tom,18,7817,80,80,90,70</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Tom,18,7817,80</span><br></pre></td></tr></table></figure><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">100</span>], number[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> age, grade1, grade2, grade3, grade4;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Student(<span class="keyword">char</span> pname[], <span class="keyword">int</span> page, <span class="keyword">char</span> pnumber[], <span class="keyword">int</span> pgrade1, <span class="keyword">int</span>  pgrade2, <span class="keyword">int</span> pgrade3, <span class="keyword">int</span> pgrade4)&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(name, pname);</span><br><span class="line">age = page;</span><br><span class="line"><span class="built_in">strcpy</span>(number, pnumber);</span><br><span class="line">grade1 = pgrade1;</span><br><span class="line">grade2 = pgrade2;</span><br><span class="line">grade3 = pgrade3;</span><br><span class="line">grade4 = pgrade4;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getAverageGrade</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((grade1 + grade2 + grade3 + grade4) / <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">getNum</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">100</span>], number[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> age, grade1, grade2, grade3, grade4;</span><br><span class="line"><span class="built_in">cin</span>.getline(name, <span class="number">100</span>, <span class="string">','</span>);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; age;</span><br><span class="line"><span class="keyword">char</span> a = getchar();</span><br><span class="line"><span class="built_in">cin</span>.getline(number, <span class="number">100</span>, <span class="string">','</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; grade1 &gt;&gt; a &gt;&gt; grade2 &gt;&gt; a &gt;&gt; grade3 &gt;&gt; a &gt;&gt; grade4;</span><br><span class="line"><span class="function">Student <span class="title">s</span><span class="params">(name, age, number, grade1, grade2, grade3, grade4)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s.getName() &lt;&lt; <span class="string">","</span> &lt;&lt; s.getAge() &lt;&lt; <span class="string">","</span> &lt;&lt; s.getNum() &lt;&lt; <span class="string">","</span> &lt;&lt; s.getAverageGrade();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Tom,22,2017110,99,98,89,95</span><br><span class="line">Tom,22,2017110,95</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Programming Language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 北大课程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++函数指针、引用、位运算</title>
      <link href="/2018/08/01/c++/c-1-1/"/>
      <url>/2018/08/01/c++/c-1-1/</url>
      <content type="html"><![CDATA[<h1 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>程序运行期间，每个函数都会占用一段连续的内存空间。而函数名就是该函数所占内存区域的起始地址(也称“入口地址”)。 可以将函数的入口地址赋给一个指针变量，使该指针变量指向该函数。然后通过指针变量就可以调用这个函数。这种指向函数的指针变量称为“函数指针”。</p><h2 id="定义形式"><a href="#定义形式" class="headerlink" title="定义形式"></a>定义形式</h2><p><strong>类型名 (* 指针变量名)(参数类型1, 参数类型2,…);</strong><br>如：<code>int (*pf)(int ,char);</code></p><p><code>pf</code>是一个函数指针，它所指向的函数，返回值类型应是<code>int</code>，该函数应有两个参数，第一个是<code>int</code> 类型，第二个是<code>char</code>类型。 </p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>可以用一个原型匹配的函数的名字给一个函数指针赋值。 要通过函数指针调用它所指向的函数，8写法为：<br><strong>函数指针名(实参表); </strong></p><p>例：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintMin</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( a&lt;b ) </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,a); </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,b); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">void</span> (* pf)(<span class="keyword">int</span> ,<span class="keyword">int</span>); </span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">4</span>, y = <span class="number">5</span>; </span><br><span class="line">    pf = PrintMin;   </span><br><span class="line">    pf(x,y); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main函数的输出结果为“4”</p><h3 id="函数指针和qsort库函数"><a href="#函数指针和qsort库函数" class="headerlink" title="函数指针和qsort库函数"></a>函数指针和qsort库函数</h3><p>函数指针的作用举例：C语言中的快排库函数<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">void</span> *base, <span class="keyword">int</span> nelem, unsighed <span class="keyword">int</span> width, </span></span></span><br><span class="line">              int (*pfCompare)(const void *, const void *));</span><br></pre></td></tr></table></figure></p><p>表示可以对任意类型的数组进行排序，其中参数<code>(*pfCompare)(const void *, const void *)</code>为函数指针，其指向的是一个返回类型为<code>int</code>的函数，这个函数有两个参数，类型都为<code>const void *</code>。<br>对数组排序，需要知道</p><table><thead><tr><th style="text-align:center">a[0]</th><th style="text-align:center">a[1]</th><th style="text-align:center">……</th><th style="text-align:center">a[j]</th><th style="text-align:center">……</th><th style="text-align:center">a[n-1]</th></tr></thead><tbody><tr><td style="text-align:center">*base</td><td style="text-align:center">1</td><td style="text-align:center">……</td><td style="text-align:center">j</td><td style="text-align:center">…….</td><td style="text-align:center">n-1</td></tr></tbody></table><ul><li>数组的起始地址</li><li>数组长度</li><li>每个元素的值</li><li>元素排序规则</li></ul><p>调用<code>qsort</code>函数时</p><ul><li>第一个参数 <code>base</code>：待排序数组的起始地址 ；</li><li>第二个参数<code>nelem</code>：待排序数组的元素个数； </li><li>第三个参数<code>width</code>：待排序数组的每个元素的大小（以字节为单位）；</li><li>最后一个参数<code>pfCompare</code>：函数指针，指向比较函数的地址  </li></ul><p>比较函数的作用， 就是告诉qsort，如何去判定两个元素，到底哪一个应该排在前面， 哪一个应该排在后面，所以<code>pfCompare</code>指向比较函数的地址，需要程序猿自己编写。它必须遵循这样一种格式：返回值一定是<code>int</code>，必须有两个类型为<code>const void*</code>的参数。</p><p>排序的过程，实际上就是在不断地比较数组元素，并且交换它们的位置。<code>qsort</code>函数在执行期间要比较两个数组元素时， 会通过<code>pfCompare</code>指针，调用 程序员自己编写的”比较函数“。调用”比较函数“时候，会把待比较的两个元素的地址，作为参数，传递给”比较函数“。 然后<code>qsort</code>根据”比较函数“的执行结果，即返回值， 判断待比较的两个元素的前后顺序。</p><p>当比较a[0]和a[1]两个元素时，<code>pfCompare(e1, e2);</code>比较函数编写规则为：</p><ul><li>如果 <code>* elem1</code>应该排在 <code>* elem2</code>前面，则函数返回值是负整数  </li><li>如果 <code>* elem1</code>和 <code>* elem2</code>哪个排在前面都行，那么函数返回0  </li><li>如果 <code>* elem1</code>应该排在<code>* elem2</code>后面，则函数返回值是正整数  </li></ul><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>下面的程序，功能是调用<code>qsort</code>库函数，将一个<code>unsigned int</code>数组按照个位数从小到大进行排序。比如 8，23，15三个数，按个位数从小到大排序，应该是 23，15，8 。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MyCompare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *elem1, <span class="keyword">const</span> <span class="keyword">void</span> *elem2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> *p1, *p2;</span><br><span class="line">    p1 = (<span class="keyword">unsigned</span> <span class="keyword">int</span> *) elem1;    <span class="comment">//</span></span><br><span class="line">    p2 = (<span class="keyword">unsigned</span> <span class="keyword">int</span> *) elem2;</span><br><span class="line">    <span class="keyword">return</span> (*p1 % <span class="number">10</span>)-(*p2 % <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM 5</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> an[NUM] = &#123; <span class="number">8</span>,<span class="number">123</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">4</span> &#125;; </span><br><span class="line">    qsort(an, NUM, <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>), MyCompare);   </span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>;i &lt; NUM; i ++ ) </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,an[i]); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 11 123 4 8</span><br></pre></td></tr></table></figure></p><p>比较时需要对<code>elem1</code>和<code>elem2</code>进行强制类型转换。因为，<code>elem1</code>是<code>void *指针，如果只写</code><em>elem1<code>，编译器不知道</code>elem1<code>指向的元素到底是多少个字节，因此直接写</code>elem1<code>是非法的。所以需要对</code>elem1<code>进行强制类型转换， 把它强制转换成一个</code>unsigned int </em><code>的指针，再赋值给</code>p1<code>，</code>p1<code>为</code>unsigned int *`类型变量。</p><hr><h1 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h1><h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><p>将用户在CMD窗口输入可执行文件名的方式启动程序时，跟在可执行文件名后面的那些字符串，称为“命令行参数”。命令行参数可以有多个，以空格分隔。<br>在C++中：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span> </span>&#123; </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>argc</strong>：启动程序时，命令行参数的个数。</li></ul><p>C/C++语言规定，可执行程序程序本身的文件名，也算一个命令行参数，因此，argc的值至少是1。 </p><ul><li><strong>argv</strong>：指针数组，其中每个元素都是一个<code>char*</code>类型的指针。指针指向存放命令行参数的字符串。</li></ul><p>例如，argv[0]指向的字符串就是第一个命令行参数，即可执行程序 的文件名，argv[1]指向第二个命令行参数，argv[2]指向第三个命令 行参数……</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; argc; i++)&#123;</span><br><span class="line">        print(<span class="string">"%s\n"</span>, argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子循环遍历了argv数组，该数组共有argc个元素，将每一个元素指向的字符打印出来。每一个元素指向的字符串都是一个命令行参数。当把程序编译为sample.exe，然后在控制台输入：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sample para1 para2 s.txt 9 &quot;hello world&quot;</span><br></pre></td></tr></table></figure></p><p>其打印结果为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sample </span><br><span class="line">para1 </span><br><span class="line">para2 </span><br><span class="line">s.txt </span><br><span class="line">9</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure></p><p>要打印空格时，使用字符串作为参数即可。</p><h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><h2 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h2><p>用于对整数类型（int,char, long 等）变量中的某一位(bit)，或者若干位进行操作。如：</p><ul><li>判断某位是否为1</li><li>只改变其中某位，保持其他不变</li></ul><p>c++中有六种位运算符：</p><table><thead><tr><th style="text-align:center">&amp;</th><th style="text-align:center">\</th><th style="text-align:center"></th><th style="text-align:center">^</th><th style="text-align:center">~</th><th style="text-align:center">&lt;&lt;</th><th>&gt;&gt;</th></tr></thead><tbody><tr><td style="text-align:center">按位与</td><td style="text-align:center">按位或</td><td style="text-align:center">按位异或</td><td style="text-align:center">按位取反</td><td style="text-align:center">左移</td><td style="text-align:center">右移</td></tr><tr><td style="text-align:center">双目</td><td style="text-align:center">双目</td><td style="text-align:center">双目</td><td style="text-align:center">单目</td><td style="text-align:center">双目</td><td style="text-align:center">双目</td></tr></tbody></table><h3 id="按位与“-amp-”"><a href="#按位与“-amp-”" class="headerlink" title="按位与“&amp;”"></a>按位与“&amp;”</h3><p>将参与运算的两操作数各对应的二进制位进行与操作，只有对应的两个二进位均为1时，结果的对 应二进制位才为1，否则为0。 </p><p>例如：表达式“21 &amp; 18 ”的计算结果是16 </p><table><thead><tr><th style="text-align:center">21</th><th style="text-align:center">0000</th><th style="text-align:center">0000</th><th style="text-align:center">0000</th><th style="text-align:center">0000</th><th style="text-align:center">0000</th><th style="text-align:center">0000</th><th style="text-align:center">0001</th><th style="text-align:center">0101</th></tr></thead><tbody><tr><td style="text-align:center">18</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td><td style="text-align:center">0001</td><td style="text-align:center">0010</td></tr><tr><td style="text-align:center">21&amp;18</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td><td style="text-align:center">0001</td><td style="text-align:center">0000</td></tr></tbody></table><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul><li>将某变量中的某些位清0且同时保留其他位不变；</li><li>获取某变量中的某一位</li></ul><ol><li>需要将int型变量n的低8位全置成0，而其余位不变，则可以执行：</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">n = n &amp; <span class="number">0xffffff00</span>;   </span><br><span class="line">n &amp;= <span class="number">0xffffff00</span>;</span><br></pre></td></tr></table></figure><p>若n为short型，执行</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">n &amp;= <span class="number">0xff00</span>;</span><br></pre></td></tr></table></figure><ol start="2"><li>判断一个int型变量n的第七位（从右往左，从0开始数 ）是否为1</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(n &amp; <span class="number">0x80</span>) == <span class="number">0x80</span>;</span><br></pre></td></tr></table></figure><h3 id="按位或“-“"><a href="#按位或“-“" class="headerlink" title="按位或“|“"></a>按位或“|“</h3><p>将参与运算的两操作数各对应的二进制位进行或操作，只有对应的两个二进位都为0时，结果的对应二进制位才是0，否则为1。 </p><p>例如：表达式“21 | 18 ”的计算结果是23<br>| 21 | 0000 | 0000 | 0000 | 0000 | 0000 | 0000 | 0001 | 0101 |<br>| :—: | :–: | :–: | :–: | :-: | :–: | :–: | :–: | :–: |<br>| 18 | 0000 | 0000 | 0000 | 0000 | 0000 | 0000 | 0001 | 0010 |<br>| 21|18 | 0000 | 0000 | 0000 | 0000 | 0000 | 0000 | 0001 | 0111 |</p><h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><ul><li>将某变量中的某些位，置1，且保留其他位不变</li></ul><p>如：需要将int型变量n的低8位全置成1，而其余位不变，则可以执行：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">n |= <span class="number">0xff</span>; </span><br><span class="line"><span class="comment">// 0xff: 1111 1111</span></span><br></pre></td></tr></table></figure><h3 id="按位异或“-”"><a href="#按位异或“-”" class="headerlink" title="按位异或“^”"></a>按位异或“^”</h3><p>将参与运算的两操作数各对应的二进制位进行异或操作，即只有对应的两个二进位不相同时，结果的对应二进制位才是1，否则为0。 </p><p>例如：表达式“21 ^ 18 ”的计算结果是7<br>| 21 | 0000 | 0000 | 0000 | 0000 | 0000 | 0000 | 0001 | 0101 |<br>| :—: | :–: | :–: | :–: | :-: | :–: | :–: | :–: | :–: |<br>| 18 | 0000 | 0000 | 0000 | 0000 | 0000 | 0000 | 0001 | 0010 |<br>| 21^18 | 0000 | 0000 | 0000 | 0000 | 0000 | 0000 | 0000 | 0111 |</p><h4 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h4><ul><li>将某变量中的某些位取反，且保留其他位不变</li></ul><p>如：需要将int型变量n的低8位取反，而其余位不变，则可以执行：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">n ^= <span class="number">0xff</span>; </span><br><span class="line"><span class="comment">// 0xff: 1111 1111</span></span><br></pre></td></tr></table></figure><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li><strong>a^b=c，那么就有 c^b = a以及c^a= b</strong>。</li></ul><p>此规律可以用来进行简单的加密和解密。</p><ul><li>能实现不创建临时变量，就能交换两个变量的值。</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>, b = <span class="number">7</span>;</span><br><span class="line">a = a ^ b;</span><br><span class="line">b = b ^ a;</span><br><span class="line">a = a ^ b;</span><br></pre></td></tr></table></figure><h3 id="按位非“-”"><a href="#按位非“-”" class="headerlink" title="按位非“~”"></a>按位非“~”</h3><p>按位非运算符“~”是单目运算符。其功能是将操作数中的二进制位0变成1，1变成0。</p><p>例如：表达式“~21”的值是整型数 0xffffffea<br>| 21 | 0000 | 0000 | 0000 | 0000 | 0000 | 0000 | 0001 | 0101 |<br>| :—: | :–: | :–: | :–: | :-: | :–: | :–: | :–: | :–: |<br>| ~21 | 1111 | 1111 | 1111 | 1111 | 1111 | 1111 | 1110 | 1010 |</p><h3 id="左移运算符“-lt-lt-”"><a href="#左移运算符“-lt-lt-”" class="headerlink" title="左移运算符“&lt;&lt;”"></a>左移运算符“&lt;&lt;”</h3><p>表达式： a &lt;&lt; b 的值是：将a各二进位全部左移b位后得到的值。左移时，高位丢弃，低位补0。a 的值不因运算而改变。</p><p>例如:  9 &lt;&lt; 4  结果为144<br>| 9 | 0000 | 0000 | 0000 | 0000 | 0000 | 0000 | 0001 | 1001 |<br>| :—: | :–: | :–: | :–: | :-: | :–: | :–: | :–: | :–: |<br>| 9&lt;&lt;4 | 0000 | 0000 | 0000 | 0000 | 0000 | 0001 | 1001 | 0000 |</p><p>实际上，m左移1位，就等于 $m\times 2 $，左移n位，就相当于$m\times 2^{n}$。而左移操作比乘法操作快得多。</p><h3 id="右移运算符“-gt-gt-”"><a href="#右移运算符“-gt-gt-”" class="headerlink" title="右移运算符“&gt;&gt;”"></a>右移运算符“&gt;&gt;”</h3><p>表达式：a &gt;&gt; b 的值是：将a各二进位全部右移b位后得到的值。右移时，移出最右边的位就被丢弃。 a 的值不因运算而改变。 </p><p>对于有符号数，如long,int,short,char类型变量，在右移时，符号位（即最高位）将一起移动，并且大多数C/C++编译器规定，如果原符号位为1，则右移时高位就补充1，原符号位为0，则右移时高位就补充0。 </p><p>例如：-25 &gt;&gt; 4 = -2  、-2 &gt;&gt; 4 = -1  、18 &gt;&gt; 4 =  1  </p><table><thead><tr><th style="text-align:center">-25</th><th style="text-align:center">1111</th><th style="text-align:center">1111</th><th style="text-align:center">1111</th><th style="text-align:center">1111</th><th style="text-align:center">1111</th><th style="text-align:center">1111</th><th style="text-align:center">1110</th><th style="text-align:center">0111</th></tr></thead><tbody><tr><td style="text-align:center">-25 &gt;&gt; 4</td><td style="text-align:center">1111</td><td style="text-align:center">1111</td><td style="text-align:center">1111</td><td style="text-align:center">1111</td><td style="text-align:center">1111</td><td style="text-align:center">1111</td><td style="text-align:center">1111</td><td style="text-align:center">1110</td></tr></tbody></table><h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n1 = <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">short</span> n2 = <span class="number">-15</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> n3 = <span class="number">0xffe0</span>;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="number">15</span>;</span><br><span class="line">    n1 = n1&gt;&gt;<span class="number">2</span>;</span><br><span class="line">    n2 &gt;&gt;= <span class="number">3</span>;</span><br><span class="line">    n3 &gt;&gt;= <span class="number">4</span>;</span><br><span class="line">    c &gt;&gt;= <span class="number">3</span>;</span><br><span class="line">    print(<span class="string">"n1 = %d, n2 = %d, n3 = %d, c = %x"</span>, n1, n2, n3, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>=<span class="number">3</span>, n2=fffffffe, n3=ffe, c=<span class="number">1</span></span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">n1</th><th style="text-align:center">0000</th><th style="text-align:center">0000</th><th style="text-align:center">0000</th><th style="text-align:center">0000</th><th style="text-align:center">0000</th><th style="text-align:center">0000</th><th style="text-align:center">0000</th><th style="text-align:center">1111</th></tr></thead><tbody><tr><td style="text-align:center">n1&gt;&gt;2</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td><td style="text-align:center">0011</td></tr><tr><td style="text-align:center">n2</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">1111</td><td style="text-align:center">1111</td><td style="text-align:center">1111</td><td style="text-align:center">0001</td></tr><tr><td style="text-align:center">n2&gt;&gt;3</td><td style="text-align:center">fffffffe</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">1111</td><td style="text-align:center">1111</td><td style="text-align:center">1111</td><td style="text-align:center">1110</td></tr><tr><td style="text-align:center">n3</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">1111</td><td style="text-align:center">1111</td><td style="text-align:center">1110</td><td style="text-align:center">0000</td></tr><tr><td style="text-align:center">n3&gt;&gt;4</td><td style="text-align:center">ffe</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">1111</td><td style="text-align:center">1111</td><td style="text-align:center">1111</td><td style="text-align:center">1110</td></tr><tr><td style="text-align:center">c</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">0000</td><td style="text-align:center">1111</td></tr><tr><td style="text-align:center">c&gt;&gt;3</td><td style="text-align:center">1</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">0000</td><td style="text-align:center">0001</td></tr></tbody></table><h2 id="编程题目"><a href="#编程题目" class="headerlink" title="编程题目"></a>编程题目</h2><p>题目：有两个int型的变量a和n(0 &lt;= n &lt;= 31)，要求写一个表达式，使该表达式的值和a的第n位相同。</p><p>答案一：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(a &gt;&gt; n) &amp; 1</span><br></pre></td></tr></table></figure><p>分析：<br>| a | $b_{31}$ | $b_{30}$ | …… | $b_{n}$ | …… | $b_{0}$ |<br>| :—: | :–: | :–: | :–: | :-: | :–: | :–: |<br>| a&gt;&gt;n | $b_{31}$ | $b_{31}$ | …… | $b_{i}$ | …… | $b_{n}$ |<br>| (a&gt;&gt;n) &amp; 1 | 0 | 0 | …… | 0 | …… | $b_{n}$ |</p><p>答案二：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(a  &amp;  (<span class="number">1</span> &lt;&lt; n )) &gt;&gt; n</span><br></pre></td></tr></table></figure><hr><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><h2 id="基本概念-3"><a href="#基本概念-3" class="headerlink" title="基本概念"></a>基本概念</h2><p>下面的写法定义了一个引用，并将其初始化为引用某个变量。 </p><p><center> 类型名 &amp; 引用名 = 某变量名; </center></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">4</span>; </span><br><span class="line"><span class="keyword">int</span> &amp; r = n;  <span class="comment">// r引用了 n, r的类型是 int &amp;</span></span><br></pre></td></tr></table></figure><p>某个变量的引用，等价于这个变量，相当于该变量的一个别名 。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">7</span>; </span><br><span class="line"><span class="keyword">int</span> &amp; r = n; </span><br><span class="line">r = <span class="number">4</span>; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; r;  <span class="comment">//输出 4 </span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; n; <span class="comment">//输出 4 </span></span><br><span class="line">n = <span class="number">5</span>; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; r;  <span class="comment">//输出5</span></span><br></pre></td></tr></table></figure><ul><li>定义引用时一定要将其初始化成引用某个变量；</li><li>初始化后，它就一直引用该变量，不会再引用别的变量了；</li><li>引用只能引用变量，不能引用常量和表达式。 </li></ul><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h4 id="交换两个整型变量值的函数"><a href="#交换两个整型变量值的函数" class="headerlink" title="交换两个整型变量值的函数"></a>交换两个整型变量值的函数</h4><p>在C语言中：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> * a, <span class="keyword">int</span> * b)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> tmp; </span><br><span class="line">    tmp = * a;</span><br><span class="line">    * a = * b;</span><br><span class="line">    * b = tmp; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n1, n2;</span><br><span class="line">    swap(&amp; n1, &amp; n2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// n1,n2的值被交换</span></span><br></pre></td></tr></table></figure><p>在C++中使用引用：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp; a, <span class="keyword">int</span> &amp; b)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> tmp; </span><br><span class="line">    tmp = a; </span><br><span class="line">    a = b; </span><br><span class="line">    b = tmp; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n1, n2;</span><br><span class="line">    swap(n1, n2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// n1,n2的值被交换</span></span><br></pre></td></tr></table></figure><h4 id="引用作为函数的返回值"><a href="#引用作为函数的返回值" class="headerlink" title="引用作为函数的返回值"></a>引用作为函数的返回值</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">4</span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> &amp; <span class="title">SetValue</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> n; &#125;   <span class="comment">// 函数的返回值为引用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">    SetValue() = <span class="number">40</span>; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; n;                  <span class="comment">// 输出40</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时可以对一个函数的返回结果赋值。</p><h4 id="常引用"><a href="#常引用" class="headerlink" title="常引用"></a>常引用</h4><p>定义引用时，前面加const关键字，即为“常引用” </p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp; r = n; </span><br><span class="line"><span class="comment">// r的类型为 const int &amp;</span></span><br></pre></td></tr></table></figure><ul><li>不能通过常引用修改其引用的内容:  </li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int n = 100; </span><br><span class="line">const int &amp; r = n; </span><br><span class="line">r = 200;   //编译错误 </span><br><span class="line">n = 300;  // 正常运行</span><br></pre></td></tr></table></figure><ul><li>常引用和非常引用的转换<ul><li><code>const T &amp;</code> 和<code>T &amp;</code>是不同的类型 </li><li><code>T &amp;</code>类型的引用或<code>T</code>类型的变量可以用来初始化<code>const T &amp;</code>类型的引用</li><li><code>const T</code>类型的常变量和<code>const T &amp;</code>类型的引用则不能用来初始化<code>T &amp;</code>类型的引用，除非进行强制类型 转换。</li></ul></li></ul><h1 id="const关键字和常量"><a href="#const关键字和常量" class="headerlink" title="const关键字和常量"></a>const关键字和常量</h1><h2 id="const用法"><a href="#const用法" class="headerlink" title="const用法"></a>const用法</h2><ol><li>定义常量</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> intMAX_VAL= <span class="number">23</span>； </span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> SCHOOL_NAME= “Peking University” ；</span><br></pre></td></tr></table></figure><ol start="2"><li>定义常量指针</li></ol><ul><li><p>不能通过常量指针修改其指向的内容。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = &amp; n;</span><br><span class="line">*p = <span class="number">5</span>;   <span class="comment">// 编译出错</span></span><br><span class="line">n = <span class="number">4</span>;    <span class="comment">// 正确</span></span><br><span class="line">p = &amp; m;  <span class="comment">// 常量指针的指向可以发生改变</span></span><br></pre></td></tr></table></figure></li><li><p>不能把常量指针赋值给非常量指针，反过来可以</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * p1;</span><br><span class="line"><span class="keyword">int</span> * p2;</span><br><span class="line">p1 = p2;        <span class="comment">// 编译正确</span></span><br><span class="line">p2 = p1;        <span class="comment">// 编译错误</span></span><br><span class="line">p2 = (<span class="keyword">int</span> *)p1; <span class="comment">// 编译正确，const强制类型转换</span></span><br></pre></td></tr></table></figure></li><li><p>函数参数为常量指针时，可以避免函数内部不小心改变参数所指地方的内容</p></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyPrinf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *p)</span></span>&#123;</span><br><span class="line">    <span class="built_in">strcpy</span>(p, <span class="string">"this"</span>);   <span class="comment">// 编译错误</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>, p);     <span class="comment">// 编译正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>strcpy</code>函数第一个参数类型为<code>char＊</code>。参数<code>p</code>的类型是<code>const char＊</code>。 不能用<code>const char＊</code>类型的指针给<code>char＊</code>类型的指针赋值。所以<code>p</code>的类型跟<code>char＊</code>不匹配的，编译出错。 因此它就可以避免在函数内部不小心写出了能改变参数指针所指向的地方的内容。</p><ol start="3"><li>定义常引用</li></ol><p>不能通过常引用修改其引用的变量</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp; r = n;</span><br><span class="line">r = <span class="number">5</span>;                <span class="comment">// 编译错误</span></span><br><span class="line">n = <span class="number">4</span>;                <span class="comment">// 编译正确</span></span><br></pre></td></tr></table></figure><hr><h1 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h1><h2 id="new运算符"><a href="#new运算符" class="headerlink" title="new运算符"></a>new运算符</h2><h3 id="new分配变量"><a href="#new分配变量" class="headerlink" title="new分配变量"></a>new分配变量</h3><p><center><strong>P = new T;</strong></center><br><code>T</code>是任意类型名，<code>P</code>是类型为<code>T *</code>的指针。 动态分配出一片大小为<code>sizeof(T)</code>字节的内存空间，并且将该内存空间的起始地址赋值给P。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *pn;</span><br><span class="line">pn = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">*pn = <span class="number">5</span>;</span><br></pre></td></tr></table></figure></p><h3 id="new分配数组"><a href="#new分配数组" class="headerlink" title="new分配数组"></a>new分配数组</h3><p><center><strong>p = new T[N];</strong></center><br><code>T</code>是任意类型名，<code>P</code>是类型为<code>T *</code>的指针，<code>N</code>为要分配的数组元素的个数，可以是整型表达式。<br>动态分配一片大小为<code>sizeof(T)</code>子节的内存空间，并将该内存空间的起始地址赋值给<code>P</code>。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *pn;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">pn = <span class="keyword">new</span> <span class="keyword">int</span>[i * <span class="number">20</span>];</span><br><span class="line">pn[<span class="number">0</span>] = <span class="number">20</span>;</span><br><span class="line">pn[<span class="number">100</span>] = <span class="number">30</span>;             <span class="comment">// 编译正确，运行时数组越界</span></span><br></pre></td></tr></table></figure><h2 id="delete释放动态分配的内存"><a href="#delete释放动态分配的内存" class="headerlink" title="delete释放动态分配的内存"></a>delete释放动态分配的内存</h2><h3 id="delete释放变量"><a href="#delete释放变量" class="headerlink" title="delete释放变量"></a>delete释放变量</h3><p><code>new</code>动态分配的内存空间，一定要用 <code>delete</code>运算符进行释放 。<code>delete</code> 指针必须指向<code>new</code>出来的空间。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">*p = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="keyword">delete</span> p;             <span class="comment">// 导致异常，一片空间不能被多次delete</span></span><br></pre></td></tr></table></figure><h3 id="delete释放数组"><a href="#delete释放数组" class="headerlink" title="delete释放数组"></a>delete释放数组</h3><p>用<code>delete</code>释放动态分配的数组，要加<code>[]</code>。<code>delete []</code>指针必须指向<code>new</code>出来的数组。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20</span>];</span><br><span class="line">p[<span class="number">0</span>] = <span class="number">1</span>; </span><br><span class="line"><span class="keyword">delete</span> [ ] p;</span><br></pre></td></tr></table></figure><h1 id="位运算测试"><a href="#位运算测试" class="headerlink" title="位运算测试"></a>位运算测试</h1><ol><li><code>printf(&quot;%d\n&quot;, 34 &amp; 27);</code>的输出结果是：2（按位与）</li></ol><table><thead><tr><th style="text-align:center">34</th><th style="text-align:center">0000</th><th style="text-align:center">0000</th><th style="text-align:center">0000</th><th style="text-align:center">0000</th><th style="text-align:center">0000</th><th style="text-align:center">0000</th><th style="text-align:center">0010</th><th style="text-align:center">0010</th></tr></thead><tbody><tr><td style="text-align:center">27</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td><td style="text-align:center">0001</td><td style="text-align:center">1011</td></tr><tr><td style="text-align:center">34&amp;27</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td><td style="text-align:center">0010</td></tr></tbody></table><ol start="2"><li><code>printf(&quot;%x\n&quot;,-12 &gt;&gt; 2 );</code>的输出结果是：fffffffd（右移）</li></ol><table><thead><tr><th style="text-align:center">-12</th><th style="text-align:center">1111</th><th style="text-align:center">1111</th><th style="text-align:center">1111</th><th style="text-align:center">1111</th><th style="text-align:center">1111</th><th style="text-align:center">1111</th><th style="text-align:center">1111</th><th style="text-align:center">0100</th></tr></thead><tbody><tr><td style="text-align:center">-12&gt;&gt;2</td><td style="text-align:center">1111</td><td style="text-align:center">1111</td><td style="text-align:center">1111</td><td style="text-align:center">1111</td><td style="text-align:center">1111</td><td style="text-align:center">1111</td><td style="text-align:center">1111</td><td style="text-align:center">1101</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">f</td><td style="text-align:center">f</td><td style="text-align:center">f</td><td style="text-align:center">f</td><td style="text-align:center">f</td><td style="text-align:center">f</td><td style="text-align:center">f</td><td style="text-align:center">d</td></tr></tbody></table><ol start="3"><li><code>printf(&quot;%d\n&quot;,26 | 14);</code>的输出结果是：30（按位或）</li></ol><table><thead><tr><th style="text-align:center">27</th><th style="text-align:center">0000</th><th style="text-align:center">0000</th><th style="text-align:center">0000</th><th style="text-align:center">0000</th><th style="text-align:center">0000</th><th style="text-align:center">0000</th><th style="text-align:center">0001</th><th style="text-align:center">1010</th></tr></thead><tbody><tr><td style="text-align:center">14</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td><td style="text-align:center">1110</td></tr><tr><td style="text-align:center">26\</td><td style="text-align:center">14</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td><td style="text-align:center">0001</td><td>1110</td></tr></tbody></table><ol start="4"><li><code>printf(&quot;%d\n&quot;,18 ^ 22);</code>的输出结果是：4（按位异或）</li></ol><table><thead><tr><th style="text-align:center">18</th><th style="text-align:center">0000</th><th style="text-align:center">0000</th><th style="text-align:center">0000</th><th style="text-align:center">0000</th><th style="text-align:center">0000</th><th style="text-align:center">0000</th><th style="text-align:center">0001</th><th style="text-align:center">0010</th></tr></thead><tbody><tr><td style="text-align:center">22</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td><td style="text-align:center">0001</td><td style="text-align:center">0110</td></tr><tr><td style="text-align:center">18^22</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td><td style="text-align:center">0100</td></tr></tbody></table><ol start="5"><li><code>int * p = new int[12];</code>动态分配了多少字节的空间？</li></ol><p>48; int为4字节，new了一个int数组，长度为12</p><ol start="6"><li>下面程序段：</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> a = <span class="number">3</span>, b = <span class="number">5</span>;</span><br><span class="line">   <span class="keyword">int</span> &amp; r = a;</span><br><span class="line">   r = b;             <span class="comment">// a = b = 5</span></span><br><span class="line">   b = <span class="number">7</span>;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其输出结果是：5</p><ol start="7"><li>以下说法正确的是：</li></ol><ul><li style="list-style: none"><input type="checkbox" checked> 类的成员函数之间可以互相调用 </li><li style="list-style: none"><input type="checkbox"> 每个对象内部都有成员函数的实现代码</li><li style="list-style: none"><input type="checkbox"> 一个类的私有成员函数内部不能访问本类的私有成员变量</li><li style="list-style: none"><input type="checkbox"> 编写一个类时，至少要写一个成员函数 </li></ul><ol start="8"><li>以下对类A的定义，哪个是正确的？</li></ol><ul><li><p>[ ] A</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    A *next;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>[ ] B            缺少“；”</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">        <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>[X] C</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">A::<span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>[ ] D</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        A next;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><ol start="9"><li>假设有以下类A:</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;<span class="keyword">return</span> a * a;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以下程序片段，哪个是不正确的？</p><ul><li style="list-style: none"><input type="checkbox" checked> <code>A a,b; if( a != b) a.func(5);</code></li><li style="list-style: none"><input type="checkbox"> <code>A a; a.func(5);</code></li><li style="list-style: none"><input type="checkbox"> <code>A * p = new A; p-&gt;func(5);</code></li><li style="list-style: none"><input type="checkbox"> <code>A a; A &amp; r = a; r.func(5);</code></li></ul>]]></content>
      
      <categories>
          
          <category> Programming Language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 北大课程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>R-CNN目标检测方法</title>
      <link href="/2018/07/26/computer_version/R-CNN/"/>
      <url>/2018/07/26/computer_version/R-CNN/</url>
      <content type="html"><![CDATA[<h1 id="物体检测R-CNN介绍"><a href="#物体检测R-CNN介绍" class="headerlink" title="物体检测R-CNN介绍"></a>物体检测R-CNN介绍</h1><h2 id="R-CNN"><a href="#R-CNN" class="headerlink" title="R-CNN"></a>R-CNN</h2><p>R-CNN的贡献主要是第一次将CNN引入到目标检测中，主要解决两个问题：</p><ul><li>速度：经典的目标检测算法使用滑动窗法依次判断所有可能的区域。R-CNN则预先提取一系列较可能是物体的候选区域，之后仅在这些候选区域上提取特征，进行判断。</li><li>训练集：经典的目标检测算法在区域中提取人工设定的特征（Haar，HOG）。R-CNN则需要训练CNN进行特征提取。可供使用的有两个数据库：<ul><li>一个较大的识别库（ImageNet ILSVC 2012）：标定每张图片中物体的类别。一千万图像，1000类。 </li><li>一个较小的检测库（PASCAL VOC 2007）：标定每张图片中，物体的类别和位置。一万图像，20类。</li></ul></li></ul><h3 id="检测过程"><a href="#检测过程" class="headerlink" title="检测过程"></a>检测过程</h3><p>R-CNN的检测过程主要分为四个步骤：</p><ul><li>使用<strong>Selective Search</strong>方法，每张图片生成1K~2K个RoI；</li><li>对每个RoI使用<strong>CNN</strong>提取特征；</li><li>将feature vector 送入<strong>SVM</strong>二分类器中，判断是否属于该类；</li><li>bounding-box regression精细修正RoI位置。</li></ul><p>其整体识别流程如下图所示：<br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/computerVersion/83769262.jpg" alt="R-CNN" title="R-CNN" width="75%/"></p><h4 id="Selective-Search"><a href="#Selective-Search" class="headerlink" title="Selective Search"></a>Selective Search</h4><p>选择性搜索是一种用于目标检测的区域推荐算法。它的设计速度快，召回率高。它是根据颜色、纹理、大小和形状的兼容性，计算相似区域的层次分组。 </p><h5 id="候选区"><a href="#候选区" class="headerlink" title="候选区"></a>候选区</h5><ul><li>使用一种分割手段，将图像分割成小区域 </li><li>查看现有小区域，合并可能性最高的两个区域。重复直到整张图像合并成一个区域位置 </li><li>输出所有曾经存在过的区域，所谓候选区域 </li><li>候选区域生成和后续步骤相对独立，实际可以使用任意算法进行。</li></ul><h5 id="合并规则（优先合并以下四种区域）"><a href="#合并规则（优先合并以下四种区域）" class="headerlink" title="合并规则（优先合并以下四种区域）"></a>合并规则（优先合并以下四种区域）</h5><ul><li>颜色（颜色直方图）相近的 </li><li>纹理（梯度直方图）相近的 </li><li>合并后总面积小的 </li><li>合并后，总面积在其BBOX中所占比例大的</li></ul><h5 id="多样化和后处理"><a href="#多样化和后处理" class="headerlink" title="多样化和后处理"></a>多样化和后处理</h5><p>为尽可能不遗漏候选区域，上述操作在多个颜色空间中同时进行（RGB,HSV,Lab等）。在一个颜色空间中，使用上述四条规则的不同组合进行合并。所有颜色空间与所有规则的全部结果，在去除重复后，都作为候选区域输出。</p><h4 id="特征提取"><a href="#特征提取" class="headerlink" title="特征提取"></a>特征提取</h4><h5 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h5><p>将每个region都wrap到固定的大小（227×227） 。此处scale时需要注意：外扩的尺寸大小，形变时是否保持原比例，对框外区域直接截取还是补灰 。</p><h5 id="CNN"><a href="#CNN" class="headerlink" title="CNN"></a>CNN</h5><p>将所有变形后的region输入到CNN中，网络结构为Hinton 2012年在Image Net上的分类网络AlexNet，其网络结构为：<br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/computerVersion/66806389.jpg" alt="AlexNet" title="AlexNet" width="75%"></p><p>AlexNet使用了两块GPU训练神经网络。此网络提取的特征为4096维，之后送入一个4096-&gt;1000的全连接(fc)层进行分类。  学习率0.01。<br>训练的过程分为两步：</p><ul><li><strong>pre-training</strong> 使用ILSVRC 2012的数据集进行有监督的分类训练（迁移训练），初步训练出CNN每层的参数，输出1000维类别标号；</li><li><strong>fine-tuning</strong> 使用PASCAL VOC2007数据集，将第2步训练出来的CNN模型替换最后一层，变为N+1个输出，采用SGD方法训练最后一层参数。</li></ul><h5 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h5><p>对每一类目标，使用一个线性SVM二类分类器进行判别。输入为深度网络输出的4096维特征，输出是否属于此类。<br>由于负样本很多，使用hard negative mining方法。 样本判别方法为：</p><ul><li>正样本：本类的真实值</li><li>负样本：考察每一个候选框，如果和本类所有标定框的重叠都小于0.3，认定其为负样本。</li></ul><h5 id="regression"><a href="#regression" class="headerlink" title="regression"></a>regression</h5><ol><li>目标检测问题的识别精度为：<strong>mAP</strong>（mean average precision）</li></ol><ul><li><strong>precision</strong>：对于某张图片计算object C在图片上的查准率<ul><li>某图片上C识别正确的个数/ 某图片C的总个数</li><li>$precision_{c} = N(TruePositives)<em>{c} / N(TotalObjects)</em>{c}$</li></ul></li><li><strong>average precision</strong>：对于object C在多张图片上的查准率<ul><li>每张图片的precisionc的和 / 含有object C的图片的数目</li><li>$averagePrecision_{c} = sum(precision_{c}) / N(TotalImages)_{c}$</li></ul></li><li><strong>mean average precision</strong>:对整个数据集的多个object的平均查准率<ul><li>每个objectc的average precision / 总的object数目</li><li>$meanAveragePrecision = sum(averagePrecision_{c}) / N(classcs)$</li></ul></li></ul><ol start="2"><li>目标检测定位精度：<strong>IoU</strong>（intersection over union ）</li></ol><ul><li>检测结果（detection result）和真实值（ground truth）的交集 / 其并集</li><li>IoU = (GT∩DR) / (GT∪DR) </li></ul><ol start="3"><li>机器学习中的评价指标：<strong>accuracy、precision、recall </strong></li></ol><ul><li>TP（true positive）正样本中预测为正样本        正确预测为正样本</li><li>FP（false positive）负样本中预测为正样本       错误预测为正样本</li><li>FN（false negative）正样本中预测为负样本     错误预测为负样本</li><li>TN（true negative）负样本中预测为负样本      正确预测为负样本 </li></ul><p>accuracy：预测正确的样本数                                       accuracy = (TP + TN) / (TP + FP + FN + TN) </p><p>precision：预测为正的样本中，正确预测的比例        precision = TP / (TP + FP) </p><p>recall：正样本中，正确预测的比例                              recall = TP / (TP + FN)   </p><p>F1: precision和recall的综合指标                                  F1 = 2×(precision / (precision + recall)) </p><ol start="4"><li>回归器</li></ol><p>在R-CNN中，对每一类目标，使用一个线性脊回归器进行精修。正则项$\lambda=10000$。  输入为深度网络pool5层的4096维特征，输出为xy方向的缩放和平移。  判定为本类的候选框中，和真值重叠面积大于0.6的候选框为正样本。</p><h3 id="优缺点分析"><a href="#优缺点分析" class="headerlink" title="优缺点分析"></a>优缺点分析</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>首次使用CNN进行特征提取</li><li>使用bounding box regression进行目标包围框的修改 </li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>selective search算法较为耗时，每帧图像需要2s处理时间</li><li>CNN前向传播较为耗时，对每一个RoI（region of interest）都需要输入AlexNet提取特征</li><li>三个步骤分别训练，消耗存储空间 </li></ul>]]></content>
      
      <categories>
          
          <category> Computer Version </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CV </tag>
            
            <tag> object detection </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>图像分割</title>
      <link href="/2018/07/22/computer_version/imgSegmentation/"/>
      <url>/2018/07/22/computer_version/imgSegmentation/</url>
      <content type="html"><![CDATA[<h1 id="图像分割"><a href="#图像分割" class="headerlink" title="图像分割"></a><center>图像分割</center></h1><p>图像分割就是预测图像中每一个像素所属的类别或者物体。图像分割有两个子问题，一个是只预测类别层面的分割，对每个像素标出一个位置。第二个是区分不同物体的个体。应用场景，比如自动驾驶，3D 地图重建，美化图片，人脸建模等等。<br>传统的图像分割通常和图像分类结合，它是图像识别的第一阶段。<br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/computerVersion/60398275.jpg" title="图像识别流程" alt="图像识别流程" width="80%"></p><p>图像分割难点：</p><ul><li>噪声影响</li><li>无法控制环境</li><li>没有一致的标准</li><li>没有足够的检测数据</li><li>存在病态问题</li></ul><p>当图像背景中存在与前景目标相 同或相似区域时，没有用户的交互，自动分割出感兴趣的前景目标这个问题本身就是病态的。<br>图像分割可以分为两类：</p><ul><li>完全分割<ul><li>每部分都和一个实物相关</li><li>没有重叠的区域</li></ul></li><li>部分分割<ul><li>拥有均匀亮度、颜色等的区域</li><li>重叠的部分，需要进一步处理</li></ul></li></ul><h2 id="分割方法"><a href="#分割方法" class="headerlink" title="分割方法"></a>分割方法</h2><h3 id="基于阈值的分割"><a href="#基于阈值的分割" class="headerlink" title="基于阈值的分割"></a>基于阈值的分割</h3><p>阈值分割是基于直方图的，对图像进行灰度阈值化是最简单的分割处理。图像阈值化算法简单高效，在很多场景中依然得到很多应用，实时性很好。图像阈值化的缺陷也是明显的，不能够很好的利用图像中的诸如色彩、纹理等语义信息，因此在复杂场景中无法得到目标结果。 </p><h4 id="阈值"><a href="#阈值" class="headerlink" title="阈值"></a>阈值</h4><p>图像阈值化分为全局阈值和局部阈值及动态阈值。全局阈值是对整幅图像使用单个阈值，局部阈值是根据图像局部信息在局部执行阈值化。阈值化操作有许多改进算法，例如：局部阈值化、带阈值化、半阈值化、多阈值化等。阈值化的关键在于如何选择阈值。  </p><p>阈值分割的优点是计算简单、运算效率较高、速度快。全局阈值对于灰度相差很大的不同目标和背景能进行有效的分割。当图像的灰度差异不明显或不同目标的灰度值范围有重叠时，应采用局部阈值或动态阈值分割法。另一方面，这种方法只考虑像素本身的灰度值，一般不考虑空间特征，因而对噪声很敏感。在实际应用中，阈值法通常与其他方法结合使用。 </p><h5 id="全局阈值"><a href="#全局阈值" class="headerlink" title="全局阈值"></a>全局阈值</h5><p>全局阈值法采用同一个灰度值作为分割门限对整幅图进行处理，特别对直方图分布呈双峰态的图像分割效果好，如：</p><p><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/computerVersion/30853134.jpg" title="全局阈值分割" alt="全局阈值分割" width="80%"> </p><p>但在有意义的全局阈值不存在的情况下，全局阈值的分割效果很差，如：<br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/computerVersion/36706577.jpg" title="全局阈值分割" alt="全局阈值分割" width="80%"> </p><h5 id="迭代阈值图像分割"><a href="#迭代阈值图像分割" class="headerlink" title="迭代阈值图像分割"></a>迭代阈值图像分割</h5><p>迭代阈值的步骤为：</p><ol><li>统计图像灰度直方图,求出图象的最大灰度值和最小灰度值，分别记为$Z_{max}$和$Z_{min}，令初始阈值$T_{0} = \frac {Z_{max} +Z_{min} } {2}$。</li><li>根据阈值TK将图象分割为前景和背景，计算小于TO所有灰度的均值ZO，和大于TO的所有灰度的均值ZB。</li><li>求出新阈值TK+1=(ZO+ZB)/2；</li><li>若TK==TK+1，则所得即为阈值；否则转2，迭代计算。</li></ol><h5 id="动态阈值"><a href="#动态阈值" class="headerlink" title="动态阈值"></a>动态阈值</h5><h3 id="边缘检测"><a href="#边缘检测" class="headerlink" title="边缘检测"></a>边缘检测</h3><p>通过不同的特征检测物体边缘</p><h3 id="基于空间的分割"><a href="#基于空间的分割" class="headerlink" title="基于空间的分割"></a>基于空间的分割</h3><p>寻找满足homogeneity criterion 条件的最大空间。</p><h3 id="结合边缘检测及空间分割"><a href="#结合边缘检测及空间分割" class="headerlink" title="结合边缘检测及空间分割"></a>结合边缘检测及空间分割</h3>]]></content>
      
      <categories>
          
          <category> Computer Version </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CV </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> 原理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>常见激活函数</title>
      <link href="/2018/07/22/deep_learning/activation-func/"/>
      <url>/2018/07/22/deep_learning/activation-func/</url>
      <content type="html"><![CDATA[<h1 id="神经网络常用激活函数"><a href="#神经网络常用激活函数" class="headerlink" title="神经网络常用激活函数"></a><center>神经网络常用激活函数</center></h1><h2 id="为什么需要激活函数"><a href="#为什么需要激活函数" class="headerlink" title="为什么需要激活函数"></a>为什么需要激活函数</h2><p>激活函数的性质：</p><ul><li><strong>非线性</strong>：激活函数为线性函数时，两层神经网络就可以拟合所有的线性函数。若激活函数为恒等激活函数，即$f(x)=x$时，不满足条件</li><li><strong>可微性</strong>：当优化方法是基于梯度的时候，必须满足可微性</li><li><strong>单调性</strong>：激活函数是单调函数时，单层网络才能保证是凸函数</li><li><strong>$f(x)\approx x $</strong>：当激活函数满足这个性质的时候，如果参数的初始化是random的很小的值，那么神经网络的训练将会很高效；如果不满足这个性质，那么就需要很用心的去设置初始值。</li><li><strong>输出值的范围</strong>：激活函数输出值的范围是有限的时候，基于梯度的优化方法更加稳定，因为特征的表示受有限权值的影响更显著；激活函数范围无限时，模型训练更高效，需要更小的learning rate。</li></ul><h2 id="常见的激活函数"><a href="#常见的激活函数" class="headerlink" title="常见的激活函数"></a>常见的激活函数</h2><h3 id="Sigmoid函数"><a href="#Sigmoid函数" class="headerlink" title="Sigmoid函数"></a>Sigmoid函数</h3><p>Sigmoid又叫作 Logistic 激活函数，它将实数值压缩进 0 到 1 的区间内，还可以在预测概率的输出层中使用。该函数将大的负数转换成 0，将大的正数转换成 1。数学公式为：<br>$$<br>\sigma(x) = \frac{1}{1+e^{-x}}<br>$$</p><p>它是关于中心点（0, 0.5）对称的函数，图形为：</p><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/deepLearning/37147146.jpg" alt="sigmoid function" title="Sigmoid function" width="70%/"><br></center><p>Sigmoid函数导数为：<br>$$<br>\sigma{}’(x)=\sigma (x)(1-\sigma (x))<br>$$<br>图形为：</p><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/deepLearning/99194005.jpg" alt="sigmoid导数" title="Sigmoid function 导数" width="75%/"><br></center><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ul><li>会有梯度弥散。Sigmoids saturate and kill gradients. sigmoid 有一个非常致命的缺点，当输入非常大或者非常小的时候（saturation），这些神经元的梯度是接近于0的，从图中可以看出梯度的趋势。需要尤其注意参数的初始值来尽量避免saturation的情况。如果初始值很大，大部分神经元可能都会处在saturation的状态而把gradient kill掉，这会导致网络变的很难学习。</li><li>不关于原点对称。 output 不是0均值。这是不可取的，因为这会导致后一层的神经元将得到上一层输出的非0均值的信号作为输入。  产生的一个结果就是：如果数据进入神经元的时候是正的(e.g. $x&gt;0$，elementwise in$f=w^{T}x + b$ )，那么$w$计算出的梯度也会始终都是正的。 如果输入神经元的数据总是正数，那么关于w的梯度在反向传播的过程中，将会要么全部是正数，要么全部是负数，这将会导致梯度下降权重更新时出现z字型的下降。</li><li>计算指数耗时。</li></ul><h3 id="Tanh函数"><a href="#Tanh函数" class="headerlink" title="Tanh函数"></a>Tanh函数</h3><p>tanh和sigmoid函数相似，实际上，tanh 是sigmoid的变形：<br>$$<br>tanh(x) = 2sigmoid(2x) -1<br>$$<br>与 sigmoid 不同的是，tanh 是0均值的。它的图像关于原点中心对称。因此，实际应用中，tanh 会比 sigmoid 更好。</p><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/deepLearning/91091273.jpg" alt="tanh function" title="tant function" width="70%/"><br></center><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul><li>解决原点对称的问题。tanh解决了Sigmoid的输出是不是零中心的问题。</li><li>收敛速度比sigmoid更快</li></ul><h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><ul><li>仍然没有解决梯度弥散问题</li></ul><h3 id="ReLu函数系列："><a href="#ReLu函数系列：" class="headerlink" title="ReLu函数系列："></a>ReLu函数系列：</h3><h4 id="ReLu"><a href="#ReLu" class="headerlink" title="ReLu"></a>ReLu</h4><p>ReLU非线性函数图像如下图所示。相较于sigmoid和tanh函数，ReLU对于随机梯度下降的收敛有巨大的加速作用；sigmoid和tanh在求导时含有指数运算，而ReLU求导几乎不存在任何计算量。<br>其公式为：<br>$$<br>f(x) = max(0,x)<br>$$</p><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/deepLearning/48089832.jpg" alt="ReLu function" title="ReLu function" width="70%/"><br></center><h5 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h5><ul><li>单侧抑制； </li><li>相对宽阔的兴奋边界； </li><li>稀疏激活性。 </li></ul><h5 id="缺点：-2"><a href="#缺点：-2" class="headerlink" title="缺点："></a>缺点：</h5><ul><li>ReLU单元比较脆弱并且可能“死掉”，而且是不可逆的，因此导致了数据多样化的丢失。通过合理设置学习率，会降低神经元“死掉”的概率。 </li></ul><h4 id="Leakly-ReLu"><a href="#Leakly-ReLu" class="headerlink" title="Leakly ReLu"></a>Leakly ReLu</h4><p>Leaky ReLUs用来解决 “dying ReLU” 问题。与 ReLU 不同的是：<br>$$<br>f(x)=\left{\begin{matrix}<br>\alpha x &amp;  (x&lt;0)\<br> x &amp; (x&gt;=0)<br>\end{matrix}\right.<br>$$<br>此处$\alpha $是一个较小的常数，这样既修正了数据分布，又保留了负半轴的值，使得负半轴的信息不会全部丢失。<br>其图像为：</p><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/deepLearning/50011864.jpg" alt="Leakly ReLu function" title="Leakly ReLu function" width="50%/"><br></center><h4 id="Parametric-ReLU-P-ReLu"><a href="#Parametric-ReLU-P-ReLu" class="headerlink" title="Parametric ReLU(P-ReLu)"></a>Parametric ReLU(P-ReLu)</h4><p>对于 Leaky ReLU 中的$\alpha$，通常都是通过先验知识人工赋值的。 然而可以观察到，损失函数对α的导数我们是可以求得的，可以将它作为一个参数进行训练，而且效果更好。<br>对$\alpha $的导数如下：<br>$$<br>\frac{\delta y_{i}}{\delta \alpha} = \left{\begin{matrix}<br>0 &amp; y_{i} &gt; 0 \<br> y_{i}&amp; other<br>\end{matrix}\right.<br>$$</p><h4 id="Randomized-ReLU-R-ReLu"><a href="#Randomized-ReLU-R-ReLu" class="headerlink" title="Randomized ReLU (R-ReLu)"></a>Randomized ReLU (R-ReLu)</h4><p>Randomized Leaky ReLU是 leaky ReLU 的random 版本 （$\alpha$ 是随机的）。核心思想就是，在训练过程中，$\alpha$ 是一个服从高斯分布的 $U(l,u)$ 中 随机抽取出来的，然后在测试过程中进行修正（有点像dropout的用法）。<br>数学表达式为：<br>$$<br>y_{j,i}=\left{\begin{matrix}<br>x_{j,i} &amp;x_{j,i}\geq 0 \<br>a_{j,i}x_{j,i} &amp; x_{j,i}&lt;0<br>\end{matrix}\right.<br>$$</p><p>其中$a_{j,i}\sim U(l,u)$，$l&lt;u$且$u\in [0,1)$。在测试阶段，把训练过程中所有的$\alpha_{j,i}$取个平均值 。</p><p>测试阶段激活函数为：<br>$$<br>y_{ij}=\frac{x_{ij}}{\frac {l+u}{2}}<br>$$</p><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/deepLearning/21922024.jpg" alt="P-ReLu and R-ReLu" title="P-ReLu and R-ReLu" width="100%/"><br></center><h3 id="Maxout"><a href="#Maxout" class="headerlink" title="Maxout"></a>Maxout</h3><p>Maxout是对ReLU和leaky ReLU的一般化归纳，假设$w$是二维的，函数公式为：<br>$$<br>f(x) = max(w_{1}^{T}x+b_{1},w_{2}^{T}x+b_{2})<br>$$</p><p>Maxout的拟合能力是非常强的，它可以拟合任意的的凸函数。作者从数学的角度上也证明了这个结论，即只需2个maxout节点就可以拟合任意的凸函数了（相减），前提是”隐隐含层”节点的个数可以任意多。</p><p>Maxout非线性函数图像如下图所示。Maxout具有ReLU的优点，如计算简单，不会 saturation，同时又没有ReLU的一些缺点，如容易死掉。 </p><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/deepLearning/43488930.jpg" alt="Maxout" title="Maxout" width="100%/"><br></center><p>由公式可以看出每个神经元的参数都变为原来的两倍，导致整体参数增加。</p><h3 id="Softmax"><a href="#Softmax" class="headerlink" title="Softmax"></a>Softmax</h3><p>Softmax用于多分类神经网络输出，目的是让大的更大。函数公式是：<br>$$<br>\sigma(z)<em>{j}=\frac{e^{z</em>{j}}}{ \sum_{k=1}^{K} e^{z_{k}}}<br>$$</p><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/deepLearning/90715034.jpg" alt="Softmax" title="Softmax" width="75%"><br></center><p>Softmax是Sigmoid的扩展，当类别数k＝2时，Softmax回归退化为Logistic回归。  </p>]]></content>
      
      <categories>
          
          <category> Deep Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 神经网络 </tag>
            
            <tag> 激活函数 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>常见的排序算法</title>
      <link href="/2018/07/19/offer_problem/sort-summery/"/>
      <url>/2018/07/19/offer_problem/sort-summery/</url>
      <content type="html"><![CDATA[<h1 id="常见的排序算法"><a href="#常见的排序算法" class="headerlink" title="常见的排序算法"></a><center>常见的排序算法</center></h1><p><strong>冒泡排序、插入排序、选择排序、希尔排序、堆排序、归并排序、快速排序</strong></p><h2 id="冒泡排序："><a href="#冒泡排序：" class="headerlink" title="冒泡排序："></a>冒泡排序：</h2><p><strong>平均时间复杂度$O(n^2)$，最好情况复杂度$O(n)$</strong></p><h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><ol><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ol><ul><li>java例子<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (array.length &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length - i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (array[j] &gt; array[j+<span class="number">1</span>])&#123;</span><br><span class="line">                swap(arary, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p><strong>时间复杂度：$O(n^2)$，最优时间复杂度：$O(n)$</strong></p><h3 id="步骤：-1"><a href="#步骤：-1" class="headerlink" title="步骤："></a>步骤：</h3><ol><li>从第一个元素开始，该元素可以认为已经被排序</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li><li>将新元素插入到该位置后</li><li>重复步骤2~5</li></ol><ul><li>java例子</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (array.length &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> key = array[i];</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; array[j] &gt; key)&#123;</span><br><span class="line">            array[j+<span class="number">1</span>] = array[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        array[j+<span class="number">1</span>] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p><strong>时间复杂度：$O(n^2)$，最优时间复杂度：$O(n)$</strong></p><h3 id="步骤：-2"><a href="#步骤：-2" class="headerlink" title="步骤："></a>步骤：</h3><p>首先在未排序序列中找到最小元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小元素，然后放到已排序序列的末尾。</p><ul><li>java例子</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (array.length &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; array.length; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (array[min] &gt; array[j])&#123;</span><br><span class="line">                min = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(array, min, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p><strong>时间复杂度：根据步长而不同，最优时间复杂度：O(n)</strong></p><h3 id="步骤：-3"><a href="#步骤：-3" class="headerlink" title="步骤："></a>步骤：</h3><ol><li>比如下面的例子，对数组进行分区，按照步长进行分区，步长为4，分成四个区，用四个颜色表示</li></ol><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/offerProblems/48327117.jpg" width="50%/"><br></center><ol start="2"><li>对每个分区应用插入排序，结果如下：</li></ol><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/offerProblems/33511557.jpg" width="50%/"><br></center><ol start="3"><li>再把步长缩减成1/2，再应用插入排序：</li></ol><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/offerProblems/11337902.jpg" width="50%/"><br></center><ol start="4"><li>直到步长为一</li></ol><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/offerProblems/96792014.jpg" width="50%/"><br></center><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p><strong>时间复杂度：$O(nlogn)$，最优时间复杂度：$O(nlogn)$</strong></p><h3 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h3><p><strong>堆（二叉堆</strong>）可以视为一棵完全的二叉树</p><p>二叉堆一般分为两种：<strong>最大堆</strong>和<strong>最小堆</strong></p><p>最大堆：</p><ul><li>最大堆中的最大元素值出现在根结点（堆顶）</li><li>堆中每个父节点的元素值都大于等于其孩子结点（如果存在）</li></ul><p>最小堆：</p><ul><li>最小堆中的最小元素值出现在根结点（堆顶）</li><li>堆中每个父节点的元素值都小于等于其孩子结点（如果存在）</li></ul><h3 id="步骤：-4"><a href="#步骤：-4" class="headerlink" title="步骤："></a>步骤：</h3><p>先建立一个堆（最小或最大都可以）</p><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/offerProblems/78118630.jpg" width="50%/"><br></center><p>映射方式按照如下的公式进行：</p><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/offerProblems/22158104.jpg" width="30%/"><br></center><p>然后进行堆调整，比如下图是按照最大堆的方式进行调整中的一趟：</p><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/offerProblems/24421504.jpg" width="50%/"><br></center><p>取出堆顶元素，在重复进行以上步骤，直到只剩一个元素</p><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/offerProblems/94527342.jpg" width="50%/"><br></center><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p><strong>时间复杂度：$O(nlogn)$，最优时间复杂度：$O(n)$</strong></p><h3 id="步骤：-5"><a href="#步骤：-5" class="headerlink" title="步骤："></a>步骤：</h3><p>归并操作（merge），也叫归并算法，指的是将两个已经排序的序列合并成一个序列的操作。归并排序算法依赖归并操作。可以用迭代或递归实现，主要采用分而治之的思想。</p><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/offerProblems/46511354.jpg" width="50%/"><br></center><ul><li>递归步骤：<ul><li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</li><li>设定两个指针，最初位置分别为两个已经排序序列的起始位置</li><li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</li><li>重复步骤3直到某一指针到达序列尾</li><li>将另一序列剩下的所有元素直接复制到合并序列尾</li></ul></li><li>迭代步骤<ul><li>将序列每相邻两个数字进行归并操作形成$ceil(n/2)$个序列，排序后每个序列包含两/一个元素</li><li>若此时序列数不是1个则将上述序列再次归并，形$ceil(n/2)$个序列，每个序列包含四/三个元素</li><li>重复步骤2，直到所有元素排序完毕，即序列数为1</li></ul></li><li>java例子递归版</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span>[] reg, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (end + start) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> start2 = mid + <span class="number">1</span>;</span><br><span class="line">    mergeSort(arr, reg, start, mid);</span><br><span class="line">    mergeSort(arr, reg, start2, end);</span><br><span class="line">    <span class="keyword">int</span> k = start;</span><br><span class="line">    <span class="keyword">while</span>(start &lt;= mid &amp;&amp; mid + <span class="number">1</span> &lt;= end)&#123;</span><br><span class="line">        reg[k++] = arr[start] &lt; arr[start2] ? arr[start++] : arr[start2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(start &lt;= mid)&#123;</span><br><span class="line">        reg[k++] == arr[start++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(start2 &lt;= end)&#123;</span><br><span class="line">        reg[k++] == arr[start2++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>java迭代版</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = arr.length;</span><br><span class="line">    <span class="keyword">int</span>[] reg = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    <span class="keyword">int</span> start, block;</span><br><span class="line">    <span class="keyword">for</span>(block = <span class="number">1</span>; block &lt; len; block *= <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (start = <span class="number">0</span>; start &lt; len; start += block * <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = start + block &lt; len ? start + block : len;</span><br><span class="line">            <span class="keyword">int</span> high = start + <span class="number">2</span> * block &lt; len ? start + <span class="number">2</span> * block : len;</span><br><span class="line">            <span class="keyword">int</span> low = start, start2 = mid;</span><br><span class="line">            <span class="keyword">while</span> (low &lt; mid  &amp;&amp; start2 &lt; high)&#123;</span><br><span class="line">                reg[low++] = arr[start] &lt; arr[start2] ? arr[start++] : arr[start2++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(low &lt;= mid)&#123;</span><br><span class="line">                reg[low++] == arr[start++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(start2 &lt;= end)&#123;</span><br><span class="line">                reg[low++] == arr[start2++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] temp = arr;</span><br><span class="line">        arr = reg;</span><br><span class="line">        reg = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    reg = arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p><strong>时间复杂度：$O(nlogn)$，最优时间复杂度：$O(nlogn)$</strong></p><p>使用二分查找的思路</p><h3 id="步骤：-6"><a href="#步骤：-6" class="headerlink" title="步骤："></a>步骤：</h3><ol><li>从数列中挑出一个元素，称为”基准”（pivot），</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ol><ul><li>java例子</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> index = (<span class="keyword">int</span>)(Math.random() * (end - start + <span class="number">1</span>)) + start;</span><br><span class="line">    swap(arr, index, end);</span><br><span class="line">    <span class="keyword">int</span> small = start-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (index = start; index &lt; end; index++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[index] &lt; arr[end])&#123;</span><br><span class="line">            small++;</span><br><span class="line">            <span class="keyword">if</span> (small != index)&#123;</span><br><span class="line">                swap(arr, index, small)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    small++;</span><br><span class="line">    swap(arr, small, end);</span><br><span class="line">    <span class="keyword">return</span> small;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (start == end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> index = Partition(arr, start, end);</span><br><span class="line">    <span class="keyword">if</span> (index &gt; start)&#123;</span><br><span class="line">        quickSort(arr, start, index - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; end)&#123;</span><br><span class="line">        quickSort(arr, insex + <span class="number">1</span>, end);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="剑指offer实例"><a href="#剑指offer实例" class="headerlink" title="剑指offer实例"></a>剑指offer实例</h2><h3 id="面试题11：旋转数组的最小数字"><a href="#面试题11：旋转数组的最小数字" class="headerlink" title="面试题11：旋转数组的最小数字"></a>面试题11：旋转数组的最小数字</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4>]]></content>
      
      <categories>
          
          <category> Offer Problems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> java </tag>
            
            <tag> 剑指offer </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>剑指offer总结（栈与队列）</title>
      <link href="/2018/07/17/offer_problem/offferStackAndQueue/"/>
      <url>/2018/07/17/offer_problem/offferStackAndQueue/</url>
      <content type="html"><![CDATA[<h1 id="剑指offer总结——栈与队列"><a href="#剑指offer总结——栈与队列" class="headerlink" title="剑指offer总结——栈与队列"></a><center>剑指offer总结——栈与队列</center></h1><h3 id="面试题9：用两个栈实现队列"><a href="#面试题9：用两个栈实现队列" class="headerlink" title="面试题9：用两个栈实现队列"></a>面试题9：用两个栈实现队列</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 </p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>栈的属性是先进后出的，而队列是先进先出，使用两个栈，队列push操作直接将数据push到第一个栈中；pop队列操作时，需要将stack1中的数据push到stack2中，变换stack中存储数据的首位方向，然后stack2弹出栈顶操作就相当于弹出stack1的栈底。push时间复杂度为$O()1$，pop时间复杂度为$O(n)$。</p><ul><li>java解法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack2.isEmpty)&#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack1.isEmpty())&#123;</span><br><span class="line">                stack2.push(stack1.pop);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="面试题30：包含min函数的栈"><a href="#面试题30：包含min函数的栈" class="headerlink" title="面试题30：包含min函数的栈"></a>面试题30：包含min函数的栈</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数。在该栈中，使用min，push，及pop的时间复杂度都是$O(1)$。</p><h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><p>使用一个栈存储数据，另一个辅助栈存储最小值数据。当push的时候，将push数据与当前辅助站的top值比较，如果该值比top值小，就将数据push到辅助站中，若该值比top值大，就将top值入栈，这样就记录了每一次入栈操作的最小值。pop时将两个栈的数据都pop即可。</p><ul><li>java解法</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.Exception;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> Stack&lt;Integer&gt; dataStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> Stack&lt;Integer&gt; minStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        dataStack.push(node);</span><br><span class="line">        <span class="keyword">if</span> (minStack != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (minStack.top() &lt; node) minStack.push(node);</span><br><span class="line">            <span class="keyword">else</span> minStack.push(minStack.top());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            minStack.push(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((!data.isEmpty()) &amp;&amp; (!minData.isEmpty()))&#123;</span><br><span class="line">            data.pop();</span><br><span class="line">            minData.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dataStack.isEmpty) <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">return</span> dataStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (minStack.isEmpty) <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="面试题31：栈的压入、弹出序列"><a href="#面试题31：栈的压入、弹出序列" class="headerlink" title="面试题31：栈的压入、弹出序列"></a>面试题31：栈的压入、弹出序列</h3><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）。</p><h4 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h4><p>使用一个辅助栈存储当前栈中的值，第二个序列的第一个数字为栈顶，因此，此时的栈应该为从序列一中入栈，直到找到popA[0]=pushA[i]，然后循环到下一个pop值<br>当popA[j]为栈顶元素时，就将该元素出栈；如果不是，就把pushA的下一个元素入栈，直到把下一个需要弹出的数字入栈为止。<br>如果所有的元素均已入栈仍然没有找到下一个应该弹出的数字，则返回false。时间复杂度为$O(n)$，空间复杂度也为$O(n)$。</p><ul><li>java解法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder</span><span class="params">(<span class="keyword">int</span> [] pushA, <span class="keyword">int</span> [] popA)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pushA == <span class="keyword">null</span> || popA == <span class="keyword">null</span> || pushA.length != popA.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; pushA.length || j &lt; popA.length)&#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; pushA.length &amp;&amp; (stack.isEmpty() || popA[j] != stack.peek()))&#123;</span><br><span class="line">            stack.push(pushA[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j &gt;= popA.length || popA[j] != stack.peek()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        stack.pop();</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stack.isEmpty() &amp;&amp; i == j) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="面试题32：从上到下打印二叉树"><a href="#面试题32：从上到下打印二叉树" class="headerlink" title="面试题32：从上到下打印二叉树"></a>面试题32：从上到下打印二叉树</h3><h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p><h4 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h4><p>用一个队列存储当前层的节点，弹出队列顶点节点，判断当前节点是否有左右子节点，有就入队，并将当前节点的值打印出来。再弹出下一个队列顶点节点，直至队列为空。时间复杂度为$O(n)$。</p><p>这道题是二叉树的内容，并且涉及到使用队列。</p><ul><li>java解法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printFromTopToBottom</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> Queue&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        TreeNode temp = queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (temp.left != <span class="keyword">null</span>) queue.offer(temp.left);</span><br><span class="line">        <span class="keyword">if</span> (temp.right != <span class="keyword">null</span>) queue.offer(temp.right);</span><br><span class="line">        ans.add(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="题目变形一：分行从上到下打印二叉树"><a href="#题目变形一：分行从上到下打印二叉树" class="headerlink" title="题目变形一：分行从上到下打印二叉树"></a>题目变形一：分行从上到下打印二叉树</h3><h4 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h4><p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p><h4 id="解决方案-4"><a href="#解决方案-4" class="headerlink" title="解决方案"></a>解决方案</h4><p>此题和上一题类似，需要使用队列来保存将要打印的节点，为了把二叉树的每一行单独打印到一行，在层次遍历的过程中，需要使用一个变量记录当前层的节点数。</p><ul><li>java解法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (pRoot == <span class="keyword">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(pRoot);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = queue.size();</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            TreeNode temp = queue.poll();</span><br><span class="line">            list.add(temp.val);</span><br><span class="line">            <span class="keyword">if</span> (temp.left != <span class="keyword">null</span>) queue.offer(temp.left);</span><br><span class="line">            <span class="keyword">if</span> (temp.right != <span class="keyword">null</span>) queue.offer(temp.right);</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.add(list);     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="题目变形二：分行从上到下打印二叉树"><a href="#题目变形二：分行从上到下打印二叉树" class="headerlink" title="题目变形二：分行从上到下打印二叉树"></a>题目变形二：分行从上到下打印二叉树</h3><h4 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h4><p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p><h4 id="解决方案-5"><a href="#解决方案-5" class="headerlink" title="解决方案"></a>解决方案</h4><p>此题和上一题变形题类似，使用之字形打印时，需要两个栈来维护之字形的结构，奇数层存入第一个栈，偶数层存入第二个栈，当遍历完当前层的所有节点时，交换这两个栈，继续遍历下一层。</p><p>LinkedList 是一个继承于AbstractSequentialList的双向链表。它也可以被当作堆栈、队列或双端队列进行操作。<br>可以仅使用一个LinkedList，类似于双向链表的数据结构存储节点数据，因为它既可以当做队列，实现从左到右打印，也可以当做栈，实现从右到左打印。因此可以在奇数层时作为队列，偶数层时作为栈。<br>这里采用第一种方法。</p><ul><li>java解法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (pRoot == <span class="keyword">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line">    </span><br><span class="line">    Stack&lt;TreeNode&gt; stack1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack1.add(pRoot);</span><br><span class="line">    <span class="keyword">boolean</span> leftToRight = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!stack1.isEmpty() || !stack2.isEmpty())&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; layer = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        TreeNode temp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (leftToRight)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">                temp = stack1.pop();</span><br><span class="line">                <span class="keyword">if</span> (temp  != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    layer.add(temp.val);</span><br><span class="line">                    stack2.push(temp.left);</span><br><span class="line">                    stack2.push(temp.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack2.isEmpty())&#123;</span><br><span class="line">                temp = stack2.pop();</span><br><span class="line">                <span class="keyword">if</span> (temp != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    layer.add(temp.val);</span><br><span class="line">                    stack1.push(temp.right);</span><br><span class="line">                    stack1.push(temp.left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (layer.length != <span class="number">0</span>)&#123;</span><br><span class="line">            ans.add(layer);</span><br><span class="line">            leftToRight = (!leftToRight);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      <categories>
          
          <category> Offer Problems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> java </tag>
            
            <tag> 剑指offer </tag>
            
            <tag> 栈和队列 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>剑指offer刷题总结（树）</title>
      <link href="/2018/07/16/offer_problem/offerTree/"/>
      <url>/2018/07/16/offer_problem/offerTree/</url>
      <content type="html"><![CDATA[<h1 id="剑指offer总结——树"><a href="#剑指offer总结——树" class="headerlink" title="剑指offer总结——树"></a><center>剑指offer总结——树</center></h1><h3 id="面试题7：重建二叉树"><a href="#面试题7：重建二叉树" class="headerlink" title="面试题7：重建二叉树"></a>面试题7：重建二叉树</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>根据二叉树先序遍历的特征，找到根节点为先序遍历的第一个节点，在中序遍历的数组中找到该节点，则在中序遍历中，该节点的左半部分为左子树的节点，又半部分为右子树的节点，分而治之，以递归的形式，分别找到根节点的左子树和右子树。算法时间复杂度为$O(nloogn)$，空间复杂度为$O(n)$，因为每个节点都会被递归调用。</p><ul><li>java解法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pre == <span class="keyword">null</span> || in == <span class="keyword">null</span> || pre.length != in.length) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> preL = <span class="number">0</span>, preR = pre.length - <span class="number">1</span>, inL = <span class="number">0</span>, inR = in.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> findNode(pre, preL, preR, in, inL, inR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">findNode</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span> preL, <span class="keyword">int</span> preR, <span class="keyword">int</span>[] in, <span class="keyword">int</span> inL, <span class="keyword">int</span> inR)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (preL &gt; preR || inL &gt;inR) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(pre[preL]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = inL; i &lt;= inR; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (pre[preL] == in[i])&#123;</span><br><span class="line">            root.left = findNode(pre, preL + <span class="number">1</span>, preL + i - inL, in, inL, i - <span class="number">1</span>);</span><br><span class="line">            root.right = findNode(pre, preL + i - inL + <span class="number">1</span>, preR, in, i+<span class="number">1</span>, inR);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="面试题8：二叉树的下一个节点"><a href="#面试题8：二叉树的下一个节点" class="headerlink" title="面试题8：二叉树的下一个节点"></a>面试题8：二叉树的下一个节点</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p><h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><p>二叉树的下一个节点共有三种情况</p><ul><li>该节点有右子节点，此时中序遍历的下一个节点就是该节点右子树沿左分支向下，知直到找到最后一个左孩子，这个左孩子就是其下一个节点</li><li>该节点没有有子节点，此时沿父节点向上查找，直到查找到一个父节点，父节点的左孩子是该节点的分支</li><li><p>该节点为null，返回null<br>平均时间复杂度为$O(h)$，h为数的深度。</p></li><li><p>java解法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeLinkNode <span class="title">GetNext</span><span class="params">(TreeLinkNode pNode)</span></span>&#123;</span><br><span class="line">    TreeLinkNode ans = <span class="keyword">new</span> TreeLinkNode(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(pNode == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(pNode.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">        ans = pNode.right;</span><br><span class="line">        <span class="keyword">while</span>(ans.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ans = ans.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(pNode.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        ans = pNode.next;</span><br><span class="line">        <span class="keyword">if</span>(ans.left == pNode) <span class="keyword">return</span> ans;</span><br><span class="line">        pNode = ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="面试题26：树的子结构"><a href="#面试题26：树的子结构" class="headerlink" title="面试题26：树的子结构"></a>面试题26：树的子结构</h3><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）。</p><h4 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h4><p>使用递归的方法判断B是否是A的子树，在当前节点的判断需要分为三种情况，首先是A和B是否相同，然后判断A的左子树是否和B相同，A的右子树是否和B相同。时间复杂度为$O(n)$，n为A的节点数。</p><ul><li>java解法<br>需要充分利用判断条件的短路性质<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode root1,TreeNode root2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root2 == <span class="keyword">null</span> || root1 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isSubtree(root1, root2) || HasSubtree(root1.left, root2) || HasSubtree(root1.right, root2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSubtree</span><span class="params">(TreeNode root1, TreeNode root2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (root1 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (root1.val == root2.val) </span><br><span class="line">        <span class="keyword">return</span> isSubtree(root1.left, root2.left) &amp;&amp; isSubtree(root1.right, root2.right);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="面试题27：二叉树的镜像"><a href="#面试题27：二叉树的镜像" class="headerlink" title="面试题27：二叉树的镜像"></a>面试题27：二叉树的镜像</h3><h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><p>操作给定的二叉树，将其变换为源二叉树的镜像。<br>例如：<br>             8<br>            /  \<br>          6    10<br>         / \    / \<br>        5  7   9  11<br>镜像二叉树为：<br>             8<br>            /  \<br>          10    6<br>         / \    / \<br>        11  9   7  5</p><h4 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h4><p>使用递归的方法，类似于二叉树的层次遍历，依次翻转二叉树的左右子节点。时间复杂度为$O(n)$，空间复杂度为$O(n)$</p><ul><li>java解法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mirror</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="keyword">null</span> || root.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">        TreeNode temp = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line">        mirror(root.left);</span><br><span class="line">        mirror(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="面试题28：对称的二叉树"><a href="#面试题28：对称的二叉树" class="headerlink" title="面试题28：对称的二叉树"></a>面试题28：对称的二叉树</h3><h4 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h4><p>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p><h4 id="解决方案-4"><a href="#解决方案-4" class="headerlink" title="解决方案"></a>解决方案</h4><p>使用递归的方法，分别判断当前节点的左孩子是否等于对比节点的右孩子值，当前节点的右孩子是否等于对比节点的左孩子值。时间复杂度和空间复杂度均为$O(n)$。</p><ul><li>java解法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode pRoot)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pRoot == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> isSym(pRoot.left, pRoot.right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSym</span><span class="params">(TreeNode pNode, TreeNode qNode)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pNode == <span class="keyword">null</span>) <span class="keyword">return</span> qNode == <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (qNode == <span class="keyword">null</span> || pNode.val != qNode.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> (isSym(pNode.left, qNode.right) &amp;&amp; isSym(pNode.right, qNode.left));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="面试题32：从上到下打印二叉树"><a href="#面试题32：从上到下打印二叉树" class="headerlink" title="面试题32：从上到下打印二叉树"></a>面试题32：从上到下打印二叉树</h3><h4 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h4><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p><h4 id="解决方案-5"><a href="#解决方案-5" class="headerlink" title="解决方案"></a>解决方案</h4><p>用一个队列存储当前层的节点，弹出队列顶点节点，判断当前节点是否有左右子节点，有就入队，并将当前节点的值打印出来。再弹出下一个队列顶点节点，直至队列为空。时间复杂度为$O(n)$。</p><ul><li>java解法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printFromTopToBottom</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> Queue&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        TreeNode temp = queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (temp.left != <span class="keyword">null</span>) queue.offer(temp.left);</span><br><span class="line">        <span class="keyword">if</span> (temp.right != <span class="keyword">null</span>) queue.offer(temp.right);</span><br><span class="line">        ans.add(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="面试题33：二叉搜索树的后序遍历序列"><a href="#面试题33：二叉搜索树的后序遍历序列" class="headerlink" title="面试题33：二叉搜索树的后序遍历序列"></a>面试题33：二叉搜索树的后序遍历序列</h3><h4 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同</p><h4 id="解决方案-6"><a href="#解决方案-6" class="headerlink" title="解决方案"></a>解决方案</h4><p>采用分而治之的思想，二叉树的后序遍历是将根节点置于数组最后，BST将剩余数组分为两部分，前面是左子树，其数值均比根节点的数值小，后面部分为右子树，其数值均比根节点的数值大，如果后面部分有比根节点数值小的数字，则不是一个BST的后序遍历。递归判断左右子序列是否是后序遍历。时间复杂度为$O(logn)$。</p><ul><li>java解法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="keyword">int</span> [] sequence)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sequence.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> (verifySequence(sequence, <span class="number">0</span>, sequence.length - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verifySequence</span><span class="params">(<span class="keyword">int</span>[] sequence, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">int</span> separater = l;</span><br><span class="line">    <span class="keyword">while</span> (separater &lt; r)&#123;</span><br><span class="line">        <span class="keyword">if</span> (sequence[separater] &gt; sequence[r])&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++separater;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = separater; i &lt; r; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (sequence[i] &lt; sequence[r]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> verifySequence(sequence, l, separater-<span class="number">1</span>) &amp;&amp; verifySequence(sequence, separater, r-<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="面试题34：二叉树中和为某一值的路径"><a href="#面试题34：二叉树中和为某一值的路径" class="headerlink" title="面试题34：二叉树中和为某一值的路径"></a>面试题34：二叉树中和为某一值的路径</h3><h4 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)</p><h4 id="解决方案-7"><a href="#解决方案-7" class="headerlink" title="解决方案"></a>解决方案</h4><p>因为需要从根节点出发到达叶节点，因此采用先序遍历的思想。访问到某一节点时，将该节点添加到路径上，累加该节点的值，如果路径中的节点值之和正好为输入整数，且该节点为叶节点，则当前路径符合要求。当前节点访问完成后，递归回到其父节点。时间复杂度为$O(n)$。</p><ul><li>java解法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root, <span class="keyword">int</span> target)&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        list.add(root.val);</span><br><span class="line">        target -= root.val;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span> &amp;&amp; root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(list));</span><br><span class="line">        FindPath(root.left, target);</span><br><span class="line">        FindPath(root.right, target);</span><br><span class="line">        list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="面试题36：二叉搜索树与双向链表"><a href="#面试题36：二叉搜索树与双向链表" class="headerlink" title="面试题36：二叉搜索树与双向链表"></a>面试题36：二叉搜索树与双向链表</h3><h4 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 </p><h4 id="解决方案-8"><a href="#解决方案-8" class="headerlink" title="解决方案"></a>解决方案</h4><p>转换为排序链表则考虑使用中序遍历，将二叉树变为排序链表。例如BST为：</p><pre><code>     10    /  \  6    14 / \    / \4  8   12 16</code></pre><p>采用中序遍历的结果应为：<br>$$<br>4\leftrightarrow 6\leftrightarrow 8\leftrightarrow 10\leftrightarrow 12\leftrightarrow 14\leftrightarrow 16<br>$$<br>为了减少指针的变换次数，并让操作更加简单，在转换成排序双向链表时，原先指向左子结点的指针调整为链表中指向前一个结点的指针，原先指向右子结点的指针调整为链表中指向下一个结点的指针。例如对于上面的值为6的节点，调整之后，它的前一个节点\左孩子是4，后一个节点\右孩子是8。<br>当遍历到根结点时，把树分为三个部分：根结点，根的左子树和根的右子树。如上图的二叉排序树，就分成了根结点10以结点6为根的左子对和以结点14为根的右子树。从变换的链表中可以看到，应当把结点10<br>的left指针指向结点8，把结点8的right指针指向结点10，由于采用中序遍历，当遍历到结点10时，结点10的左子树已经转化为一个有序的双向链表，而结点8是这个已经转化的双向链表的尾结点，所以应该用一个变量last_node来保存最后一个结点的指针，以便在与根结点连续时使用。然后把这个变量last_node的值更新为指向根结点10。对于结点10的右子树，采取相似的操作。至于具体的实现，只需要对所有的子树递归地执行上述操作即可。</p><ul><li>java解法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode lastNode = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">public</span> TreeNode realHead = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode pRootOfTree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pRootOfTree == <span class="keyword">null</span>) <span class="keyword">return</span> pRootOfTree;</span><br><span class="line">        convertNode(pRootOfTree);</span><br><span class="line">        <span class="keyword">return</span> realHead;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">convertNode</span><span class="params">(TreeNode pNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pNode == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (pRootOfTree.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            convertNode(pNode.left);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (lastNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">            lastNode = pNode;</span><br><span class="line">            realHead = pNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            lastNode.right = pNode;</span><br><span class="line">            pNode.left = lastNode;</span><br><span class="line">            lastNode = pNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pNode.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            convertNode(pNode.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="面试题37：序列化二叉树"><a href="#面试题37：序列化二叉树" class="headerlink" title="面试题37：序列化二叉树"></a>面试题37：序列化二叉树</h3><h4 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h4><p>请实现两个函数，分别用来序列化和反序列化二叉树 。</p><h4 id="解决方案-9"><a href="#解决方案-9" class="headerlink" title="解决方案"></a>解决方案</h4><p>二叉树的序列化从根节点开始，相应的反序列化在根节点的数值读出来的时候就可以开始，因此可以根据前序遍历的顺序来序列化二叉树，当遇到空指针的时候就使用”$”来代替该处的value，用“,”把不同的节点数值分隔开。</p><p>反序列化的时候每次从流中读取一个字符，以前序遍历的顺序重建二叉树。</p><ul><li>java解法</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">Serialize</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="string">"$,"</span>;</span><br><span class="line">        StringBuffer ans = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        ans.append(root.val).append(<span class="string">","</span>);</span><br><span class="line">        ans.append(Serialize(root.left));</span><br><span class="line">        ans.append(Serialize(root.right));</span><br><span class="line">        <span class="keyword">return</span> ans.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Deserialize</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str.equals(<span class="string">""</span>)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        String[] strList = str.split(<span class="string">","</span>);       </span><br><span class="line">        <span class="keyword">return</span> deserialize(strList);      </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String[] strList)</span></span>&#123;</span><br><span class="line">        ++index;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= strList.length) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (!strList[index].equals(<span class="string">"$"</span>))&#123;</span><br><span class="line">            root = <span class="keyword">new</span> TreeNode(Integer.parseInt(strList[index]));</span><br><span class="line">            root.left = deserialize(strList);</span><br><span class="line">            root.right = deserialize(strList);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="面试题40：最小的k个数"><a href="#面试题40：最小的k个数" class="headerlink" title="面试题40：最小的k个数"></a>面试题40：最小的k个数</h3><h4 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。 </p><h4 id="解决方案-10"><a href="#解决方案-10" class="headerlink" title="解决方案"></a>解决方案</h4><p>如果将数组排序后取前面k个数可以解决问题，但时间复杂度为$O(nlogn)$。</p><ul><li><p>方法一：时间复杂度$O(n)$</p><p>基于Partition函数来实现，如果基于数组中的第k个数字来调整，使比第k个数小的所有数字位于数组左半部分，比第k个数大的所有数字位于数组右半部分。调整后可以直接找到这k个数字，但这k个数字不一定是排序的。且这种方法会更改原始数组的排序。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span> [] input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (input.length == <span class="number">0</span> || k &lt;= <span class="number">0</span> || input.length &lt; k) <span class="keyword">return</span> ans;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, end = input.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> index = Partition(input, start, end);</span><br><span class="line">    <span class="keyword">while</span>(index != k - <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt; k - <span class="number">1</span>)</span><br><span class="line">            index = Partition(input, start, index - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            index = Partition(input, index + <span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">        ans.add(input[i]);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span>[] input, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end) <span class="keyword">return</span> start;</span><br><span class="line">    <span class="keyword">int</span> index = (<span class="keyword">int</span>)(Math.random()*(end - start + <span class="number">1</span>)) + start;</span><br><span class="line">    swap(input, index, end);</span><br><span class="line">    <span class="keyword">int</span> small = start - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (index = start; index &lt; end; index++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (input[index] &lt; input[end])&#123;</span><br><span class="line">            small++;</span><br><span class="line">            <span class="keyword">if</span>(input[small] != input[index])</span><br><span class="line">                swap(input, small, index);      </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    small++;</span><br><span class="line">    swap(input, small, end);</span><br><span class="line">    <span class="keyword">return</span> small;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] input, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = input[i];</span><br><span class="line">    input[i] = input[j];</span><br><span class="line">    input[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>方法二：时间复杂度$O(klogn)$</p><p>适合处理海量数据的算法。<br>先创建一个大小为k的数据容器来存储最小的k个数字，接下来每次从输入的n个整数中读入一个数。如果容器中已有的数字少于k个，则直接把这次读入的整数放入容器之中；如果容器中己有k 数字了，也就是容器己满，此时我们不能再插入新的数字而只能替换已有的数字。找出这己有的k 个数中的最大值，然后1在这次待插入的整数和最大值进行比较。如果待插入的值比当前己有的最大值小，则用这个数替换当前已有的最大值：如果待插入的值比当前已有的最大值还要大，那么这个数不可能是最小的k个整数之一，于是我们可以抛弃这个整数。</p><p>因此当容器满了之后，要做3 件事情： </p><ul><li>在k 个整数中找到最大数</li><li>有可能在这个容器中删除最大数</li><li>有可能要插入一个新的数字</li></ul><p>使用一个二叉树作为容器，在O(logk）时间内实现这三步操作。<br>由于每次都需要找到k个整数中的最大值，因此考虑用最大堆。在最大堆中，根节点的值总是大于子树中的值。可以在$O(1)$的时间内查找到最大值，但需要$O(logk)$时间完成删除和插入。这种解法没有修改原始输入。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="面试题54：二叉搜索树的第K个节点"><a href="#面试题54：二叉搜索树的第K个节点" class="headerlink" title="面试题54：二叉搜索树的第K个节点"></a>面试题54：二叉搜索树的第K个节点</h3><h4 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一颗二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）    中，按结点数值大小顺序第三小结点的值为4。</p><h4 id="解决方案-11"><a href="#解决方案-11" class="headerlink" title="解决方案"></a>解决方案</h4><p>BST中序遍历找到第K个节点就是返回值。时间复杂度为$O(k)$。</p><ul><li>java解法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="function">TreeNode <span class="title">KthNode</span><span class="params">(TreeNode pRoot, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span> || k &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode node = KthNode(pRoot.left, k);</span><br><span class="line">        <span class="keyword">if</span>(node != <span class="keyword">null</span>) <span class="keyword">return</span> node;</span><br><span class="line">        index++;</span><br><span class="line">        <span class="keyword">if</span>(k == index) <span class="keyword">return</span> pRoot;</span><br><span class="line">        node = KthNode(pRoot.right, k);</span><br><span class="line">        <span class="keyword">if</span>(node != <span class="keyword">null</span>) <span class="keyword">return</span> node;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="面试题55：二叉树的深度"><a href="#面试题55：二叉树的深度" class="headerlink" title="面试题55：二叉树的深度"></a>面试题55：二叉树的深度</h3><h4 id="题目描述-12"><a href="#题目描述-12" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p><h4 id="解决方案-12"><a href="#解决方案-12" class="headerlink" title="解决方案"></a>解决方案</h4><p>递归调用，判断左子树的深度和右子树的深度，返回深度时+1</p><ul><li>java解法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> l = TreeDepth(root.left), r = TreeDepth(root.right);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>+ (l&gt;r?l:r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="面试题55：二叉树的深度——平衡二叉树"><a href="#面试题55：二叉树的深度——平衡二叉树" class="headerlink" title="面试题55：二叉树的深度——平衡二叉树"></a>面试题55：二叉树的深度——平衡二叉树</h3><h4 id="题目描述-13"><a href="#题目描述-13" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p><h4 id="解决方案-13"><a href="#解决方案-13" class="headerlink" title="解决方案"></a>解决方案</h4><p>后序遍历的方式遍历整棵二叉树，遍历某节点的左右子节点之后，根据左右子节点的深度判断其是否为平衡二叉树，且得到当前节点的深度。遍历到最后节点的时候就可以判断其是否为平衡二叉树。这种方法每个节点只遍历一次。</p><ul><li>java解法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span> || isBalanced(root) != -<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">depthOfBST</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> leftDepth = depthOfBST(root.left);</span><br><span class="line">    <span class="keyword">if</span> (leftDepth == -<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> rightDepth = depthOfBST(root.right);</span><br><span class="line">    <span class="keyword">if</span> (rightDepth == -<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (Math.abs(leftDepth - rightDepth) &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + (leftDepth &gt; rightDepth ? leftDepth : rightDepth);</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="面试题68：树中两个节点的最低公共祖先"><a href="#面试题68：树中两个节点的最低公共祖先" class="headerlink" title="面试题68：树中两个节点的最低公共祖先"></a>面试题68：树中两个节点的最低公共祖先</h3><h4 id="题目描述-14"><a href="#题目描述-14" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入两个树节点，求他们的最低公共祖先。</p><h4 id="解决方案-14"><a href="#解决方案-14" class="headerlink" title="解决方案"></a>解决方案</h4><p>给定二叉搜索树时，因为二叉搜索树已近排序，位于左子树的节点都比右子树的节点小。从树的根节点开始，和两个输入的节点进行比较。如果当前节点的值比两个树节点的值都大，则目标节点一定是位于当前节点的左子树中，若小就位于右子树。从上到下遍历，找到的第一个在两个输入节点的值之间的节点就是最低的公共祖先。</p><ul><li>java解法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">findFirstCommon</span><span class="params">(TreeNode pNode, TreeNode qNode，TreeNode root)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>假设给定的树为普通树，且子树没有指向父节点的指针，那么应该记录从根节点到这两个节点的路径，然后转换成找到链表中的最后一个公共节点问题。</p><ul><li>java解法</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 获取两个节点的最低公共祖先</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">getLastCommonParent</span><span class="params">(TreeNode root, TreeNode p1, TreeNode p2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//path1和path2分别存储根节点到p1和p2的路径（不包括p1和p2）</span></span><br><span class="line">    List&lt;TreeNode&gt; path1 = <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;();</span><br><span class="line">    List&lt;TreeNode&gt; path2 = <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;();</span><br><span class="line">    List&lt;TreeNode&gt; tmpList = <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;();</span><br><span class="line"></span><br><span class="line">    getNodePath(root, p1, tmpList, path1);</span><br><span class="line">    getNodePath(root, p2, tmpList, path2);</span><br><span class="line">    <span class="comment">//如果路径不存在，返回空</span></span><br><span class="line">    <span class="keyword">if</span> (path1.size() == <span class="number">0</span> || path2.size() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> getLastCommonParent(path1, path2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取根节点到目标节点的路径</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getNodePath</span><span class="params">(TreeNode root, TreeNode target, List&lt;TreeNode&gt; tmpList, List&lt;TreeNode&gt; path)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//鲁棒性</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span> || root == target)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    tmpList.add(root);</span><br><span class="line">    List&lt;TreeNode&gt; children = root.children;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode node : children) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == target) &#123;</span><br><span class="line">            path.addAll(tmpList);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        getNodePath(node, target, tmpList, path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tmpList.remove(tmpList.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将问题转化为求链表最后一个共同节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">getLastCommonParent</span><span class="params">(List&lt;TreeNode&gt; p1, List&lt;TreeNode&gt; p2)</span> </span>&#123;</span><br><span class="line">    TreeNode tmpNode = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p1.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1.get(i) != p2.get(i))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        tmpNode = p1.get(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tmpNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Offer Problems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> java </tag>
            
            <tag> 剑指offer </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>剑指offer刷题总结（链表）</title>
      <link href="/2018/07/15/offer_problem/offerLinkList/"/>
      <url>/2018/07/15/offer_problem/offerLinkList/</url>
      <content type="html"><![CDATA[<h1 id="剑指offer总结——链表"><a href="#剑指offer总结——链表" class="headerlink" title="剑指offer总结——链表"></a><center>剑指offer总结——链表</center></h1><h3 id="面试题6：从尾到头打印链表"><a href="#面试题6：从尾到头打印链表" class="headerlink" title="面试题6：从尾到头打印链表"></a>面试题6：从尾到头打印链表</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。 </p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>解法一：使用栈的形式，将链表从头到尾入栈，最后依次出栈，时间复杂度及空间复杂度均为$O(n)$<br>解法二：递归</p><ul><li>java解法一：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span></span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (listNode == <span class="keyword">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (listNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">        stack.push(listNode.val);</span><br><span class="line">        listNode = listNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">        ans.add(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>java解法二：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">if</span>(listNode == <span class="keyword">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line">    ListNode pHead = listNode;</span><br><span class="line">    <span class="keyword">if</span>(pHead != <span class="keyword">null</span>)&#123;</span><br><span class="line">        ans = printList(pHead, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printList</span><span class="params">(ListNode pHead, ArrayList&lt;Integer&gt; ans)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pHead.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        ans = printList(pHead.next, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    ans.add(pHead.val);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>python解法：使用python insert函数</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printListFromTailToHead</span><span class="params">(self, listNode)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> listNode:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    arr = []</span><br><span class="line">    head = listNode</span><br><span class="line">    <span class="keyword">while</span> head:</span><br><span class="line">        arr.insert(<span class="number">0</span>, head.val)</span><br><span class="line">        head = head.next</span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure><h3 id="面试题18：删除链表的节点"><a href="#面试题18：删除链表的节点" class="headerlink" title="面试题18：删除链表的节点"></a>面试题18：删除链表的节点</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个单向链表的头指针的一个节点指针，实现一个函数在$O(1)$时间删除该节点</p><h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><p>常用的做法是遍历链表，找到目标节点，其时间复杂度为$O(n)$，不满足要求。要删除该节点，不一定非要找到目标节点的上一节点，只需要找到目标节点的下一节点，将其赋值给目标节点就可以了。</p><ul><li>链表有多个节点，要删除的不是尾节点需要$O(1)$的时间；</li><li>链表只有一个结点，删除头结点（也是尾结点）需要$O(1)$的时间；</li><li>链表有多个节点，要删除的是尾节点需要$O(n)$的时间</li></ul><p>并且在删除操作前，需要判断target节点是否确实在链表中，这样的查找需要$O(n)$的时间，但此处因为时间复杂度的要求，不加以判断。</p><ul><li>java解法</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode pHead, ListNode target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span> || target == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(target.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        ListNode temp = target.next;</span><br><span class="line">        target.val = temp.val;</span><br><span class="line">        target.next = temp.next;</span><br><span class="line">        temp = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pHead == target)&#123;</span><br><span class="line">        pHead = <span class="keyword">null</span>;</span><br><span class="line">        target = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        ListNode head = pHead;</span><br><span class="line">        <span class="keyword">while</span>(head.next != target)</span><br><span class="line">            head = head.next;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        target = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表中倒数第k个节点"><a href="#链表中倒数第k个节点" class="headerlink" title="链表中倒数第k个节点"></a>链表中倒数第k个节点</h3><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个链表，输出该链表中倒数第k个结点。 </p><h4 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h4><p>类似于滑动窗的做法，使用两个指针，让第一个指针先走k-1步，再让第一第二个指针同时走，当第一个指针走到链表尾部的时候，第二个指针正好指向倒数第K个结点。其时间复杂度为$O(n)$,空间复杂度为$O(1)$</p><ul><li>java解法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span><span class="params">(ListNode head,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    ListNode first = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || k &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> first.next;</span><br><span class="line">    &#125;</span><br><span class="line">    first = head;</span><br><span class="line">    ListNode second = head;</span><br><span class="line">    <span class="keyword">while</span>(--k &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        first = first.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (first == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(first.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        first = first.next;</span><br><span class="line">        second = second.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="面试题23：链表中环的入口节点"><a href="#面试题23：链表中环的入口节点" class="headerlink" title="面试题23：链表中环的入口节点"></a>面试题23：链表中环的入口节点</h3><h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><p>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。</p><h4 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h4><p>使用一个快指针，步长为2，慢指针，步长为1。如果链表中有环，两个指针在更新的过程中都不可能为null，当快慢指针第一次相遇时，根据其更新次数是相等的，然后快指针的路程是慢指针的2倍的关系，列出等式，然后让快指针从头结点开始走，慢指针从当前位置以相同的步长开始走。当他们相遇时，相遇的节点就是环的入口节点。时间复杂度为$O(n)$，空间复杂度为$O(1)$</p><ul><li>java解法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(pHead == <span class="keyword">null</span> || pHead.next == <span class="keyword">null</span> || pHead.next.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      ListNode slow = pHead.next, fast = slow.next;</span><br><span class="line">      <span class="keyword">while</span>(fast != slow)&#123;</span><br><span class="line">          slow = slow.next;</span><br><span class="line">          fast = fast.next.next;</span><br><span class="line">          <span class="keyword">if</span>(fast == <span class="keyword">null</span> || slow == <span class="keyword">null</span>)&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      fast = pHead;</span><br><span class="line">      <span class="keyword">while</span>(fast != slow)&#123;</span><br><span class="line">          fast = fast.next;</span><br><span class="line">          slow = slow.next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> fast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="面试题24：反转链表"><a href="#面试题24：反转链表" class="headerlink" title="面试题24：反转链表"></a>面试题24：反转链表</h3><h4 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个链表，反转链表后，输出新链表的表头。 </p><h4 id="解决方案-4"><a href="#解决方案-4" class="headerlink" title="解决方案"></a>解决方案</h4><p>使用两个指针更新链表，在循环内部使用一个temp Node保存当前结点的next结点，然后将head节点的next指向pre节点，此时完成了head节点的断链以及指向新链。然后将pre指向当前节点head， head指向其下一个节点temp。时间复杂度为$O(n)$，空间复杂度为$O(1)$</p><ul><li>java解法</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">        ListNode temp = head.next;</span><br><span class="line">        head.next = pre;</span><br><span class="line">        pre = head;</span><br><span class="line">        head = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="面试题25：合并两个排序的链表"><a href="#面试题25：合并两个排序的链表" class="headerlink" title="面试题25：合并两个排序的链表"></a>面试题25：合并两个排序的链表</h3><h4 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 </p><h4 id="解决方案-5"><a href="#解决方案-5" class="headerlink" title="解决方案"></a>解决方案</h4><p>创建一个头节点，使用while循环，遍历两个list，进行判断：</p><p>当头结点的下一个节点为list1的节点时，需要满足的条件为list2此时为null或（list1不为null且list1的小于list2的值）充分利用逻辑语句的短路性质，list2的判断方法相同。时间复杂度为$O(n)$,空间复杂度为$O(1)$</p><ul><li>java解法</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(list1 == <span class="keyword">null</span>) <span class="keyword">return</span> list2;</span><br><span class="line">    <span class="keyword">if</span>(list2 == <span class="keyword">null</span>) <span class="keyword">return</span> list1;</span><br><span class="line"></span><br><span class="line">    ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode ans = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(list1 != <span class="keyword">null</span> || list2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(list2 == <span class="keyword">null</span> || (list1 != <span class="keyword">null</span> &amp;&amp; list1.val &lt; list2.val))&#123;</span><br><span class="line">            ans.next = list1;</span><br><span class="line">            list1 = list1.next;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(list1 == <span class="keyword">null</span> || (list2 != <span class="keyword">null</span> &amp;&amp; list1.val &gt;= list2.val))&#123;</span><br><span class="line">            ans.next = list2;</span><br><span class="line">            list2 = list2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = ans.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="面试题35：复杂链表的复制"><a href="#面试题35：复杂链表的复制" class="headerlink" title="面试题35：复杂链表的复制"></a>面试题35：复杂链表的复制</h3><h4 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> label;</span><br><span class="line">    RandomListNode next = <span class="keyword">null</span>;</span><br><span class="line">    RandomListNode random = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    RandomListNode(<span class="keyword">int</span> label) &#123;</span><br><span class="line">        <span class="keyword">this</span>.label = label;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂链表示例：</p><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/offerProblems/772795.jpg" width="50%/"><br></center><h4 id="解决方案-6"><a href="#解决方案-6" class="headerlink" title="解决方案"></a>解决方案</h4><p>有一个巧妙的方法，使用链表结构本身来记录其sbiling指针的位置，分成三个步骤 </p><ul><li>根据原始链表的每个结点N创建对应的N’，并把N’连在N的后面。  如下图： </li></ul><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/offerProblems/76851960.jpg" width="75%/"><br></center><ul><li>根据原来的记录，N节点的random指向S节点，因此将复制出来的节点N’的random指向其对应的S’节点，如图所示</li></ul><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/offerProblems/6780607.jpg" width="75%/"><br></center><ul><li>将长链表拆分为两个短链表，将奇数位置的节点连接起来就是原链表，偶数位置的链表连接起来就是复制的链表。如图所示</li></ul><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/offerProblems/92955680.jpg" width="75%/"><br></center><p>这种方法的总体时间复杂度为$O(n)$,空间复杂度也为$O(n)$</p><ul><li>java解法</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RandomListNode <span class="title">Clone</span><span class="params">(RandomListNode pHead)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pHead == <span class="keyword">null</span>) <span class="keyword">return</span> pHead;</span><br><span class="line">    RandomListNode p = pHead, q = pHead, g = pHead;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="keyword">null</span>)&#123;</span><br><span class="line">        RandomListNode copy = <span class="keyword">new</span> RandomListNode(p.label);</span><br><span class="line">        copy.next = p.next;</span><br><span class="line">        p.next = copy;</span><br><span class="line">        p = copy.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(q.random != <span class="keyword">null</span>)&#123;</span><br><span class="line">            q.next.random = q.random.next;</span><br><span class="line">        &#125;</span><br><span class="line">        q = q.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    RandomListNode ans = <span class="keyword">new</span> RandomListNode(<span class="number">0</span>);</span><br><span class="line">    RandomListNode f = ans;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(g != <span class="keyword">null</span>)&#123;                         <span class="comment">//注意最后分开两个链表的方式，用局部变量</span></span><br><span class="line">        RandomListNode temp = g.next;</span><br><span class="line">        g.next = temp.next;</span><br><span class="line">        temp.next = f.next;</span><br><span class="line">        f.next = temp;</span><br><span class="line">        f = f.next;</span><br><span class="line">        g = g.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="面试题52：两个链表的第一个公共节点"><a href="#面试题52：两个链表的第一个公共节点" class="headerlink" title="面试题52：两个链表的第一个公共节点"></a>面试题52：两个链表的第一个公共节点</h3><h4 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入两个链表，找出它们的第一个公共结点。</p><h4 id="解决方案-7"><a href="#解决方案-7" class="headerlink" title="解决方案"></a>解决方案</h4><p>首先找到两个链表的长度，其长度的差值d+1就是链表公共节点的个数，然后然长的链表先走d步，然后短链表和长链表一起走，直到两个链表相遇，第一次相遇的节点就是他们相等的节点。时间复杂度$O(n)$,空间复杂度$O(1)$</p><ul><li>java解法</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pHead1 == <span class="keyword">null</span> || pHead2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> count1 = <span class="number">0</span>, count2 = <span class="number">0</span>;</span><br><span class="line">    ListNode p = pHead1, q = pHead2, p1 = p, q1 = q;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="keyword">null</span> || q != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p != <span class="keyword">null</span>)&#123;</span><br><span class="line">            count1++;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(q != <span class="keyword">null</span>)&#123;</span><br><span class="line">            count2++;</span><br><span class="line">            q = q.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count1 &gt; count2) <span class="keyword">return</span> findFirstNode(p1, q1, count1, count2);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> findFirstNode(q1, p1, count2, count1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">findFirstNode</span><span class="params">(ListNode p, ListNode q, <span class="keyword">int</span> count1, <span class="keyword">int</span> count2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> diff = count1 - count2;</span><br><span class="line">    <span class="keyword">while</span>(--diff &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == q) <span class="keyword">return</span> p;</span><br><span class="line">        p = p.next;</span><br><span class="line">        q = q.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="面试题62：圆圈中最后剩下的数字"><a href="#面试题62：圆圈中最后剩下的数字" class="headerlink" title="面试题62：圆圈中最后剩下的数字"></a>面试题62：圆圈中最后剩下的数字</h3><h4 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h4><p>击鼓传花，所有人围成一个圈，编号为0~n-1，共n人，指定一个数字m，每次循环喊数从0~m-1，喊到m-1的淘汰，直到剩下最后一个，返回这个人的编号。</p><h4 id="解决方案-8"><a href="#解决方案-8" class="headerlink" title="解决方案"></a>解决方案</h4><p>这是Josephuse环问题，可以用经典的解法：使用环形链表模拟圆圈，创建有m个节点的环形链表，然后每次在链表中删除第n个节点，但总体的时间复杂度为$O(m*n)$,空间复杂度为$O(n)$</p><p>一种创新性解法是使用根据题目本身的数学关系，用数学归纳法，建立公式求解，最终实现时间复杂度为$O(n)$，空间复杂度为$O(1)$</p><p>问题描述：n个人（编号0~(n-1))，从0开始报数，报到(m-1)的退出，剩下的人 继续从0开始报数。求胜利者的编号。<br>我们知道第一个人(编号一定是m%n-1)出列之后，剩下的n-1个人组成了一个新的约瑟夫环（以编号为k=m%n的人开始）:<br>$$<br>k , k+1,  k+2,  … n-2, n-1, 0, 1, 2, … k-2并且从k开始报0。<br>$$<br>现在我们把他们的编号做一下转换：</p><p>$$<br>\begin{equation}<br>\begin{aligned}<br>&amp;k     –&gt; 0 \<br>&amp;k+1   –&gt; 1 \<br>&amp;k+2   –&gt; 2 \<br>&amp;… \<br>&amp;… \<br>&amp;k-2   –&gt; n-2 \<br>&amp;k-1   –&gt; n-1<br> \end{aligned}<br>\end{equation}<br>$$</p><p>变换后成为了(n-1)个人报数的子问题，假如知道这个子问题的解：如$x$是最终的胜利者，根据上面的表把$x$变回去刚好就是$n$个人情况的解。变回去的公式为：<br>$$<br>x’=(x+k)%n<br>$$<br>令$f[i]$表示$i$个人玩游戏报$m$退出最后胜利者的编号，最后的结果是$f[n]$。</p><p>递推公式<br>$$<br>\begin{equation}<br>f[1]=0;\<br>…\<br>f[i] = f([i-1] + m) \%i;  (i&gt;1)<br>\end{equation}<br>$$<br>有了这个公式，我们要做的就是从1-n顺序算出f[i]的数值，最后结果是f[n]。 因为实际生活中编号总是从1开始，我们输出f[n]+1。</p><ul><li>java解法</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(unsigned <span class="keyword">int</span> n, unsigned <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> (LastRemaining_Solution(n-<span class="number">1</span>,m)+m)%n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Offer Problems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> java </tag>
            
            <tag> 剑指offer </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>图像处理基本方法</title>
      <link href="/2018/07/12/computer_version/imgProcession/"/>
      <url>/2018/07/12/computer_version/imgProcession/</url>
      <content type="html"><![CDATA[<h1 id="数字图像处理基本原理及方法"><a href="#数字图像处理基本原理及方法" class="headerlink" title="数字图像处理基本原理及方法"></a>数字图像处理基本原理及方法</h1><p>数字图像处理是指将图像信号转换成数字信号并利用计算机对其进行处理的过程。图像处理最早出现于 20 世纪 50 年代，当时的电子计算机已经发展到一定水平，人们开始利用计算机来处理图形和图像信息。数字图像处理作为一门学科大约形成于 20 世纪 60 年代初期。早期的图像处理的目的是改善图像的质量，它以人为对象，以改善人的视觉效果为目的。图像处理中，输入的是质量低的图像，输出的是改善质量后的图像，常用的图像处理方法有图像增强、复原、编码、压缩等。 </p><h2 id="数字图像处理常用方法"><a href="#数字图像处理常用方法" class="headerlink" title="数字图像处理常用方法"></a>数字图像处理常用方法</h2><ol><li>图像变换</li></ol><p>由于图像阵列很大，直接在空间域中进行处理，涉及计算量很大。因此，往往采用各种图像变换的方法，如傅立叶变换、沃尔什变换、离散余弦变换等间接处理技术，将空间域的处理转换为变换域处理，不仅可减少计算量，而且可获得更有效的处理（如傅立叶变换可在频域中进行数字滤波处理）。目前新兴研究的小波变换在时域和频域中都具有良好的局部化特性，它在图像处理中也有着广泛而有效的应用。 </p><ol start="2"><li>图像编码压缩</li></ol><p>图像编码压缩技术可减少描述图像的数据量（即比特数），以便节省图像传输、处理时间和减少所占用的存储器容量。压缩可以在不失真的前提下获得，也可以在允许的失真条件下进行。编码是压缩技术中最重要的方法，它在图像处理技术中是发展最早且比较成熟的技术。 </p><ol start="3"><li>图像增强和复原</li></ol><p>图像增强和复原的目的是为了提高图像的质量，如去除噪声，提高图像的清晰度等。图像增强不考虑图像降质的原因，突出图像中所感兴趣的部分。如强化图像高频分量，可使图像中物体轮廓清晰，细节明显；如强化低频分量可减少图像中噪声影响。图像复原要求对图像降质的原因有一定的了解，一般讲应根据降质过程建立“降质模型”，再采用某种滤波方法，恢复或重建原来的图像。 </p><ol start="4"><li>图像分割</li></ol><p>图像分割是数字图像处理中的关键技术之一。图像分割是将图像中有意义的特征部分提取出来，其有意义的特征有图像中的边缘、区域等，这是进一步进行图像识别、分析和理解的基础。虽然目前已研究出不少边缘提取、区域分割的方法，但还没有一种普遍适用于各种图像的有效方法。因此，对图像分割的研究还在不断深入之中，是目前图像处理中研究的热点之一。 </p><ol start="5"><li>图像描述</li></ol><p>图像描述是图像识别和理解的必要前提。作为最简单的二值图像可采用其几何特性描述物体的特性，一般图像的描述方法采用二维形状描述，它有边界描述和区域描述两类方法。对于特殊的纹理图像可采用二维纹理特征描述。随着图像处理研究的深入发展，已经开始进行三维物体描述的研究，提出了体积描述、表面描述、广义圆柱体描述等方法。 </p><ol start="6"><li>图像分类</li></ol><p>图像分类（识别）属于模式识别的范畴，其主要内容是图像经过某些预处理（增强、复原、压缩）后，进行图像分割和特征提取，从而进行判决分类。图像分类常采用经典的模式识别方法，有统计模式分类和句法（结构）模式分类，近年来新发展起来的模糊模式识别和人工神经网络模式分类在图像识别中也越来越受到重视。 </p><h3 id="图像基本属性"><a href="#图像基本属性" class="headerlink" title="图像基本属性"></a>图像基本属性</h3><ol><li>亮度（brightness）也称为灰度，它是颜色的明暗变化，常用 0 ％～ 100 ％ ( 由黑到白 ) 表示。</li><li>色调（Hue）</li><li>饱和度（Saturation）</li><li>Hue + Saturation = chromaticity色度</li><li>直方图（histogram）表示图像中具有每种灰度级的象素的个数，反映图像中每种灰度出现的频率。图像在计算机中的存储形式，就像是有很多点组成一个矩阵，这些点按照行列整齐排列，每个点上的值就是图像的灰度值，直方图就是每种灰度在这个点矩阵中出现的次数。</li><li>对比度（contrast）</li></ol><h4 id="数字图像间的距离"><a href="#数字图像间的距离" class="headerlink" title="数字图像间的距离"></a>数字图像间的距离</h4><ul><li>欧式距离（Euclidean）：$D_{E}[(i,j),(h,k)] = \sqrt {(i-h)^{2} + (j - k)^{2}}$</li><li>城市距离（City block）：$D_{4}[(i,j),(h,k)] =\left | i-h\right | + \left | j - k\right |$</li><li>棋盘距离（Chessboard）：$D_{8}[(i,j),(h,k)]=max ( |i-h|+|j-k| )$</li></ul><h4 id="图像增强相关操作"><a href="#图像增强相关操作" class="headerlink" title="图像增强相关操作"></a>图像增强相关操作</h4><ol><li>直方图均衡（Histogram equalization ）</li><li>直方图匹配（Histogram matching ）</li><li>局部增强（Local enhancement）</li></ol><h4 id="常见噪声"><a href="#常见噪声" class="headerlink" title="常见噪声"></a>常见噪声</h4><ul><li>加性噪声：噪声和图像信息独立$f(x,y) = g(x, y) + v(x,y)$</li><li>乘性噪声：噪声量级取决于图像信息的量级$f(x,y) =  g(x, y) +  g(x, y) \times v(x,y)$</li><li>量化噪声：当量化强度不够时会产生量化噪声</li><li>冲击噪声：典型代表椒盐噪声（salt and pepper noise）用中值滤波去除</li></ul><h3 id="图像预处理"><a href="#图像预处理" class="headerlink" title="图像预处理"></a>图像预处理</h3><p>图像预处理分为四个类，分别为：</p><ol><li>pixel brightness transformations 像素亮度变换</li><li>geometric transformation几何变换</li><li>pre-processing methods that use a local neighborhood of the processed pixel 使用处理过的像素处理未处理过的像素</li><li>image restoration 图像重建</li></ol><h4 id="pixel-brightness-transformations-像素亮度变换"><a href="#pixel-brightness-transformations-像素亮度变换" class="headerlink" title="pixel brightness transformations 像素亮度变换"></a>pixel brightness transformations 像素亮度变换</h4><p>pixel brightness transformations 像素亮度变换，其变化只取决于像素本身，其包括两种：</p><ul><li>Brightness Corrections：仅考虑图像中原来的亮度及像素位置；</li><li>Gray Scale Transformations（灰度变换） ：改变像素亮度时和像素在图中的位置无关。对于输入图象$f(x，y)$，输出图像$g(x，y)$，$T(in)$为灰度变换函数，则$g(x，y)=T( f(x，y) )$。<ul><li>主要目的：<ul><li>改善画质，使图像显示效果更加清晰</li><li>有选择性地突出图像中感兴趣的特征或抑制某些不需要的特征，使图像与视觉响应特征相匹配（图像增强）</li></ul></li><li>主要应用：<ul><li>图像求反：这种方法适用于增强嵌入图像暗色区域的白色或灰色细节。</li><li>对比度拉伸；</li><li>图像灰度分割（二值化）：在图像处理领域，二值图像运算量小，并且能够体现图像的关键特征，因此被广泛使用。</li></ul></li></ul></li></ul><h3 id="图像增强"><a href="#图像增强" class="headerlink" title="图像增强"></a>图像增强</h3><h4 id="直方图均衡"><a href="#直方图均衡" class="headerlink" title="直方图均衡"></a>直方图均衡</h4><p>通过灰度变换将一幅图像转换为另一幅具有均衡直方图的图像，即在一定灰度范围内具有相同的象素点数的图像的过程。通过这种方法，亮度可以更好地在直方图上分布。这样就可以用于增强局部的对比度而不影响整体的对比度，直方图均衡化通过有效地扩展常用的亮度来实现这种功能。<br>这种方法对于背景和前景都太亮或者太暗的图像非常有用，这种方法尤其是可以带来X光图像中更好的骨骼结构显示以及曝光过度或者曝光不足照片中更好的细节。这种方法的一个主要优势是它是一个相当直观的技术并且是可逆操作，如果已知均衡化函数，那么就可以恢复原始的直方图，并且计算量也不大。<br>这种方法的一个缺点是它对处理的数据不加选择，它可能会增加背景噪声的对比度并且降低有用信号的对比度。<br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/computerVersion/57057553.jpg" alt=""></p><h4 id="直方图匹配"><a href="#直方图匹配" class="headerlink" title="直方图匹配"></a>直方图匹配</h4><p>直方图规定化（histogram specification）又称直方图匹配，是指使一幅图像的直方图变成规定形状的直方图而对图像进行变换的增强方法。就是通过一个灰度映像函数，将原灰度直方图改造成所希望的直方图。所以，直方图修正的关键就是灰度映像函数。<br>直方图规定化原理是对两个直方图都做均衡化，变成相同的归一化的均匀直方图。以此均匀直方图起到媒介作用，再对参考图像做均衡化的逆运算即可。直方图均衡化是直方图规定化的桥梁。<br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/computerVersion/90622666.jpg" alt=""></p><h4 id="局部增强"><a href="#局部增强" class="headerlink" title="局部增强"></a>局部增强</h4><p>Local preprocessiong 也称为filtering，根据图像处理的目的分为两类：</p><h5 id="平滑（smoothing）"><a href="#平滑（smoothing）" class="headerlink" title="平滑（smoothing）"></a>平滑（smoothing）</h5><p>使用低通滤波器可以抑制高频成分（sharp image details），使图像变模糊。图像平滑的目的是抑制噪声及图片中的波动，和在频域抑制高频的作用相同。<br>缺点：平滑会损失边缘信息，丢失重要的边界信息。filter尺寸越大，丢失信息越多。</p><ul><li><p>Image Smoothing-Average<strong>均值滤波</strong><br>均值滤波是一种<strong>线性滤波</strong>操作，输出图像的每一个像素是核窗口内输入图像对应像素的像素的平均值( 所有像素加权系数相等)。相当于给图像经过一个$n*n$的卷积核，卷积核的系数都为1。<br>均值滤波算法比较简单，计算速度快，但是均值滤波本身存在着固有的缺陷，即它不能很好地保护图像细节，在图像去噪的同时，也破坏了图像的细节部分，从而使图像变得模糊，不能很好地去除噪声点。但均值滤波对周期性的干扰噪声有很好的抑制作用。</p></li><li><p>Median Filter <strong>中值滤波</strong><br>中值滤波法是一种<strong>非线性平滑技术</strong>，将图像的每个像素用邻域 (以当前像素为中心的正方形区域)像素的<strong>中值</strong>代替 ，常用于消除图像中的<strong>椒盐噪声</strong>。</p><p>与低通滤波不同的是，中值滤波对脉冲噪声有良好的滤除作用，特别是在滤除噪声的同时，<strong>能够保护信号的边缘，使之不被模糊</strong>，但它会洗去均匀介质区域中的纹理。这些优良特性是线性滤波方法所不具有的。<br>中值滤波能减弱或消除傅里叶空间的高频分量，同时也影响低频分量。中值滤波去除噪声的效果依赖于两个要素：邻域的空间范围和中值计算中涉及的像素数。一般说来，小于滤波器面积一半的亮或暗的物体基本上会被滤除，而较大的物体几乎会原封不动地保存下来，因此中值滤波器的空间尺寸必须根据现有的问题来进行调整。<br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/computerVersion/25880713.jpg" alt=""></p></li><li><p>Maximum and Minimum Filters极大极小滤波器<br>极大值极小值滤波器是两个串联滤波器，可以用于消除椒盐噪声。极大值滤波器移除pepper-type（小值）噪声，极小值滤波器移除salt-type（大值）噪声。</p></li></ul><h5 id="锐化（sharpening）"><a href="#锐化（sharpening）" class="headerlink" title="锐化（sharpening）"></a>锐化（sharpening）</h5><p>使用高通滤波器可以抑制低频成分，锐化图像的边缘，增强图片细节</p><ul><li>Derivative operators <strong>差分滤波器</strong><br>一阶微分：$\frac{\partial f}{\partial x}= f(x+1) - f(x)$<br>一阶微分会产生较粗的边缘，因为沿着斜坡的积分非零。主要检测极值。<br>二阶微分：$\frac{\partial ^{2} f}{\partial x^{2}}= f(x+1) + f(x-1) -2f(x)$<br>二阶微分在增强细节方面要比一阶微分好得多，这是一个适合锐化图像的理想特性。因此常用二阶微分来进行图像增强。典型的二阶微分算子是<strong>拉普拉斯算子</strong>：<br>$$<br>\triangledown^{2}f=\frac{\partial ^{2} f}{\partial x^{2}}+\frac{\partial ^{2} f}{\partial y^{2}}<br>$$<br>$$<br>\frac{\partial ^{2} f}{\partial x^{2}}= f(x+1,y) + f(x-1,y) -2f(x,y)<br>$$<br>$$<br>\frac{\partial ^{2} f}{\partial x^{2}}= f(x,y+1) + f(x,y-1) -2f(x,y)<br>$$<br>$$<br>\triangledown^{2}f= f(x+1,y) + f(x-1,y) + f(x,y+1) + f(x,y-1)-4f(x,y)<br>$$</li></ul><p><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/computerVersion/20812166.jpg" alt=""></p><p>由于拉普拉斯是一种微分算子，因此其应用强调的是图像中的灰度突变，并不强调灰度级缓慢变化的区域。<br>将原图像和拉普拉斯图像叠加在一起的简单方法，可以复原背景特性并保持拉普拉斯锐化处理的效果。<br>$$<br>g(x,y) = f(x,y) + \triangledown^{2}f(x, y)<br>$$<br>如果所使用的模板定义有负的中心系数，那么必须将原图像减去经拉普拉斯变换后的图像，而不是加上他，从而得到锐化后的结果。</p><ul><li>High-boost Filter<strong>高频提升滤波器</strong></li></ul><p>高通滤波后的图像= 原图-低通滤波后的图像<br>$$<br>\begin{equation}<br>\begin{aligned}<br>Hight-boost &amp; = A \times original - lowpass(blurred) \<br>&amp; = A \times original - lowpass(blurred) \<br>&amp; = (A-1) \times original + original - lowpass(blurred)<br> \end{aligned}<br>\end{equation}<br>$$<br>当$A=1$时，为标准的高通滤波器，</p><p>当$A &gt; 1$时，部分原图抵消了高通滤波部分，保留了低频部分。</p><p>高频提升滤波器是图像处理的基础工具，常用于印刷出版业。</p><p><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/computerVersion/2387564.jpg" alt=""></p><p>带通滤波器移除选择的频带，用于图像重建，不用于图像增强</p><ul><li>卷积和相关</li></ul><p>卷积是一个filter的作用，相关是两个信号关联的度量。</p><h4 id="频域增强"><a href="#频域增强" class="headerlink" title="频域增强"></a>频域增强</h4><h5 id="傅里叶变换（FT）"><a href="#傅里叶变换（FT）" class="headerlink" title="傅里叶变换（FT）"></a>傅里叶变换（FT）</h5><p>$$<br>\mathfrak{F}(f(x))= \int_{-\infty }^{+\infty}f(x)\cdot e^{-j2\pi ux}dx<br>$$</p><p>反变换：<br>$$<br>\mathfrak{F}  ^{-1} (F(u) ) = \int_{-\infty }^{+\infty}F(u)\cdot e^{j2\pi ux}du<br>$$<br>离散傅里叶变化可以分为实数部分和虚数部分：<br>$$<br>\begin{equation}<br>\begin{aligned}<br>F(u) &amp;= \frac{1}{M}\sum_{x=0}^{M-1}f(x)[cos\frac{2\pi ux}{M} - jsin\frac{2\pi ux}{M}]\<br>&amp;=R(u)+jI(u)\<br>&amp;=\left | F(u) \right |e^{-j\varphi (u)}<br> \end{aligned}<br>\end{equation}<br>$$<br>其中幅值和相位分别为：<br>$$<br>\left | F(u) \right | =\sqrt{ R^{2}(u)+I^{2}(u)}\<br>\varphi (u)=arctan()\frac{I(u)}{R(u)}\<br>P(u) = \left | F(u) \right |^{2} = R^{2}(u)+I^{2}(u)<br>$$<br>时域位移和频域位移的对应关系：<br>$$<br>f(x,y)e^{j2\pi (\frac{u_{0}x}{M} + \frac{v_{0}y}{N})}\Leftrightarrow F(u-u_{0}, v-v_{0})\<br>f(x-x_{0}, y-y_{0}) \Leftrightarrow F(u,v)e^{-j2\pi (\frac{u_{0}x}{M} + \frac{v_{0}y}{N})}<br>$$<br>也即是在时域移动$(x_{0},y_{0})$，对应频域上是幅值不变，相位移动。</p><p>频域增强操作：</p><p><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/computerVersion/34598712.jpg" alt=""></p><p>频域滤波器分类：</p><ul><li>低通滤波器：图像模糊、平滑——例如巴特沃斯滤波器、高斯低通滤波器</li><li>高通滤波器：增大高频幅值，对应锐化操作——巴特沃斯高通滤波器、高斯高通滤波器</li></ul><h6 id="Butterworth低通滤波器"><a href="#Butterworth低通滤波器" class="headerlink" title="Butterworth低通滤波器"></a>Butterworth低通滤波器</h6><p>$$<br>H(u,v)=\frac{1}{1+(\frac{D(u,v)}{D_{0}})^{2n}}<br>$$</p><p><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/computerVersion/55623921.jpg" alt=""></p><ul><li>n越大，Butterworth低通滤波器越接近于理想低通滤波器，但会出现振铃效应</li><li>其有3db不变性</li><li>有平坦性</li></ul><h6 id="Gaussian低通滤波器"><a href="#Gaussian低通滤波器" class="headerlink" title="Gaussian低通滤波器"></a>Gaussian低通滤波器</h6><p>$$<br>H(u,v)=e^{\frac{-D^{2}(u,v)}{2\sigma ^{2}}}<br>$$</p><p><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/computerVersion/13819824.jpg" alt=""></p><ul><li>$D_{0}$越小，越接近理想低通滤波器</li></ul><p>低通滤波器应用：平滑印刷字体</p><p><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/computerVersion/90373906.jpg" alt=""></p><h6 id="Butterworth高通滤波器"><a href="#Butterworth高通滤波器" class="headerlink" title="Butterworth高通滤波器"></a>Butterworth高通滤波器</h6><p>$$<br>H_{hp}(u,v)=1-H_{lp}{(u,v)}\<br>H(u,v)=\frac{1}{1+(\frac{D_{0}}{D(u,v)})^{2n}}<br>$$</p><p>和低通滤波器正好相反。增加一个常数项保存低频部分信息。</p><p><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/computerVersion/50235930.jpg" alt=""></p><h6 id="Gaussian高通滤波器"><a href="#Gaussian高通滤波器" class="headerlink" title="Gaussian高通滤波器"></a>Gaussian高通滤波器</h6><p>$$<br>H(u,v)=1-e^{\frac{-D^{2}(u,v)}{2\sigma ^{2}}}<br>$$</p><p>$\sigma = D_{0}$是cutoff频率</p><h5 id="频域拉普拉斯变换"><a href="#频域拉普拉斯变换" class="headerlink" title="频域拉普拉斯变换"></a>频域拉普拉斯变换</h5><p>时域微分对应傅里叶变换为频域乘上$(ju)$：<br>$$<br>F[\frac{d^{n}f(x)}{dx^{n}}] = (ju)^{n}F(u)\<br>F[\frac{\partial ^{2}f(x,y)}{\partial x^{2}}+\frac{\partial ^{2}f(x,y)}{\partial y^{2}}] =- (u^{2}+v^{2})F(u,v)<br>$$<br>因此Laplacian可以看做是使用$H(u,v) = -(u^{2}+v^{2})$的滤波器。</p><p>带有中心点的Laplacian，其傅里叶变换对为：<br>$$<br>\triangledown ^{2}f(x,y) \Leftrightarrow -[(u-\frac{M}{2})^{2} +(v - \frac{N}{2})^{2}]F(u,v)<br>$$<br>在频域，Laplacian相当于一个函数中心在$(\frac{M}{2}, \frac{N}{2})$，且在顶点处的值为0，其他值为负的函数。</p><p>图像增强使用方法是原图减去拉普拉斯变换后的图：<br>$$<br>g(x,y) = f(x,y)-\triangledown^{2}f(x,y)\<br>g(x,y) =\mathfrak{F} ^{-1} ( 1-[(u-\frac{M}{2})^{2} +(v-\frac{N}{2})^{2}]F(u,v) )<br>$$</p><h6 id="Unsharp-masking"><a href="#Unsharp-masking" class="headerlink" title="Unsharp masking"></a>Unsharp masking</h6><p>$$<br>H_{hp}(u,v)=1-H_{lp}{(u,v)}\<br>$$</p><h6 id="High-boost-filtering"><a href="#High-boost-filtering" class="headerlink" title="High-boost filtering"></a>High-boost filtering</h6><p>$$<br>H_{hp}(u,v)=(A-1)+H_{hp}{(u,v)}\<br>$$</p><h6 id="Hight-frequency-emphasis-filtering"><a href="#Hight-frequency-emphasis-filtering" class="headerlink" title="Hight frequency emphasis filtering"></a>Hight frequency emphasis filtering</h6><p>$$<br>H_{hfe}(u,v)=a+bH_{hp}{(u,v)}<br>$$</p><h4 id="高斯金字塔"><a href="#高斯金字塔" class="headerlink" title="高斯金字塔"></a>高斯金字塔</h4><p>高斯金字塔背后的理论基础为尺度空间理论。 这个的概念可以用在任意维度的信号中，不过最常用的地方还是在二维的影像信号上，以二维影像信号作为主要讨论对象。 给定一张图片$ f(x,y)$它的尺度空间表示方式$ L(x,y;t)$定义为:影像信号$f(x,y)$和高斯函数$g(x,y;t)={\frac {1}{2{\pi }t}}e^{-(x^{2}+y^{2})/2t}$的卷积，完整公式为：<br>$$<br>L(x,y;t)=g(x,y;t)*f(x,y)<br>$$<br>式中的分号代表卷积的对象为 $x,y$而分号右边的$t$表示定义的尺度大小。 这个定义当$ t\geq 0$ 时对于所有的$t$都会成立，不过通常在实际操作时只会选取特定的$t$值。 其中$t$为高斯函数的变异数。当$t$趋近于零的时候，$g$成为一个单位脉冲响应，使得$ L(x,y;t)\ =f(x,y)$ ，这代表当 $t=0$的时候我们可以把这项操作视为图片$f$本身。 当$t$增加时，$L$代表将影像$f$通过一个较大的高斯滤波器，从而使得影像的细节被去除更多。</p><p>在建立高斯金字塔的时候，首先会将影像转换为尺度空间的表示方式，亦即乘上不同大小的高斯函数，之后再依据取定的尺度向下取样。 乘上的高斯函数大小和向下取样的频率通常会选为2的幂次，也就是说，在每次迭代的过程中，影像都会被乘上一个固定大小的高斯函数，并且被以长宽各0.5的比率被向下取样。 如果将向下取样过程的图片一张一张叠在一起，会呈现一个金字塔的样子，因此这个过程称为高斯金字塔。 </p><p><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/computerVersion/98042535.jpg" alt=""></p><p>高斯金字塔使用：</p><ul><li>如果物体的尺寸很小或者说对比度不高，通常则需要采用较高的分辨率来观察。</li><li>如果物体的尺寸很大或者说对比度很强，那么就仅仅需要较低的分辨率就能够来传观了。</li><li>那如果现在物体的尺寸有大有小，对比度有强有弱，这些关系同时存在，这个时候需要使用多分辨率处理</li></ul><h4 id="同态滤波器（Homomorphic-Filter）"><a href="#同态滤波器（Homomorphic-Filter）" class="headerlink" title="同态滤波器（Homomorphic Filter）"></a>同态滤波器（Homomorphic Filter）</h4><p>对于一副图像$f(x,y)$可由照射分量$i(x,y)$和反射分量$r(x,y)$的乘积，即<br>$$<br>f(x,y)=i(x,y)*r(x,y)<br>$$<br>由于照度相对变化很小，可以看作是图像的低频成份，而反射率则是高频成份。通过分别处理照度和反射率对像元灰度值的影响，达到揭示阴影区细节特征的目的。 </p><p>上式不能直接用于对照度和反射的频率分量进行操作，因此上式取对数  :<br>$$<br>Inf(x,y)=lni(x,y)+lnr(x,y)<br>$$<br>对上式两边取傅里叶变换：<br>$$<br>\mathfrak{F}(Inf(x,y) )=\mathfrak{F} (Ini(x,y) )+\mathfrak{F}  (Inr(x,y) )<br>$$<br>图像的照射分量通常由慢的空间变化来表征，而反射分量往往引起突变，特别是在不同物体的连接部分。这些特性导致图像取对数后的傅里叶变换的低频成分与照射相联系，而高频成分与反射相联系。  </p><p><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/computerVersion/672660.jpg" alt=""></p><p>使用同态滤波器可以更好地控制照射分量和反射分量。这种控制器需要指定一个滤波器函数$H(u,v)$，它可用不同的可控方法影响傅里叶变换的低频和高频。如果$γL$和$γH$选定，而$γL&lt;1$且$γH&gt;1$，那么滤波器函数趋近于衰减低频（照射）的贡献，而增强高频反射的贡献。最终结果是同时进行动态范围抑制低频，增强对比度。  </p><p>使用同态滤波器步骤：</p><p><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/computerVersion/62116892.jpg" alt=""></p><p><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/computerVersion/56382828.jpg" alt=""></p><p>同态滤波是一个比较经典的算法，有论文说可以去雾。但对水中图像效果确是极好的。另外同态滤波主要用于预处理阶段去除光照不均的影响，这用顶帽变化也可以的。 </p><h3 id="图像重建"><a href="#图像重建" class="headerlink" title="图像重建"></a>图像重建</h3><p>目标：</p><ul><li>在某些方面提升图像</li><li>使用图像退化的先验知识来修复图像</li><li>主要方法即创建图像退化模型，反向操作处理退化的图像</li></ul><p>重建包括两部分，一个是退化函数，另一部分是噪声。</p><p>在空间域中，生成模型形式为：<br>$$<br>d(x,y) = h(x,y) * I(x,y) + n(x,y)<br>$$<br>频域中，生成模型为：<br>$$<br>D(u,v) = H(u,v)I(u,v) + N(u,v)<br>$$</p><h4 id="造成图像退化的原因："><a href="#造成图像退化的原因：" class="headerlink" title="造成图像退化的原因："></a>造成图像退化的原因：</h4><ul><li><p>物体和摄像头的相对移动</p><p>这时采用的$H(u,v)=\frac{sin(\pi VTu)}{\pi VTu}$，其中$T$是拍摄时间</p></li><li><p>不当的镜头焦距</p><p>此时的$H(u,v) = \frac{j_{1}(ar)}{ar}$，其中$j_{1}$—-</p></li><li><p>大气扰动</p></li></ul><h4 id="逆滤波（Inverse-filtration）"><a href="#逆滤波（Inverse-filtration）" class="headerlink" title="逆滤波（Inverse filtration）"></a>逆滤波（Inverse filtration）</h4><p>与噪声无关，限定半径</p><h4 id="维纳滤波（Wiener-filtration）"><a href="#维纳滤波（Wiener-filtration）" class="headerlink" title="维纳滤波（Wiener filtration）"></a>维纳滤波（Wiener filtration）</h4><p>在噪声环境下效果很好</p>]]></content>
      
      <categories>
          
          <category> Computer Version </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CV </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> 原理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>剑指offer刷题总结（数组）</title>
      <link href="/2018/07/12/offer_problem/offerArray/"/>
      <url>/2018/07/12/offer_problem/offerArray/</url>
      <content type="html"><![CDATA[<h1 id="剑指offer总结——数组"><a href="#剑指offer总结——数组" class="headerlink" title="剑指offer总结——数组"></a><center>剑指offer总结——数组</center></h1><h3 id="面试3：数组中的重复数字"><a href="#面试3：数组中的重复数字" class="headerlink" title="面试3：数组中的重复数字"></a>面试3：数组中的重复数字</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>重排数组，指针从第一个下标开始，指针index等于数组中指针指向的数就移动到下一个，如果不是，就将指针指向数组中数字的index，直到指针index和它指向的数字相等。时间复杂度$O(n)$，空间复杂度$O(1)$。</p><ul><li><p>java解法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[],<span class="keyword">int</span> length,<span class="keyword">int</span> [] duplication)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numbers == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers[i] &lt; <span class="number">0</span> || numbers[i] &gt;= numbers.length) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(numbers[i] != i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[i] == numbers[numbers[i]])&#123;</span><br><span class="line">                duplication[<span class="number">0</span>] = numbers[i];</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> temp = numbers[i];</span><br><span class="line">            numbers[i] = numbers[temp];</span><br><span class="line">            numbers[temp] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>python解法</p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">duplicate</span><span class="params">(self, numbers, duplication)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> numbers == <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(numbers)<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> numbers[i] &lt; <span class="number">0</span> <span class="keyword">or</span> numbers[i] &gt;len(numbers)<span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">while</span> numbers[i] != i:</span><br><span class="line">            <span class="keyword">if</span> numbers[i] == numbers[numbers[i]]:</span><br><span class="line">                duplication[<span class="number">0</span>] = numbers[i]</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            temp = numbers[i]</span><br><span class="line">            numbers[i] = numbers[temp]</span><br><span class="line">            numbers[temp] = temp</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h3 id="面试4：二位数组中的查找"><a href="#面试4：二位数组中的查找" class="headerlink" title="面试4：二位数组中的查找"></a>面试4：二位数组中的查找</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><p>选取左下角的数字作为起始点，如果目标数比这个数字大，就往右走一步，比目标数字小就往左走一步，若下标越界则没找到，返回false。时间复杂度为$O(n)$，空间复杂度为$O(1)$</p><ul><li><p>java解法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = array.length;</span><br><span class="line">    <span class="keyword">int</span> m = array [<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span> i = n - <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; j &lt; m)&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == array[i][j]) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; array[i][j]) j++;</span><br><span class="line">        <span class="keyword">else</span> i--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>python解法</p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Find</span><span class="params">(self, target, array)</span>:</span></span><br><span class="line">    <span class="comment"># write code here</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(target, (int, float)):</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">if</span> array == <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    m = len(array)</span><br><span class="line">    n = len(array[<span class="number">0</span>])</span><br><span class="line">    i = m<span class="number">-1</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &lt; n:</span><br><span class="line">        <span class="keyword">if</span> array[i][j] == target:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">elif</span> array[i][j] &lt; target:</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h3 id="面试题21：调整数组顺序使奇数位于偶数前面"><a href="#面试题21：调整数组顺序使奇数位于偶数前面" class="headerlink" title="面试题21：调整数组顺序使奇数位于偶数前面"></a>面试题21：调整数组顺序使奇数位于偶数前面</h3><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p><h4 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h4><p>用两个指针维护数组，第一个指针在头，第二个指针在尾，如果第一个指向偶数，第二个指向奇数，则交换两个数字。时间复杂度为$O(n)$，空间复杂度为$O(1)$。</p><h5 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h5><p>书中没有保持数组位置的相对稳定性，在空间复杂度为$O(1)$的情况下需要使用插入排序或归并排序的方法。此时的时间复杂度为$O(n^{2})$。</p><ul><li>java解法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(array == <span class="keyword">null</span> || array.length == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((array[i] &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>((array[j - <span class="number">1</span>] &amp; <span class="number">1</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = array[j];</span><br><span class="line">                    array[j] = array[j-<span class="number">1</span>];</span><br><span class="line">                    array[j-<span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h5><p>使用python直接写简单的排序数组，顺序不变，时间复杂度$O(n)$，空间复杂度$O(n)$。</p><ul><li>python解法<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reOrderArray</span><span class="params">(self, array)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> array <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> len(array) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> array</span><br><span class="line">    left = [x <span class="keyword">for</span> x <span class="keyword">in</span> array <span class="keyword">if</span> x &amp; <span class="number">1</span>]</span><br><span class="line">    right = [x <span class="keyword">for</span> x <span class="keyword">in</span> array <span class="keyword">if</span> <span class="keyword">not</span> x &amp; <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> left + right</span><br></pre></td></tr></table></figure></li></ul><h5 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h5><p>可扩展解法，希望解决同一类的问题，而不仅是奇数和偶数的排序，可能是将数组分为负数和非负数，大于某数和小于等于某数。</p><ul><li>python解法</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reOrderArray</span><span class="params">(self, array)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> array <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> len(array) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> array</span><br><span class="line">    left = [x <span class="keyword">for</span> x <span class="keyword">in</span> array <span class="keyword">if</span> x &amp; <span class="number">1</span>]</span><br><span class="line">    right = [x <span class="keyword">for</span> x <span class="keyword">in</span> array <span class="keyword">if</span> <span class="keyword">not</span> x &amp; <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> left + right</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Reorder</span><span class="params">(self, pData, length, func)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> length == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    pBegin = <span class="number">0</span></span><br><span class="line">    pEnd = length - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> pBegin &lt; pEnd:</span><br><span class="line">        <span class="keyword">while</span> pBegin &lt; pEnd <span class="keyword">and</span> <span class="keyword">not</span> func(pData[pBegin]):</span><br><span class="line">            pBegin += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> pBegin &lt; pEnd <span class="keyword">and</span> func(pData[pEnd]):</span><br><span class="line">            pEnd -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> pBegin &lt; pEnd:</span><br><span class="line">            pData[pBegin], pData[pEnd] = pData[pEnd], pData[pBegin]</span><br><span class="line">    <span class="keyword">return</span> pData</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isEven</span><span class="params">(self, n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">not</span> n &amp; <span class="number">0x1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isNegtive</span><span class="params">(self, n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> n &gt;= <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ReorderOddEven</span><span class="params">(self, pData)</span>:</span></span><br><span class="line">    length = len(pData)</span><br><span class="line">    <span class="keyword">return</span> self.Reorder(pData, length, func=self.isNegtive)</span><br></pre></td></tr></table></figure><h3 id="面试题29：数组中出现次数超过一半的数字"><a href="#面试题29：数组中出现次数超过一半的数字" class="headerlink" title="面试题29：数组中出现次数超过一半的数字"></a>面试题29：数组中出现次数超过一半的数字</h3><h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><h5 id="方法一-1"><a href="#方法一-1" class="headerlink" title="方法一"></a>方法一</h5><p>使用快排的方法，判断选中的数字是否是数组的中位数。时间复杂度为$O(n)$</p><ul><li>java解法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (array == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = array.length &gt;&gt; <span class="number">1</span>, l = <span class="number">0</span>, r = array.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> index = partition(array, l, r);</span><br><span class="line">    <span class="keyword">while</span>(index != mid)&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt; mid)&#123;</span><br><span class="line">            index = partition(array, l, index - <span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            index = partition(array, index + <span class="number">1</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> result = array[mid];</span><br><span class="line">    <span class="keyword">if</span>(!checkValid(array, result)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkValid</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(array == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(array[i] == target)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count &gt; (array.length / <span class="number">2</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = (<span class="keyword">int</span>)(Math.random()*(r-l+<span class="number">1</span>)) + l;</span><br><span class="line">    swap(array, index, r);</span><br><span class="line">    <span class="keyword">int</span> small = l - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(index = l ; index &lt; r; index++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(array[index] &lt; array[r])&#123;</span><br><span class="line">            small++;</span><br><span class="line">            <span class="keyword">if</span>(array[small] != array[index])&#123;</span><br><span class="line">                swap(array, small, index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    small++;</span><br><span class="line">    swap(array, small, r);</span><br><span class="line">    <span class="keyword">return</span> small;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = array[i];</span><br><span class="line">    array[i] = array[j];</span><br><span class="line">    array[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="方法二-1"><a href="#方法二-1" class="headerlink" title="方法二"></a>方法二</h5><p>根据数组的特点找到重复次数最大的数字。使用两个数字存储，一个存储当前数字，一个存储time，当下一个数字和之前保存的数字相同时就time++，不同时time–，当次数为0的时候保存下一个数字并把当前次数设为1。</p><ul><li>python<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(self, numbers)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> numbers <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    temp = numbers[<span class="number">0</span>]</span><br><span class="line">    time = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(numbers) - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> time == <span class="number">0</span>:</span><br><span class="line">            temp = numbers[i]</span><br><span class="line">            time = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> numbers[i] == temp:</span><br><span class="line">            time += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            time -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> self.checkValid(numbers, temp):</span><br><span class="line">        <span class="keyword">return</span> temp</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkValid</span><span class="params">(self, numbers, target)</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> numbers:</span><br><span class="line">        <span class="keyword">if</span> num == target:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> count &gt; (len(numbers) / <span class="number">2</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="面试题42：连续子数组的最大和"><a href="#面试题42：连续子数组的最大和" class="headerlink" title="面试题42：连续子数组的最大和"></a>面试题42：连续子数组的最大和</h3><h4 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h4><p>在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和。(子向量的长度至少是1)，要求时间复杂度为$O(n)$。</p><h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p>使用两个变量存储数据，第一个存储当前遍历的数组的和，当和&lt;0时抛弃前面累加的数字。第二个存储当前遍历的最大子数组的和，当和值大于之前存储的最大和时更新最大和。空间复杂度为$O(n)$。</p><ul><li>java解法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (array.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (array.length == <span class="number">1</span>) <span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> ans = array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> max = ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;array.length; i++)&#123;</span><br><span class="line">        max = Math.max(max + array[i], array[i]);</span><br><span class="line">        ans = Math.max(ans, max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="面试题45：把数组排成最小的数"><a href="#面试题45：把数组排成最小的数" class="headerlink" title="面试题45：把数组排成最小的数"></a>面试题45：把数组排成最小的数</h3><h4 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p><h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><p>将数组整型元素转换为字符串元素，采用字符串元素之间的比较规则判断，重写compare接口，将String数组排序，最后将排好序的字符串数组拼接出来。关键就是制定排序规则。</p><ul><li>先将整型数组转换成String数组，然后</li><li><p>排序规则如下：</p><ul><li>若ab &gt; ba 则 a &gt; b，</li><li>若ab &lt; ba 则 a &lt; b，</li><li>若ab = ba 则 a = b；</li></ul><p>如： “3” &lt; “31”但是 “331” &gt; “313”，所以要将二者拼接起来进行比较。</p></li><li><p>java解法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.StringBuilder;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">PrintMinNumber</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numbers.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    StringBuilder ans = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> number : numbers)&#123;</span><br><span class="line">        list.add(number);</span><br><span class="line">    &#125;</span><br><span class="line">    list.sort(<span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer num1, Integer num2)</span></span>&#123;</span><br><span class="line">            String str1 = num1 + <span class="string">""</span> + num2;</span><br><span class="line">            String str2 = num2 + <span class="string">""</span> + num1;</span><br><span class="line">            <span class="keyword">return</span> str1.compareTo(str2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : list)&#123;</span><br><span class="line">        ans.append(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="面试题49：丑数"><a href="#面试题49：丑数" class="headerlink" title="面试题49：丑数"></a>面试题49：丑数</h3><h4 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h4><p>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p><h4 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h4><p>一种传统的解法是判断所有整数是不是丑数，是则count++，不是就i++，直到count=N，这种解法时间复杂度过高，每个整数都需要计算。<br>另一种方法是使用空间换时间，创建数组保存已经找到的丑数。使用三个变量存储数组中最后一个×2后大于M的丑数，记做$M_{2}$，及×3后大于M的丑数，记做$M_{3}$，×5后大于M的丑数，记做$M_{5}$。每次生成新的丑数时更新$M_{2}$，$M_{3}$，$M_{5}$。用$T_{2}$、$T_{3}$、$T_{5}$，记录$M_{2}$，$M_{3}$，$M_{5}$的index。</p><p>这种方法使用$O(N)$的空间来换取时间，时间复杂度也为$O(N)$。</p><ul><li>java解法</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">7</span>) <span class="keyword">return</span> index;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> T2 = <span class="number">0</span>, T3 = <span class="number">0</span>, T5 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(list.size() &lt; index)&#123;</span><br><span class="line">        list.add(Math.min(list.get(T2) * <span class="number">2</span>, list.get(T3) * <span class="number">3</span>, list.get(T5) * <span class="number">5</span> ));</span><br><span class="line">        <span class="keyword">if</span> (list.get(list.size() - <span class="number">1</span>) == list.get(T2) * <span class="number">2</span>) T2++;</span><br><span class="line">        <span class="keyword">if</span> (list.get(list.size() - <span class="number">1</span>) == list.get(T3) * <span class="number">3</span>) T3++;</span><br><span class="line">        <span class="keyword">if</span> (list.get(list.size() - <span class="number">1</span>) == list.get(T5) * <span class="number">5</span>) T5++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list.get(list.size() - <span class="number">1</span>);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="面试题50：第一个只出现一次的字符"><a href="#面试题50：第一个只出现一次的字符" class="headerlink" title="面试题50：第一个只出现一次的字符"></a>面试题50：第一个只出现一次的字符</h3><h4 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h4><p>在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1。</p><h4 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h4><p>使用长度为256的HashMap来存储出现过的字符。key是char的ASCII码的值，value是出现的次数。总体的时间复杂度为$O(n)$，使用一个长度为256的HashMap辅助空间，相当于大小为1KB，空间复杂度为$O(1)$。</p><ul><li>java解法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str.length() == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span>[] list = str.toCharArray();</span><br><span class="line">    <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">255</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.length; i++)&#123;</span><br><span class="line">        map[list[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; list.length; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (map[list[j]] == <span class="number">1</span>) <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="题目变形：字符流中第一个不重复的字符"><a href="#题目变形：字符流中第一个不重复的字符" class="headerlink" title="题目变形：字符流中第一个不重复的字符"></a>题目变形：字符流中第一个不重复的字符</h3><h4 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h4><p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。<br>输出描述：<br>如果当前字符流没有存在出现一次的字符，返回#字符。</p><h4 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h4><p>字符只能一个接一个地从字符流中读出，定义数据容器保存字符在字符流中的位置。当一个字符没有出现过时，就将它在字符流中的位置保存到数据容器中，当再次从字符流中出现时，忽略这个字符，把这个字符在容器中对应的值变为负数。</p><ul><li>java解法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Insert one char from stringstream</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">255</span>];</span><br><span class="line">    <span class="keyword">public</span> index = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (map[ch] == <span class="number">0</span>)&#123;</span><br><span class="line">            map[ch] = index++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            map[ch] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//return the first appearence once char in current stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">char</span> ans = <span class="string">'#'</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (map[i] &gt; <span class="number">0</span> &amp;&amp; map[i] &lt; min)&#123;</span><br><span class="line">                min = map[i];</span><br><span class="line">                ans = (<span class="keyword">char</span>)i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="面试题51：数组中的逆序对"><a href="#面试题51：数组中的逆序对" class="headerlink" title="面试题51：数组中的逆序对"></a>面试题51：数组中的逆序对</h3><h4 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h4><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007<br>输入描述：<br>题目保证输入的数组中没有的相同的数字<br>数据范围：<br>    对于%50的数据,size&lt;=10^4<br>    对于%75的数据,size&lt;=10^5<br>    对于%100的数据,size&lt;=2*10^5</p><h4 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h4><p>使用分而治之的方法，先把数组分为两部分，统计出数组内部的逆序对数目，再统计出两个相邻子数组之间的逆序对数目。实际就是归并排序的思想。将时间复杂度降低为$O(nlogn)$。</p>]]></content>
      
      <categories>
          
          <category> Offer Problems </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> java </tag>
            
            <tag> 剑指offer </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode3</title>
      <link href="/2018/05/23/leetCode/leetcode3/"/>
      <url>/2018/05/23/leetCode/leetcode3/</url>
      <content type="html"><![CDATA[<h1 id="33-Search-in-Rotated-Sorted-Array"><a href="#33-Search-in-Rotated-Sorted-Array" class="headerlink" title="33. Search in Rotated Sorted Array"></a>33. Search in Rotated Sorted Array</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p><p>(i.e., <code>[0,1,2,4,5,6,7]</code> might become <code>[4,5,6,7,0,1,2]</code>).</p><p>You are given a target value to search. If found in the array return its index, otherwise return <code>-1</code>.</p><p>You may assume no duplicate exists in the array.</p><p>Your algorithm’s runtime complexity must be in the order of <em>O</em>(log <em>n</em>).</p><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><ol><li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums = [4,5,6,7,0,1,2], target = 0</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure></li><li></li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums = [4,5,6,7,0,1,2], target = 3</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>这里使用二分法查找最小的数，然后再将数组分为两部分，这两部分都是顺序排列的，再使用二分法查找目标数是否在该数组中。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span> || (nums.length == <span class="number">1</span> &amp;&amp; nums[<span class="number">0</span>] != target)) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span> &amp;&amp; nums[<span class="number">0</span>] == target) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[right])</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = mid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (target &lt; nums[left] || target &gt; nums[left-<span class="number">1</span>]) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (target &gt;= nums[<span class="number">0</span>] &amp;&amp; target &lt;= nums[left-<span class="number">1</span>])</span><br><span class="line">                ans = searchIndex(nums, target, <span class="number">0</span>, left-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (target &gt;= nums[left] &amp;&amp; target &lt;= nums[nums.length -<span class="number">1</span>])</span><br><span class="line">                ans = searchIndex(nums, target, left, nums.length -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(target &lt; nums[<span class="number">0</span>] || target &gt; nums[nums.length -<span class="number">1</span>]) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            ans = searchIndex(nums, target, <span class="number">0</span>, nums.length -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">searchIndex</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == nums[left]) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">if</span> (target == nums[right]) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) right = mid-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode2</title>
      <link href="/2018/05/22/leetCode/leetcode2/"/>
      <url>/2018/05/22/leetCode/leetcode2/</url>
      <content type="html"><![CDATA[<h1 id="19-Remove-Nth-Node-From-End-of-List"><a href="#19-Remove-Nth-Node-From-End-of-List" class="headerlink" title="19. Remove Nth Node From End of List"></a>19. Remove Nth Node From End of List</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a linked list, remove the <em>n</em>-th node from the end of list and return its head. </p><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.</span><br><span class="line"></span><br><span class="line">After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><p>Given <em>n</em> will always be valid.</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>这里需要查找链表的最后第n个节点，并将其删除。主要思想是利用两个指针，第一个指针先走n步，第二个指针再开始走，当第一个指针移动到链表末端时，第二个指针正好指向需要移除的节点。</p><p>注意：</p><ul><li>在头部添加一个节点，防止边界溢出。</li><li>在第一个指针移动到尾部时，第二个指针需要指向移除节点的前一个节点。</li><li>找到该节点后，将待移除节点的后一节点连接到该节点就相当于完成了节点的移除</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode deleteNode = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        deleteNode.next = head;</span><br><span class="line">        ListNode first = deleteNode;</span><br><span class="line">        ListNode second = deleteNode;</span><br><span class="line">        <span class="keyword">int</span> time = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (first.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            first = first.next;</span><br><span class="line">            time++;</span><br><span class="line">            <span class="keyword">if</span>(time &gt; n)&#123;</span><br><span class="line">                second = second.next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        second.next = second.next.next;</span><br><span class="line">        <span class="keyword">return</span> deleteNode.next;          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此算法的时间复杂度为$O(n)$，其中$n$为链表的长度。</p><h1 id="20-Valid-Parentheses"><a href="#20-Valid-Parentheses" class="headerlink" title="20. Valid Parentheses"></a>20. Valid Parentheses</h1><h2 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h2><p>Given a string containing just the characters <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;{&#39;</code>, <code>&#39;}&#39;</code>, <code>&#39;[&#39;</code> and <code>&#39;]&#39;</code>, determine if the input string is valid.</p><p>An input string is valid if:</p><ol><li>Open brackets must be closed by the same type of brackets.</li><li>Open brackets must be closed in the correct order.</li></ol><p>Note that an empty string is also considered valid.</p><h2 id="Examp"><a href="#Examp" class="headerlink" title="Examp"></a>Examp</h2><ol><li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;()&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></li><li></li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;()[]&#123;&#125;&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><ol start="3"><li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;(]&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></li><li></li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;([)]&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><ol start="5"><li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;&#123;[]&#125;&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h2></li></ol><p>这一题可以运用到栈的知识，关于栈的应用中的递归嵌套。遇到左括号就入栈，遇到又括号就出栈。这样算法在最坏情况下的时间复杂度为$O(n)$，其中n为输入字符串的长度。这里使用一个StringBuilder来替代栈结构。采用栈Stack来进行相同的操作时，StringBuilder的处理时间会更短。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.equals(<span class="string">""</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span> &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;n; i++)&#123;</span><br><span class="line">        <span class="keyword">char</span> nowChar = s.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (nowChar == <span class="string">'('</span> || nowChar == <span class="string">'['</span> || nowChar == <span class="string">'&#123;'</span>)&#123;</span><br><span class="line">            stringBuilder.append(s.charAt(i));</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nowChar == <span class="string">')'</span> || nowChar == <span class="string">']'</span> || nowChar == <span class="string">'&#125;'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">int</span> m = nowChar - stringBuilder.charAt(stringBuilder.length() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (m &lt; <span class="number">3</span> &amp;&amp; m &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                stringBuilder.deleteCharAt(stringBuilder.length() - <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stringBuilder.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="21-Merge-Two-Sorted-Lists"><a href="#21-Merge-Two-Sorted-Lists" class="headerlink" title="21. Merge Two Sorted Lists"></a>21. Merge Two Sorted Lists</h1><h2 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h2><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. </p><h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure><h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h2><p>按照常规解法，l1和l2逐次向下比较即可，时间复杂度为$O(n1+n2)$n1是l1的长度，n2是l2的长度。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        ListNode ans = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode ansCopy = ans;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span> || l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (l1 != <span class="keyword">null</span>  &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (l1.val &lt; l2.val)&#123;</span><br><span class="line">                    temp = l1.val;</span><br><span class="line">                    l1 = l1.next;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    temp = l2.val;</span><br><span class="line">                    l2 = l2.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">                temp = l1.val;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (l1 == <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">                temp = l2.val;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            ansCopy.next = <span class="keyword">new</span> ListNode(temp);</span><br><span class="line">            ansCopy = ansCopy.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="22-Generate-Parentheses"><a href="#22-Generate-Parentheses" class="headerlink" title="22. Generate Parentheses"></a>22. Generate Parentheses</h1><h2 id="Description-3"><a href="#Description-3" class="headerlink" title="Description"></a>Description</h2><p>Given <em>n</em> pairs of parentheses, write a function to generate all combinations of well-formed parentheses. </p><h2 id="Example-2"><a href="#Example-2" class="headerlink" title="Example"></a>Example</h2><p> given <em>n</em> = 3, a solution set is: </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &quot;((()))&quot;,</span><br><span class="line">  &quot;(()())&quot;,</span><br><span class="line">  &quot;(())()&quot;,</span><br><span class="line">  &quot;()(())&quot;,</span><br><span class="line">  &quot;()()()&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h2><p>采用递归的方法求解。每次递归，输出字符串增加一个括号，使用一个字符数组记录输出字符串。将”(“剩余的数量记为<code>left</code>，“)”剩余的数量记为<code>right</code>。当<code>left &gt; 0</code>时，递归调用函数，并将<code>left - 1</code>，输出字符数组对应位置存储“(”。右括号同理，不过右括号的剩余数量始终是大于左括号数目的，满足这个条件可以执行右括号的递归。最终字符数组存储完成后将结果添加到返回值中。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] array = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">2</span> * n];</span><br><span class="line">        helper(array, <span class="number">0</span>, n, n, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">char</span>[] array, <span class="keyword">int</span> index, <span class="keyword">int</span> left, <span class="keyword">int</span> right, List&lt;String&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == array.length) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> String(array));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            array[index] = <span class="string">'('</span>;</span><br><span class="line">            helper(array, index + <span class="number">1</span>, left - <span class="number">1</span>, right, res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right &gt; left) &#123;</span><br><span class="line">            array[index] = <span class="string">')'</span>;</span><br><span class="line">            helper(array, index + <span class="number">1</span>, left, right - <span class="number">1</span>, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="26-Remove-Duplicates-from-Sorted-Array"><a href="#26-Remove-Duplicates-from-Sorted-Array" class="headerlink" title="26. Remove Duplicates from Sorted Array"></a>26. Remove Duplicates from Sorted Array</h1><h2 id="Description-4"><a href="#Description-4" class="headerlink" title="Description"></a>Description</h2><p>Given a sorted array <em>nums</em>, remove the duplicates <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener"><strong>in-place</strong></a> such that each element appear only <em>once</em> and return the new length.</p><p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array in-place</strong> with O(1) extra memory.</p><h2 id="Example-3"><a href="#Example-3" class="headerlink" title="Example"></a>Example</h2><ol><li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given nums = [1,1,2],</span><br><span class="line"></span><br><span class="line">Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.</span><br><span class="line"></span><br><span class="line">It doesn&apos;t matter what you leave beyond the returned length.</span><br></pre></td></tr></table></figure></li><li></li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given nums = [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line"></span><br><span class="line">Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.</span><br><span class="line"></span><br><span class="line">It doesn&apos;t matter what values are set beyond the returned length.</span><br></pre></td></tr></table></figure><h2 id="Clarification"><a href="#Clarification" class="headerlink" title="Clarification"></a>Clarification</h2><p>Confused why the returned value is an integer but your answer is an array?</p><p>Note that the input array is passed in by <strong>reference</strong>, which means modification to the input array will be known to the caller as well.</p><p>Internally you can think of this:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// nums is passed in by reference. (i.e., without making a copy)</span></span><br><span class="line"><span class="keyword">int</span> len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line"><span class="comment">// any modification to nums in your function would be known by the caller.</span></span><br><span class="line"><span class="comment">// using the length returned by your function, it prints the first len elements.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h2><p>这题除了需要找到不重复的数组的长度之外，还需要更新数组，将刚找到的不相同的数置于<code>nums[ans - 1]</code>的位置。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> preNum = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; preNum) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                nums[ans - <span class="number">1</span>] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            preNum = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="28-Implement-strStr"><a href="#28-Implement-strStr" class="headerlink" title="28.  Implement strStr()"></a>28.  Implement strStr()</h1><h2 id="Description-5"><a href="#Description-5" class="headerlink" title="Description"></a>Description</h2><p>Implement <a href="http://www.cplusplus.com/reference/cstring/strstr/" target="_blank" rel="noopener">strStr()</a>.</p><p>Return the index of the first occurrence of needle in haystack, or <strong>-1</strong> if needle is not part of haystack.</p><h2 id="Example-4"><a href="#Example-4" class="headerlink" title="Example"></a>Example</h2><ol><li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: haystack = &quot;hello&quot;, needle = &quot;ll&quot;</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></li><li></li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure><h2 id="Clarification-1"><a href="#Clarification-1" class="headerlink" title="Clarification"></a>Clarification</h2><p>What should we return when <code>needle</code> is an empty string? This is a great question to ask during an interview.</p><p>For the purpose of this problem, we will return 0 when <code>needle</code> is an empty string. This is consistent to C’s <a href="http://www.cplusplus.com/reference/cstring/strstr/" target="_blank" rel="noopener">strstr()</a> and Java’s <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String" target="_blank" rel="noopener">indexOf()</a>).</p><h2 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h2><p>本题首先用到一个技巧，先判断第二个字符串是否包含于第一个字符串，缩减判断时间。其次使用滑动窗，首尾节点的长度为第二个字符串的长度，沿着第一个字符串滑动，判断当前子字符串是否和第二个字符串相等。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (needle.isEmpty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!haystack.contains(needle)) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>, r = needle.length()-<span class="number">1</span>; l &lt; haystack.length(); l++, r++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (haystack.substring(l, r+<span class="number">1</span>).equals(needle)) <span class="keyword">return</span> l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="29-Divide-Two-Integers"><a href="#29-Divide-Two-Integers" class="headerlink" title="29. Divide Two Integers"></a>29. Divide Two Integers</h1><h2 id="Description-6"><a href="#Description-6" class="headerlink" title="Description"></a>Description</h2><p>Given two integers <code>dividend</code> and <code>divisor</code>, divide two integers without using multiplication, division and mod operator.</p><p>Return the quotient after dividing <code>dividend</code> by <code>divisor</code>.</p><p>The integer division should truncate toward zero.</p><h2 id="Example-5"><a href="#Example-5" class="headerlink" title="Example"></a>Example</h2><ol><li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: dividend = 10, divisor = 3</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure></li><li></li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: dividend = 7, divisor = -3</span><br><span class="line">Output: -2</span><br></pre></td></tr></table></figure><h2 id="Clarification-2"><a href="#Clarification-2" class="headerlink" title="Clarification"></a>Clarification</h2><ul><li>Both dividend and divisor will be 32-bit signed integers.</li><li>The divisor will never be 0.</li><li>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: $[−2^{31},  2^{31} − 1]$. For the purpose of this problem, assume that your function returns 231 − 1 when the division result overflows.</li></ul><h2 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h2><p>此题困难之处在于需要提前对出书和被除数做出判断，如果其超出了整型数据的最大或最小值，则需要首先根据其符号返回整型的最大值或最小值。</p><p>具体步骤：</p><ul><li>获取最终结果的符号</li><li>将除数和被除数转换为长整型计算。</li><li>分别判断被除数为0和除数为1的情况下的返回值。</li><li>递归实现其他正常情况下的结果。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (divisor == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> symbol = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> ((dividend &gt; <span class="number">0</span> &amp;&amp; divisor &lt; <span class="number">0</span>) || (dividend &lt; <span class="number">0</span> &amp;&amp; divisor &gt; <span class="number">0</span>)) symbol = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> ldivident =  Math.abs((<span class="keyword">long</span>)dividend);</span><br><span class="line">        <span class="keyword">long</span> ldivisor = Math.abs((<span class="keyword">long</span>)divisor);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ldivident == <span class="number">0</span> || ldivident &lt; ldivisor) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ldivisor == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (dividend == Integer.MIN_VALUE || dividend == Integer.MAX_VALUE)&#123;</span><br><span class="line">                <span class="keyword">if</span> (symbol == -<span class="number">1</span>) <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> (<span class="keyword">int</span>)(symbol * ldivisor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> lans = computeRes(ldivident, ldivisor);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(lans * symbol);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">computeRes</span><span class="params">(<span class="keyword">long</span> ldividend, <span class="keyword">long</span> ldivisor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ldividend - ldivisor &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> sum = ldivisor;</span><br><span class="line">        <span class="keyword">long</span> temp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (sum + sum &lt;= ldividend)&#123;</span><br><span class="line">            sum += sum;</span><br><span class="line">            temp += temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp + computeRes(ldividend-sum, ldivisor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 1</title>
      <link href="/2018/05/16/leetCode/leetcode1/"/>
      <url>/2018/05/16/leetCode/leetcode1/</url>
      <content type="html"><![CDATA[<h1 id="2-Add-Two-Numbers"><a href="#2-Add-Two-Numbers" class="headerlink" title="2.Add Two Numbers"></a>2.Add Two Numbers</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong> and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p><p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">Output: 7 -&gt; 0 -&gt; 8</span><br><span class="line">Explanation: 342 + 465 = 807.</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>主要需要注意的地方：</p><ul><li>使用temp节点进行节点的后移，返回的l3其实是temp的前一个节点</li><li>在创建新节点时直接将carray的值赋给新节点</li><li>当进行到最后一位时不再创建新节点</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;              </span><br><span class="line">        ListNode l3 = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode temp = l3;</span><br><span class="line">        <span class="keyword">int</span> carray = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((l1 != <span class="keyword">null</span>) || (l2 != <span class="keyword">null</span>))&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">                temp.val += l1.val;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">                temp.val += l2.val;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            carray = temp.val / <span class="number">10</span>;</span><br><span class="line">            temp.val = temp.val % <span class="number">10</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(carray &gt;<span class="number">0</span>)&#123;</span><br><span class="line">                temp.next = <span class="keyword">new</span> ListNode(carray);</span><br><span class="line">                temp = temp.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>((l1 != <span class="keyword">null</span>) || (l2 != <span class="keyword">null</span>))&#123;</span><br><span class="line">                temp.next = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">                temp = temp.next;</span><br><span class="line">            &#125;                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l3;          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h2><p>调试时需要注意，该函数返回的值实际上相当于l3头节点，在主函数中的操作为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ListNode l1 = <span class="keyword">new</span> ListNode(<span class="number">5</span>);</span><br><span class="line">        l1.next = <span class="keyword">new</span> ListNode(<span class="number">7</span>);</span><br><span class="line">        l1.next.next = <span class="keyword">new</span> ListNode(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        ListNode l2 = <span class="keyword">new</span> ListNode(<span class="number">8</span>);</span><br><span class="line">        l2.next = <span class="keyword">new</span> ListNode(<span class="number">7</span>);</span><br><span class="line">        l2.next.next = <span class="keyword">new</span> ListNode(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        ListNode l3 = addTwoNumbers(l1, l2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="3-Longest-Substring-Without-Repeating-Characters"><a href="#3-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="3.Longest Substring Without Repeating Characters"></a>3.Longest Substring Without Repeating Characters</h1><h2 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h2><p>Given a string, find the length of the longest substring without repeating characters.</p><h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><ul><li>Given “<code>abcabcbb</code>“, the answer is “<code>abc</code>“, which the length is 3.</li><li>Given “<code>bbbbb</code>“, the answer is “<code>b</code>“, with the length of 1.</li><li>Given “<code>pwwkew</code>“, the answer is “<code>wke</code>“, with the length of 3. Note that the answer must be a substring, “<code>pwke</code>“ is a subsequence and not a substring.</li></ul><h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h2><p>要点：采用滑动窗来寻找窗中的相同字符。滑动窗通常用于解决字符串问题，主要是一个$[i, j)$的区间，j向右滑动，找到重复的元素时，更新i值。将i的值变为重复元素的后一位，缩小区间。区间的长度就是不重复最大子序列的长度，为$j-i+1$。<br>注意：</p><ul><li>使用HashMap存储字符及索引</li><li>遇到重复元素时，可能碰到重复元素索引值+1比原来的i值小的情况，此时不更新i</li><li>子序列的长度取最大的那个值<br>算法的时间复杂度为$O(n)$。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; charMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> subLenth = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; n &amp;&amp; j &lt; n)&#123;</span><br><span class="line">            <span class="keyword">if</span> (charMap.containsKey(s.charAt(j)))&#123;</span><br><span class="line">                i = Math.max(charMap.get(s.charAt(j)) + <span class="number">1</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">            charMap.put(s.charAt(j), j);</span><br><span class="line">            subLenth = Math.max(j-i+<span class="number">1</span>, subLenth);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> subLenth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-Longest-Palindromic-Substring"><a href="#5-Longest-Palindromic-Substring" class="headerlink" title="5.Longest Palindromic Substring"></a>5.Longest Palindromic Substring</h1><h2 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h2><p>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.</p><h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h2><ol><li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;babad&quot;</span><br><span class="line">Output: &quot;bab&quot;</span><br><span class="line">Note: &quot;aba&quot; is also a valid answer.</span><br></pre></td></tr></table></figure></li><li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;cbbd&quot;</span><br><span class="line">Output: &quot;bb&quot;</span><br></pre></td></tr></table></figure></li></ol><h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h2><ol><li><p>Manacher算法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    StringBuilder extS = <span class="keyword">new</span> StringBuilder(<span class="string">"*#"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">        extS.append(s.charAt(i)).append(<span class="string">"#"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = extS.length();</span><br><span class="line">    <span class="keyword">int</span> [] rs = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">    <span class="keyword">int</span> maxEdge = <span class="number">0</span>, center = <span class="number">0</span>, start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j= <span class="number">1</span>; j &lt; m; j++)&#123;</span><br><span class="line">        rs[j] = (maxEdge &gt; j ? Math.min(rs[<span class="number">2</span> * center - j], maxEdge - j) : <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(extS.charAt(j + rs[j]) == extS.charAt(j - rs[j]))&#123;</span><br><span class="line">            rs[j]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (j+rs[j] &gt; maxEdge)&#123;</span><br><span class="line">            center = j;</span><br><span class="line">            maxEdge = j + rs[j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rs[j] - <span class="number">1</span> &gt; end)&#123;</span><br><span class="line">            start = (j - rs[j]) / <span class="number">2</span>;</span><br><span class="line">            end = rs[j] - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substring(start, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>动态规划<br>动态规划解法较为经典，采用一个转移矩阵<code>p[i][j]</code>来存储<code>s[i]</code> ~<code>s[j]</code>的子字符串是否为回形字符串。当<code>s[i]</code> ~<code>s[j]</code>为回形字符串时，其判断依据为：</p></li></ol><ul><li><code>s[i]</code>必然等于<code>s[j]</code></li><li><p><code>s[i]</code> ~<code>s[j]</code>的上一组<code>s[i+1]</code> ~<code>s[j-1]</code>仍然是回形字符串。或者是碰到“bb”这种情况或“bab”，此时的j - i &lt; 3。<br>采用动态规划仍然会有$O(n^{2})$的时间复杂度。</p></li><li><p>算法从后向前遍历，防止在边界条件时，<code>s[i+1]</code> ~<code>s[j-1]</code>溢出。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    String ans = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> [][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n-<span class="number">1</span>; i &gt;= <span class="number">0</span> ; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == s.charAt(j) &amp;&amp; (j - i &lt; <span class="number">3</span> || dp[i + <span class="number">1</span>][j - <span class="number">1</span>]))&#123;</span><br><span class="line">                dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (dp[i][j] &amp;&amp; (ans == <span class="keyword">null</span> || j - i + <span class="number">1</span> &gt; ans.length()))&#123;</span><br><span class="line">                ans = s.substring(i, j+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br></pre></td></tr></table></figure><h1 id="6-ZigZag-Conversion"><a href="#6-ZigZag-Conversion" class="headerlink" title="6. ZigZag Conversion"></a>6. ZigZag Conversion</h1><h2 id="Description-3"><a href="#Description-3" class="headerlink" title="Description"></a>Description</h2><p>The string<code>&quot;PAYPALISHIRING&quot;</code>is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">P   A   H   N</span><br><span class="line">A P L S I I G</span><br><span class="line">Y   I   R</span><br></pre></td></tr></table></figure></p><p>And then read line by line:<code>&quot;PAHNAPLSIIGYIR&quot;</code></p><p>Write the code that will take a string and make this conversion given a number of rows:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string convert(string s, int numRows);</span><br></pre></td></tr></table></figure></p><h2 id="Example-2"><a href="#Example-2" class="headerlink" title="Example:"></a>Example:</h2><ol><li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;PAYPALISHIRING&quot;, numRows = 3</span><br><span class="line">Output: &quot;PAHNAPLSIIGYIR&quot;</span><br></pre></td></tr></table></figure></li></ol><p>2.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;PAYPALISHIRING&quot;, numRows = 4</span><br><span class="line">Output: &quot;PINALSIGYAHRPI&quot;</span><br><span class="line">Explanation:</span><br><span class="line"></span><br><span class="line">P     I    N</span><br><span class="line">A   L S  I G</span><br><span class="line">Y A   H R</span><br><span class="line">P     I</span><br></pre></td></tr></table></figure></p><h2 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h2><ol><li><p>较为复杂的解法，首先需要将原字符串补全为可以被周期整除的字符串，并在后面补上<code>&#39;*&#39;</code>。然后可以观察到一个周期内访问字符串的顺序，根据这个顺序可以发现除了头部和尾部的字符，其他地方的字符在一个周期内是关于底部字符对称访问的。这里为了省去边界判断，直接在底部字符和周期尾部字符处插入<code>&#39;*&#39;</code>，使得在一个周期内字符的访问都是一个是周期头部，一个是周期末尾字符。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(String s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numRows == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    StringBuffer ans = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    StringBuffer strBuff = <span class="keyword">new</span> StringBuffer(s);</span><br><span class="line">    StringBuffer strBuff2 = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">int</span> n = s.length(), oneSize = numRows * <span class="number">2</span> - <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> m = n / oneSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n % oneSize &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oneSize - n % oneSize; i++) &#123;</span><br><span class="line">            strBuff.append(<span class="string">"*"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        m++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        strBuff2.append(strBuff.substring(i*oneSize, numRows + i * oneSize))</span><br><span class="line">                .append(<span class="string">"*"</span>)</span><br><span class="line">                .append(strBuff.substring(numRows + i * oneSize, oneSize + i * oneSize))</span><br><span class="line">                .append(<span class="string">"*"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numRows; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (strBuff2.charAt(i + j * (oneSize + <span class="number">2</span>)) != <span class="string">'*'</span>)&#123;</span><br><span class="line">                ans.append(strBuff2.charAt(i + j * (oneSize + <span class="number">2</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (strBuff2.charAt(oneSize - i + <span class="number">1</span> + j * (oneSize + <span class="number">2</span>)) != <span class="string">'*'</span>)&#123;</span><br><span class="line">                ans.append(strBuff2.charAt(oneSize - i + <span class="number">1</span> + j * (oneSize + <span class="number">2</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li>分好周期后分情况讨论。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(String s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numRows == <span class="number">0</span> || s == <span class="keyword">null</span> || s == <span class="string">""</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">if</span>(numRows == <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">2</span> * numRows - <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numRows; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; s.length(); j += size) &#123;</span><br><span class="line">            sb.append(s.charAt(j));</span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">0</span> &amp;&amp; i != numRows - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = j+ size - i * <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(temp &lt; s.length()) &#123;</span><br><span class="line">                    sb.append(s.charAt(temp));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="12-Integer-to-Roman"><a href="#12-Integer-to-Roman" class="headerlink" title="12. Integer to Roman"></a>12. Integer to Roman</h1><h2 id="Description-4"><a href="#Description-4" class="headerlink" title="Description"></a>Description</h2><p>Roman numerals are represented by seven different symbols: <code>I</code>, <code>V</code>, <code>X</code>, <code>L</code>, <code>C</code>, <code>D</code> and <code>M</code>. </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Symbol       Value</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure><p>For example, two is written as <code>II</code> in Roman numeral, just two one’s added together. Twelve is written as, <code>XII</code>, which is simply <code>X</code> + <code>II</code>. The number twenty seven is written as <code>XXVII</code>, which is <code>XX</code> + <code>V</code> + <code>II</code>. </p><p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not <code>IIII</code>. Instead, the number four is written as <code>IV</code>. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as <code>IX</code>. There are six instances where subtraction is used: </p><ul><li><code>I</code> can be placed before <code>V</code> (5) and <code>X</code> (10) to make 4 and 9. </li><li><code>X</code> can be placed before <code>L</code> (50) and <code>C</code> (100) to make 40 and 90. </li><li><code>C</code> can be placed before <code>D</code> (500) and <code>M</code> (1000) to make 400 and 900.</li></ul><p>Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999. </p><h2 id="Example-3"><a href="#Example-3" class="headerlink" title="Example"></a>Example</h2><ol><li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: &quot;III&quot;</span><br></pre></td></tr></table></figure></li><li></li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 4</span><br><span class="line">Output: &quot;IV&quot;</span><br></pre></td></tr></table></figure><ol><li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 9</span><br><span class="line">Output: &quot;IX&quot;</span><br></pre></td></tr></table></figure></li><li></li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 58</span><br><span class="line">Output: &quot;LVIII&quot;</span><br><span class="line">Explanation: C = 100, L = 50, XXX = 30 and III = 3.</span><br></pre></td></tr></table></figure><ol><li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1994</span><br><span class="line">Output: &quot;MCMXCIV&quot;</span><br><span class="line">Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.</span><br></pre></td></tr></table></figure></li></ol><h2 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static String intToRoman(int num)&#123;</span><br><span class="line">    String M[] = &#123;&quot;&quot;, &quot;M&quot;, &quot;MM&quot;, &quot;MMM&quot;&#125;;</span><br><span class="line">    String C[] = &#123;&quot;&quot;, &quot;C&quot;, &quot;CC&quot;, &quot;CCC&quot;, &quot;CD&quot;, &quot;D&quot;, &quot;DC&quot;, &quot;DCC&quot;, &quot;DCCC&quot;, &quot;CM&quot;&#125;;</span><br><span class="line">    String X[] = &#123;&quot;&quot;, &quot;X&quot;, &quot;XX&quot;, &quot;XXX&quot;, &quot;XL&quot;, &quot;L&quot;, &quot;LX&quot;, &quot;LXX&quot;, &quot;LXXX&quot;, &quot;XC&quot;&#125;;</span><br><span class="line">    String I[] = &#123;&quot;&quot;, &quot;I&quot;, &quot;II&quot;, &quot;III&quot;, &quot;IV&quot;, &quot;V&quot;, &quot;VI&quot;, &quot;VII&quot;, &quot;VIII&quot;, &quot;IX&quot;&#125;;</span><br><span class="line">    return M[num/1000] + C[(num%1000)/100] + X[(num%100)/10] + I[num%10];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="13-Roman-to-Integer"><a href="#13-Roman-to-Integer" class="headerlink" title="13. Roman to Integer"></a>13. Roman to Integer</h1><h2 id="Description-5"><a href="#Description-5" class="headerlink" title="Description"></a>Description</h2><p>Roman numerals are represented by seven different symbols: <code>I</code>, <code>V</code>, <code>X</code>, <code>L</code>, <code>C</code>, <code>D</code> and <code>M</code>. </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Symbol       Value</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure><p>For example, two is written as <code>II</code> in Roman numeral, just two one’s added together. Twelve is written as, <code>XII</code>, which is simply <code>X</code> + <code>II</code>. The number twenty seven is written as <code>XXVII</code>, which is <code>XX</code> + <code>V</code> + <code>II</code>. </p><p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not <code>IIII</code>. Instead, the number four is written as <code>IV</code>. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as <code>IX</code>. There are six instances where subtraction is used: </p><ul><li><code>I</code> can be placed before <code>V</code> (5) and <code>X</code> (10) to make 4 and 9. </li><li><code>X</code> can be placed before <code>L</code> (50) and <code>C</code> (100) to make 40 and 90. </li><li><code>C</code> can be placed before <code>D</code> (500) and <code>M</code> (1000) to make 400 and 900.</li></ul><p>Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. </p><h2 id="Example-4"><a href="#Example-4" class="headerlink" title="Example"></a>Example</h2><ol><li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;III&quot;</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure></li><li></li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;IV&quot;</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><ol start="3"><li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;IX&quot;</span><br><span class="line">Output: 9</span><br></pre></td></tr></table></figure></li><li></li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;LVIII&quot;</span><br><span class="line">Output: 58</span><br><span class="line">Explanation: C = 100, L = 50, XXX = 30 and III = 3.</span><br></pre></td></tr></table></figure><ol start="5"><li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;MCMXCIV&quot;</span><br><span class="line">Output: 1994</span><br><span class="line">Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.</span><br></pre></td></tr></table></figure></li></ol><h2 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h2><p>将罗马数字转换为整形数字，具体思路为：动态规划</p><ul><li>将每一个字母对应为整型数字</li><li>动态规划，从后向前判断当前数字和其后面的数字的大小</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = charToInt(s.charAt(s.length()-<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">int</span> ans = temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.length()-<span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (charToInt(s.charAt(i)) &lt; temp)&#123;</span><br><span class="line">                ans = ans - charToInt(s.charAt(i));</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                ans += charToInt(s.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">            temp = charToInt(s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">charToInt</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span> (c)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'I'</span>:</span><br><span class="line">                num = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'V'</span>:</span><br><span class="line">                num = <span class="number">5</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'X'</span>:</span><br><span class="line">                num = <span class="number">10</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'L'</span>:</span><br><span class="line">                num = <span class="number">50</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'C'</span>:</span><br><span class="line">                num = <span class="number">100</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'D'</span>:</span><br><span class="line">                num = <span class="number">500</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'M'</span>:</span><br><span class="line">                num = <span class="number">1000</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据结构之高级搜索树-伸展树</title>
      <link href="/2018/05/14/data_structure/%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
      <url>/2018/05/14/data_structure/%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
      <content type="html"><![CDATA[<h1 id="伸展树"><a href="#伸展树" class="headerlink" title="伸展树"></a>伸展树</h1><ul><li>局部性：刚被访问过的数据，极有可能很快再次被访问。（如BST）</li></ul><p>对此，考察列表结构。在列表中，相邻的元素通过引用确立前驱和后继关系，对任意一个元素的访问效率主要取决于它在序列中的秩。秩越小，访问效率越高，为了提高多次查找的访问效率，可以考虑将刚刚接受访问的元素移动到序列的最前端，提高访问效率。希望借助局部性对BST的访问效率做进一步的优化，参照对列表做出的技巧，将在某一段时间内经常要访问到的元素通过某种方式，尽可能的移送到更加接近树根的位置，尽可能降低他们的深度。</p><h3 id="逐层伸展"><a href="#逐层伸展" class="headerlink" title="逐层伸展"></a>逐层伸展</h3><p>节点v一旦被访问，随即将其转移至树根，具体操作方式为zig和zag，将节点v和其父亲节点p在高度上互换，多次进行旋转操作，使得节点v最终抵达树根节点。</p><p>但一层一层进行伸展，在最坏的情况下：</p><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/dataStructure/50759199.jpg" width="75%/"><br></center><p>树退化为一个列表，此时逐层伸展需要的累计时间是$\Omega(n^{2})$，因此需要改进方法。</p><h3 id="双层伸展"><a href="#双层伸展" class="headerlink" title="双层伸展"></a>双层伸展</h3><p>向上追溯两层，反复考察祖孙三代，根据相应的位置，经过两次旋转，使得v一次上升两层，成为子树根。</p><p>对于zig-zag和zag-zig而言，和逐层伸展没有区别，但在处理zig-zig和zag-zag时，颠倒上升的次序将彻底改变整体的结构。</p><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/dataStructure/97964754.jpg" width="75%/"><br></center><p>具有路径折叠效果：一旦访问最深的那个节点，对应路径的长度随即减半。相当于对坏节点有修复的作用，使得最坏的情况不至于持续发生，按照当前策略，单趟伸展操作所需要的时间不会超过$O(logn)$。</p><h3 id="伸展树接口"><a href="#伸展树接口" class="headerlink" title="伸展树接口"></a>伸展树接口</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Splay</span>:</span><span class="keyword">public</span> BST&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        BinNodePosi(T) splay(BinNodePosi(T) v);  <span class="comment">// 将v伸展至v</span></span><br><span class="line">    <span class="keyword">public</span>:                                      </span><br><span class="line">        BinNodePosi(T) &amp; search(<span class="keyword">const</span> T &amp; e);    <span class="comment">// 查找重写，查找会引起整树的结构调整</span></span><br><span class="line">        BinNodePosi(T) insert(<span class="keyword">const</span> T &amp; e);      <span class="comment">// 插入重写</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> T &amp; e)</span></span>;                <span class="comment">// 删除重写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与AVL树不同，需要重写search接口，因为在伸展树中，它会导致树中节点之间拓扑关系的变化。splay是保护类型接口。</p><h4 id="伸展算法"><a href="#伸展算法" class="headerlink" title="伸展算法"></a>伸展算法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; BinNodePosi(T) Splay&lt;T&gt;::splay(BinNodePosi(T) v)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!v) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    BinNodePosi(T) p;</span><br><span class="line">    BinNodePosi(T) g;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>((p = v-&gt;parent) &amp;&amp; (g = p-&gt;parent))&#123;</span><br><span class="line">        BinNodePosi(T) gg = g-&gt;parent;  <span class="comment">// 每轮指定原节点的曾祖父为现在节点的父亲</span></span><br><span class="line">        <span class="keyword">if</span>(IsLChild(*v))&#123;</span><br><span class="line">            <span class="keyword">if</span>(isLChild(*p))&#123;</span><br><span class="line">                <span class="comment">/*  zig-zig */</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">/* zig-zag */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(isRChild(*p))&#123;</span><br><span class="line">                <span class="comment">/* zag-zag */</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">/* zag-zig */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!gg) v-&gt;parent = <span class="literal">NULL</span>;     <span class="comment">// 若无曾祖父，则现在的v为树根</span></span><br><span class="line">        <span class="keyword">else</span>&#123;                         <span class="comment">// 否则，gg此后以v为左或右孩子</span></span><br><span class="line">            g == gg-&gt;lc ? attachAsLChild(gg, v) : attachAsRChild(gg, v);</span><br><span class="line">        &#125;</span><br><span class="line">        updateHeight(g);</span><br><span class="line">        updateHeight(p);</span><br><span class="line">        updateHeight(v);</span><br><span class="line">    &#125;                 <span class="comment">// 双层伸展后，必有g==NULL，但p可能非空</span></span><br><span class="line">    <span class="keyword">if</span>(p = v-&gt;parent)&#123;<span class="comment">/* 若p是根节点，只需要单旋至多一次 */</span>&#125;</span><br><span class="line">    v-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>四种情况的分别处理：</p><ol><li>zig-zig<br>类似于3+4重构，只需考虑最后的构造而忽略过程。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(IsLChild(*v))&#123;</span><br><span class="line">    <span class="keyword">if</span>(IsLChild(*p))&#123;                 <span class="comment">// zig-zig</span></span><br><span class="line">        attachAsLChild(g, p-&gt;rc);</span><br><span class="line">        attachAsLChild(p, v-&gt;rc);</span><br><span class="line">        attachAsRChild(p, g);</span><br><span class="line">        attachAsRChild(v, p);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;                           <span class="comment">// zig-zag</span></span><br><span class="line">        attachAsRChild(p, v-&gt;lc);</span><br><span class="line">        attachAsLChild(g, v-&gt;rc);</span><br><span class="line">        attachAsRChild(v, g);</span><br><span class="line">        attachAsLChild(v, p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>zag-zag和zag-zig情况类似于上面。</p><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; BinNodePosi(T) &amp; Splay&lt;T&gt;::search(<span class="keyword">const</span> T &amp; e)&#123;   </span><br><span class="line">    <span class="comment">// 标准BST内部接口定位目标节点</span></span><br><span class="line">    BinNodePosi(T) p = searchIn(_root, e, _hot = <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 无论成功与否，最后被访问的节点都将伸展至根</span></span><br><span class="line">    _root = spaly(p ? p : _hot);</span><br><span class="line">    <span class="keyword">return</span> _root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论是成功或者失败 ，都会在树根处获得一个相等或者近似的节点，这种处理手法的原理正是为了充分利用我们此前介绍的局部性。既然在其内部需要调用splay算法调整树的拓扑结构，所以对于伸展树而言，search接口不再是一个静态的操作，这也是伸展树区别于其他同类BBST的最本质特点。</p><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>按照直观的思维，调用BST标准的插入算法，然后再按照伸展树的规则，将新节点伸展至树根的位置。这种实现方法在这里显得过于迂回曲折，因为无论如何在真正实施插入操作之前，已经调用过一次search接口，而刚刚业已重写过的search接口实际上已经集成了一个splay操作。也就是说，即便查找可能失败，根节点也必然是<code>_hot</code>节点。新的节点本来就应该作为<code>_hot</code>的左或右孩子接入树中，因此进行一下操作：</p><ul><li>调用重写后的search接口，查找失败，记录失败前最终的节点t，即<code>_hot</code></li><li>集成在search接口内部的splay操作将<code>_hot</code>推送到树根位置</li><li>将此时的树拆分为两部分，引入节点v，将t及其后代作为v的左子树，从t分离出来的右子树作为v的右子树</li></ul><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/dataStructure/22263908.jpg" width="75%/"><br></center><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>同样的，按照直观的思维，首先按照BST的标准删除算法实施删除，再按照伸展树的约定，将与之临近的节点比如_hot伸展到树根的位置，但是在此时，也依然显得有些迂回。因为 如果在删除操作之前的search操作是成功的，那么在查找之后，待删除的目标节点必然已经被推送到了树根的位置，因此可以随即就在树根的位置附近完成删除操作。具体过程为：</p><ul><li>调用重写后的search接口，定位待删除节点</li><li>查找成功，但删除节点被伸展到树根</li><li>释放树根节点</li><li>重新组合两棵子树。如在右子树中找到最小节点，也就是右子树的树根节点的直接后继，因为它虽然是右子树最下的节点，但它比左子树的节点都大。将左子树作为这个节点的左子树连接上去。</li></ul><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/dataStructure/42272731.jpg" width="75%/"><br></center><h3 id="伸展树总结"><a href="#伸展树总结" class="headerlink" title="伸展树总结"></a>伸展树总结</h3><p>优点：</p><ul><li><p>相对于AVL树，伸展树无需记录节点高度或平衡因子，编程简单易行，其分摊复杂度$O(logn)$和AVL相当。</p></li><li><p>局部性强，缓存命中率极高时$(k &lt;&lt; n &lt;&lt; m)$，效率更高。其中m为操作次数，n为数据集数量，k为访问数据的数量。此时的效率可以自适应达到$O(logk)$。</p></li></ul><p>缺点：</p><ul><li>不能杜绝单次最坏的情况，不适用于对效率敏感的场合</li><li>复杂度分析较为复杂</li></ul><h2 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h2><p>与二叉查找树类似，B树也是用来存放一组具有关键码的词条的数据结构。<br>它有两个特点：</p><ol><li>每个节点未必只有两个分叉</li><li>所有底层节点的深度都完全一致</li></ol>]]></content>
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据结构之图</title>
      <link href="/2018/04/18/data_structure/dataStructureGraph/"/>
      <url>/2018/04/18/data_structure/dataStructureGraph/</url>
      <content type="html"><![CDATA[<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h2><p>图G由两个集合V和E组成，记为$G = (V, E)$，V代表图中顶点的集合，E代表顶点之间的关系。将顶点的规模记为$n = |V|$，边集的规模记做$e = |E|$。</p><ul><li>邻接（adjacency）顶点与顶点间的关系</li><li><p>关联（incidence）顶点与边的关系</p></li><li><p>无向图（undigraph）：邻接顶点u和v的次序无关系，则（u，v）为无向边。若图中都为无向边则为无向图。</p></li><li>有向图（digraph）：邻接顶点u和v的有头有尾，且u为尾（tail），v为头（head），则（u，v）为有向边。若图中都为有向边，则为有向图。</li><li>混合图（mixed graph）：一个图中既有有向边，又有无向边。<br>无向图可以用有向图表示。</li></ul><p>路径：连续的边的端点构成的顶点序列。</p><ul><li>简单路径：路径中不含重复的顶点</li><li>简单环路：除了起点和终点，其余顶点都不相同的环路。</li><li>欧拉环路：经过所有的边一次且恰好一次的环路</li><li>哈密尔顿环路：经过每一个顶点一次且恰好一次的环路</li></ul><h2 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h2><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>使用二维数组表示顶点之间的相邻关系。设$G=(V, E)$是有n个顶点的图，顶点序号依次为0,1,···，n-1，则邻接矩阵可以表示为：<br>$arc\left [ i,j \right ]=\left{\begin{matrix} 1 &amp; \left ( v_{i},v_{j} \right ) \in E\cup \left \langle v_{i},v_{j} \right \rangle \in E\ 0 &amp; others \end{matrix}\right.$</p><h3 id="关联矩阵"><a href="#关联矩阵" class="headerlink" title="关联矩阵"></a>关联矩阵</h3><p>使用二位数字表示顶点和边的关系。设$G=(V, E)$是有n个顶点，e条边的图</p><h3 id="顶点类"><a href="#顶点类" class="headerlink" title="顶点类"></a>顶点类</h3><p>给出顶点类的一种实现方法，并未进行严格封装。其中<code>status</code>、<code>dTime</code>、<code>fTime</code>、<code>parent</code>、<code>priority</code>要进行重点分析。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;UNDISCOVERED, DISCOVERED, VISITED&#125; VStatus;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tv&gt; <span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span>&#123;</span>   <span class="comment">//顶点对象</span></span><br><span class="line">    Tv data;                            <span class="comment">//数据</span></span><br><span class="line">    <span class="keyword">int</span> inDegree, outDegree;            <span class="comment">//入度，出度</span></span><br><span class="line">    VStatus status;                     <span class="comment">//状态</span></span><br><span class="line">    <span class="keyword">int</span> dTime, fTime;                   <span class="comment">//时间标签</span></span><br><span class="line">    <span class="keyword">int</span> parent;                         <span class="comment">//遍历树中的父节点</span></span><br><span class="line">    <span class="keyword">int</span> priority;                       <span class="comment">//遍历树中的优先级</span></span><br><span class="line">    Vertex(Tv <span class="keyword">const</span> &amp; d):               <span class="comment">//构造新节点</span></span><br><span class="line">        data(d),</span><br><span class="line">        inDegree(<span class="number">0</span>),outDegree(<span class="number">0</span>),</span><br><span class="line">        ststus(UNDISCOVERED),</span><br><span class="line">        dTime(<span class="number">-1</span>), fTime(<span class="number">-1</span>),</span><br><span class="line">        parent(<span class="number">-1</span>),</span><br><span class="line">        priority(INT_MAX)&#123;&#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h4 id="顶点操作"><a href="#顶点操作" class="headerlink" title="顶点操作"></a>顶点操作</h4><p>对于任意的顶点i，枚举出其所有的邻接顶点neighbor：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nextNbr</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;             <span class="comment">//表示若已经枚举到邻居j，则转向下一个邻居。采用逆序查找的方式，时间复杂度为O(n)</span></span><br><span class="line">    <span class="keyword">while</span>((<span class="number">-1</span>&lt;j)&amp;&amp;!exists(i,--j));     <span class="comment">//短路求值，当j越界时跳出循环</span></span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">firstNbr</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;<span class="keyword">return</span> nextNbr(i, n)&#125; <span class="comment">//返回首个邻居的索引，将n假想成一个尾哨兵。</span></span><br></pre></td></tr></table></figure></p><p>如果改用邻接矩阵来查找，耗时将会降低到degree+1</p><h4 id="顶点插入"><a href="#顶点插入" class="headerlink" title="顶点插入"></a>顶点插入</h4><p>在邻接矩阵中，顶点插入对应于增加一列和一行，并且在对应的边集中增加其关联的边，在顶点集中增加该顶点。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(Tv <span class="keyword">const</span> &amp; vertex)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">        E[j].insert(<span class="literal">NULL</span>);                         <span class="comment">//为每个列向量的末尾增加一个单元</span></span><br><span class="line">    &#125;</span><br><span class="line">    n++;</span><br><span class="line">    E.insert(Vector&lt;Edge&lt;Te&gt;*&gt;(n, n, <span class="literal">NULL</span>));       <span class="comment">//边集增加边</span></span><br><span class="line">    <span class="keyword">return</span> V.insert(Vertex&lt;Tv&gt;(vertex));           <span class="comment">//顶点集增加顶点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>在每个列向量的尾部增加一个单元，初始化为NULL；</li><li>生成一个新的行向量，每个元素为一个边记录，总数为n，所有边引用都初始化为NULL。此处行向量的长度在原来的基础上增加1。</li><li>顶点集增加一个顶点元素。<br>这里未对新的边进行实质性操作。</li></ul><h4 id="顶点删除"><a href="#顶点删除" class="headerlink" title="顶点删除"></a>顶点删除</h4><p>与顶点插入类似，需要删除顶点及其关联边，并返回该顶点信息。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Tv <span class="title">remove</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;                      <span class="comment">//删除所有出边</span></span><br><span class="line">        <span class="keyword">if</span>(exists(i, j))&#123;</span><br><span class="line">            <span class="keyword">delete</span> E[i][j];</span><br><span class="line">            V[j].inDegree--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    E.remove(i);                                 <span class="comment">//删除第i行</span></span><br><span class="line">    n--;   </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;                      <span class="comment">//删除所有入边和第i列</span></span><br><span class="line">        <span class="keyword">if</span>(exists(j, i))&#123;</span><br><span class="line">            <span class="keyword">delete</span> E[j].remove(i);</span><br><span class="line">            V[j].outDegree--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Tv vBak = vertex(i);                         <span class="comment">//备份顶点信息</span></span><br><span class="line">    V.remove(i);                                 <span class="comment">//删除顶点</span></span><br><span class="line">    <span class="keyword">return</span> vBak;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="边类"><a href="#边类" class="headerlink" title="边类"></a>边类</h3><p>对于Edge类也没有进行严格封装。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;UNDTERMINED, TREE, CROSS, FORWARD, BACKWARD&#125; EStatus;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Te&gt; <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    Te data;</span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">    EStatus status;</span><br><span class="line">    Edge(Te <span class="keyword">const</span> &amp; d, <span class="keyword">int</span> w):</span><br><span class="line">        data(d),</span><br><span class="line">        weight(w),</span><br><span class="line">        status(UNDTERMINED)&#123;&#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="边操作"><a href="#边操作" class="headerlink" title="边操作"></a>边操作</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">exists</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span>&lt;=i)&amp;&amp;(i&lt;n)&amp;&amp;(<span class="number">0</span>&lt;=j)&amp;&amp;(j&lt;n)&amp;&amp;E[i][j] != <span class="literal">NULL</span>;  <span class="comment">//短路求值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Te &amp; <span class="title">edge</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> E[i][j]-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Estatus &amp; <span class="title">status</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> E[i][j]-&gt;status;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> &amp; <span class="title">weight</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> E[i][j]-&gt;weight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断边是否合法，如果合法可以将该边对应的数据取出，且该边的其他状态也可以直接返回，其时间复杂度为$O(1)$。</p><h4 id="边插入"><a href="#边插入" class="headerlink" title="边插入"></a>边插入</h4><p>使用邻接矩阵，将需要插入的边封装成一个边信息，再将地址链接到邻接矩阵对应的地方即可。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Te <span class="keyword">const</span> &amp; edge, <span class="keyword">int</span> w, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(exists(i, j)) <span class="keyword">return</span>;           <span class="comment">//忽略已有的边</span></span><br><span class="line">    E[i][j] = <span class="keyword">new</span> Edge&lt;Te&gt;(edge, w);   <span class="comment">//创建新的边并赋值给E[i][j]</span></span><br><span class="line">    e++;                               <span class="comment">//更新边数</span></span><br><span class="line">    V[i].outDegree++;                  <span class="comment">//更新关联顶点i的出度</span></span><br><span class="line">    V[j].inDegree++;                   <span class="comment">//更新关联顶点j的入度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="边删除"><a href="#边删除" class="headerlink" title="边删除"></a>边删除</h4><p>在邻接矩阵中删除一条边只需要将边插入的过程反过来。查询邻接矩阵，对应到一条边记录，删除边记录，使其查询时对应为空，返回删除边的信息。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Te <span class="title">remove</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!exists(i, j)) <span class="keyword">return</span>;           <span class="comment">//忽略不存在的边</span></span><br><span class="line">    Te eBak = edge(i, j);               <span class="comment">//备份要删除的边</span></span><br><span class="line">    <span class="keyword">delete</span> E[i][j];</span><br><span class="line">    E[i][j] = <span class="literal">NULL</span>;</span><br><span class="line">    e--;</span><br><span class="line">    V[i].outDegree--;</span><br><span class="line">    V[j].inDegree--;</span><br><span class="line">    <span class="keyword">return</span> eBak;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="GraphMatrix"><a href="#GraphMatrix" class="headerlink" title="GraphMatrix"></a>GraphMatrix</h3><p>GraphMatrix派生于Graph类。首先构造顶点集和边集，其中顶点集是顶点构成的向量；边集相当于由边向量构成的矩阵，每个边向量长度为n，因此恰好构成邻接矩阵<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tv, <span class="keyword">typename</span> Te&gt; <span class="class"><span class="keyword">class</span> <span class="title">GraphMatrix</span> :</span> <span class="keyword">public</span> Graph&lt;Tv, Te&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Vector&lt;Vertex&lt;Tv&gt;&gt; V;           <span class="comment">//顶点集</span></span><br><span class="line">        Vector&lt;Vector&lt;Edge&lt;Te&gt;*&gt;&gt; E;    <span class="comment">//边集</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        GraphMatrix()&#123;                  <span class="comment">//构造函数</span></span><br><span class="line">            n = e = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ~GraphMatrix()&#123;                 <span class="comment">//析构</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;n; k++)</span><br><span class="line">                    <span class="keyword">delete</span> E[j][k]</span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="邻接矩阵表示优缺点"><a href="#邻接矩阵表示优缺点" class="headerlink" title="邻接矩阵表示优缺点"></a>邻接矩阵表示优缺点</h4><ul><li>优点：<ul><li>直观，易于理解和实现</li><li>适用范围广泛，尤其适用于稠密图（dense graph）</li><li>判断两点之间是否存在联边只需要$O(1)$的时间</li><li>获取顶点（出/入）度数只需要$O(1)$的时间</li><li>添加或删除边后更新度数也只需$O(1)$的时间</li><li>良好的扩展性（scalability）：<ul><li>Vector良好的空间控制策略</li><li>可“透明处理”空间溢出的情况</li></ul></li></ul></li><li>缺点：<ul><li>消耗空间数与边数无关，总是会消耗$\Theta \left ( n^{2} \right )$的空间<ul><li>如平面图，其边数$e &lt;&lt; n^{2}$，此时空间利用率约为$\frac{1}{n}$ </li></ul></li></ul></li></ul><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h3><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ol><li>访问顶点s</li><li>依次访问s所有尚未访问的邻接顶点</li><li>依次访问2步骤中的顶点的尚未访问的邻接顶点</li><li>……</li><li>直达没有尚未访问的邻接顶点</li></ol><p>此算法会逐层访问顶点，灰色线条表示各邻接顶点之间可能会有的关系，但此算法会忽略这种关系。这种广度遍历是树的层次遍历的推广。</p><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/dataStructure/17577110.jpg" width="75%/"><br></center><h4 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;Typename Tv, TypenameTe&gt;</span><br><span class="line"><span class="keyword">void</span> Graph&lt;Tv, Te&gt;::BFS(<span class="keyword">int</span> v, <span class="keyword">int</span> &amp; clock)&#123;</span><br><span class="line">    Queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    status(v) = DISCPVERED;</span><br><span class="line">    Q.enqueue(v);</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> v = Q.dequeue();   <span class="comment">// 取出队首顶点v</span></span><br><span class="line">        dTime(v) = ++clock;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> u = firdtNbr(v); <span class="number">-1</span> &lt; u; u = nextNbr(v, u))&#123;  <span class="comment">// 考察v的每个邻居u</span></span><br><span class="line">            dealWithUforBFS(u, v)</span><br><span class="line">            <span class="comment">/***  视u的状态分别处理  ***/</span></span><br><span class="line">        &#125;</span><br><span class="line">        status(v) = VISITED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历的起点是某个预先指定的顶点v。每个顶点都会经历从UNDISCOVERED状态到DISCOVERED状态，最后到VISITED状态，由此构成其生命周期。每个顶点都会入队和出队一次且仅一次，因此外层while循环的时间复杂度为$O(n)$，内层for循环是对顶点邻居的扫描，时间复杂度为$O(n)$，因此总体的时间消耗为$n^{2} + e$，时间复杂度为$O(n^{2})$，但在实际操作中，内层for循环的n很小，所以总体的时间消耗接近于$n + e$。对于邻居u的处理方式为：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;Typename Tv, TypenameTe&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dealWithUforBFS</span> <span class="params">(Tv u, Tv v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (UNDISCOVERD == status(u))&#123;   <span class="comment">// 若u尚未被发现，则发现该顶点</span></span><br><span class="line">        status(u) = DISCOVERD;</span><br><span class="line">        Q.enqueue(u);</span><br><span class="line">        status(v, u) = TREE;         <span class="comment">// 引入树边</span></span><br><span class="line">        parent(u) = v;</span><br><span class="line">    &#125;<span class="keyword">else</span>                            <span class="comment">// 若u已经被发现（正在队列中）或已经访问完毕（已出队）</span></span><br><span class="line">        status(v, u) = CROSS;        <span class="comment">// 将（v,u）归类为跨边</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并不是没幅图都只包含一个联通域，在有多个连通域的时候，从任何一个起点s出发，未必能够抵达其它的连通域，要使得bfs搜索足以覆盖整幅图而不是其中一个特定的连通域，需要使用while循环对BFS进行封装。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;Typename Tv, TypenameTe&gt;</span><br><span class="line"><span class="keyword">void</span> Graph&lt;Tv, Te&gt;::bfs(<span class="keyword">int</span> s)&#123;            <span class="comment">// s为起点</span></span><br><span class="line">    reset();</span><br><span class="line">    <span class="keyword">int</span> clock = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> v = s;                             <span class="comment">// 初始化，时间占用为θ（n + e）</span></span><br><span class="line">    <span class="keyword">do</span>                                     <span class="comment">// 逐一检查所有顶点，一旦遇到尚未发现的顶点</span></span><br><span class="line">        <span class="keyword">if</span>(UNDISCOVERED == status(v))</span><br><span class="line">            BFS(v, clock);                 <span class="comment">// 从该顶点出发启动一次BFS</span></span><br><span class="line">    <span class="keyword">while</span>(s != (v = (++v % n)) );          <span class="comment">// 按照序号访问，可不漏不重</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最短路径性"><a href="#最短路径性" class="headerlink" title="最短路径性"></a>最短路径性</h4><p>在树的结构中，相对于树根节点，任何一个节点v都对应于一条唯一的通路，这条路径的长度称作顶点v的深度，于是我们可以进而对所有的顶点自上而下按照它们的深度进行等价类划分，在每一个等价类中的所有顶点，所具有的深度指标都是彼此相等的。而树的层次遍历也相当于按照这一指标非降的次序，将所有的顶点逐一枚举出来，这样一个遍历的过程也可以转换为图结构的遍历。</p><p>图与树不同之处在于，从起始顶点s出发可能有多条路径都最后通往同一个顶点而且可能出现分叉。实际上只需考察顶点之间的最短通路，并且将这两个顶点之间的距离取作这条最短通路的长度。而在起始顶点相对固定的情况下，可以将s在这个记号中省掉，直接简称之为顶点v所对应的距离。</p><h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><h4 id="过程："><a href="#过程：" class="headerlink" title="过程："></a>过程：</h4><ul><li>访问顶点s</li><li>if s的邻居尚未被访问，访问s尚未被访问的邻居，任取其一，递归执行DFS（u）</li><li>else 返回</li></ul><p>此过程等效于树的先序遍历，DFS会构造出原图的一颗支撑树。其过程为：</p><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/dataStructure/54619684.jpg" width="75%/"><br></center><p>按照图中的箭头方向，从红色到白色到黄色到蓝色，每次改变颜色都是因为处于else语句中。</p><h4 id="算法："><a href="#算法：" class="headerlink" title="算法："></a>算法：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tv, <span class="keyword">typename</span> Te&gt;</span><br><span class="line"><span class="keyword">void</span> Graph&lt;Tv, Te&gt;::DFS(<span class="keyword">int</span> v, <span class="keyword">int</span> &amp; clock)&#123;</span><br><span class="line">    dTime(v) = ++clock;</span><br><span class="line">    status(v) = DISCOVERED;                                <span class="comment">// 发现当前顶点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> u = firstNbr(v); <span class="number">-1</span> &lt; u; u = nextNbr(v, u))&#123;   <span class="comment">// 枚举v的每个邻居</span></span><br><span class="line">        <span class="comment">/*  视u的状态分别处理  */</span></span><br><span class="line">        <span class="comment">/* 与BFS不同，含有递归 */</span></span><br><span class="line">        dealwithUforDFS(v, u)</span><br><span class="line">    &#125;</span><br><span class="line">    status(v) = VISITED;</span><br><span class="line">    fTime(v) = ++clock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在内部对u进行处理时，没有使用队列的方式，而是涉及到递归调用。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tv, <span class="keyword">typename</span> Te&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dealwithUforDFS</span><span class="params">(Tv v, Tv u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(status(u))&#123;</span><br><span class="line">        <span class="keyword">case</span> UNDISCOVERED:                      <span class="comment">// u尚未被发现，支撑树可以在此基础上扩展</span></span><br><span class="line">            status(v, u) = TREE;</span><br><span class="line">            parent(u) = v;</span><br><span class="line">            DFS(u, clock);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DISCOVERED:                       <span class="comment">// u已被发现但尚未访问完毕</span></span><br><span class="line">            status(v, u) = BACKWARD;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:                               <span class="comment">// u已被访问完，视承袭关系分为前向边或跨边</span></span><br><span class="line">            status(v, u) = dTime(v) &lt; dTime(u) ? FORWARD : CROSS;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="无向图例子"><a href="#无向图例子" class="headerlink" title="无向图例子"></a>无向图例子</h4><p>例如对当前的无向图：</p><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/dataStructure/85305440.jpg" width="75%/"><br></center><p>最终会得到一个支撑树：</p><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/dataStructure/27991522.jpg" width="75%/"><br></center><p>与BFS（v）类似，在有多个连通域的时候，需要将DFS（v）用while循环封装起来</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tv, <span class="keyword">typename</span> Te&gt;</span><br><span class="line"><span class="keyword">void</span> Graph&lt;Tv, Te&gt;::dfs(<span class="keyword">int</span> s)&#123;</span><br><span class="line">    reset();                               <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">int</span> clock = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> v = s;</span><br><span class="line">    <span class="keyword">do</span>                                    <span class="comment">// 逐一检查所有顶点</span></span><br><span class="line">        <span class="keyword">if</span>(UNDISCOVERD = status(v))       <span class="comment">// 一旦有尚未发现的顶点就从该点出发启动一次DFS      </span></span><br><span class="line">            DFS(v, clock);</span><br><span class="line">    <span class="keyword">while</span>(s != (v = ++v % n));            <span class="comment">// 按序号访问，不重不漏</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在有向图中，情况更为复杂。一旦出现BACKWARD边，则表明图中出现了环路。</p><h4 id="括号引理"><a href="#括号引理" class="headerlink" title="括号引理"></a>括号引理</h4><p>顶点活动期：<code>active[u] = (dTime[u], fTime[u])</code><br>嵌套引理：给定有向图$G = (V, E)$及其任一DS森林，则</p><ul><li>u是v的后代，if and only if active[u]$\subseteq $active[v]</li><li>u是v的祖先，if and only if activate[u]$\supseteq $activate[v]</li><li>u与v无关，if and only if actiavte[u]$\cap$active[v] = $\varnothing$</li></ul><p>祖先的活跃期必定包含后代的活跃期。借助时间标签可以在$O(1)$的时间内得出两个节点之间的祖先关系，若没有时间标签则需要从起点一直追溯到终点。</p>]]></content>
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据结构之二叉搜索树</title>
      <link href="/2018/04/06/data_structure/dataStructureBST/"/>
      <url>/2018/04/06/data_structure/dataStructureBST/</url>
      <content type="html"><![CDATA[<h1 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="循关键码访问"><a href="#循关键码访问" class="headerlink" title="循关键码访问"></a>循关键码访问</h3><p>数据各项之间，依照各自的关键码彼此区分。其中关键码需要满足以下条件</p><ul><li>大小比较</li><li>相等比对</li></ul><p>数据集合中的数据项统一表示和实现为词条（entry）形式<br>词条：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt; <span class="class"><span class="keyword">struct</span> <span class="title">Entry</span>&#123;</span></span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry(K k=K(), V v=V()):key(k), value(v)&#123;&#125;;   <span class="comment">//默认构造函数</span></span><br><span class="line">    Entry(Entry&lt;K, V&gt; <span class="keyword">const</span> &amp; e):key(e.key), value(e.value)&#123;&#125;;  <span class="comment">// 克隆比较器、判断器</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (Entry&lt;K, V&gt; <span class="keyword">const</span> &amp; e)&#123;<span class="keyword">return</span> key &lt; e.key&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt; (Entry&lt;K, V&gt; <span class="keyword">const</span> &amp; e)&#123;<span class="keyword">return</span> key &gt; e.key&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>== (Entry&lt;K, V&gt; <span class="keyword">const</span> &amp; e)&#123;<span class="keyword">return</span> key == e.key&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!= (Entry&lt;K, V&gt; <span class="keyword">const</span> &amp; e)&#123;<span class="keyword">return</span> key != e.key&#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="BST"><a href="#BST" class="headerlink" title="BST"></a>BST</h3><p>二叉搜索树（Binary Search Tree）首先是一颗二叉树，其次处处满足顺序性，即它的任一节点不小于其左后代或任一节点不大于其右后代。</p><ul><li>顺序性：为局部的特征，但考察BST的中序遍历时可以发现它必然是单调非降的。</li><li>这一性质是BST的充要条件</li></ul><p>例如下面的一颗BST</p><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/dataStructure/48098822.jpg" width="75%/"><br></center><p>根据中序遍历的顺序，列出访问的节点，可以看出其值为单调递增的。</p><h4 id="BST模板"><a href="#BST模板" class="headerlink" title="BST模板"></a>BST模板</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">BST</span>:</span><span class="keyword">public</span> BinTree&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span>:          <span class="comment">// virtual修饰，便于派生类重写</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">BinNodePosi</span><span class="params">(T)</span> &amp; <span class="title">search</span><span class="params">(<span class="keyword">const</span> T &amp;)</span></span>;  <span class="comment">// 查找</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">BinNodePosi</span><span class="params">(T)</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> T &amp;)</span></span>;    <span class="comment">// 插入</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> T &amp;)</span></span>;              <span class="comment">// 删除</span></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    BinNodePosi(T) _hot;                         <span class="comment">// 命中节点的父亲</span></span><br><span class="line">    BinNodePosi(T) connect34(                    <span class="comment">// 3+4重构</span></span><br><span class="line">    BinNodePosi(T), BinNodePosi(T), BinNodePosi(T),</span><br><span class="line">    BinNodePosi(T), BinNodePosi(T), BinNodePosi(T), BinNodePosi(T));</span><br><span class="line">    BinNodePosi(T) rotateAt(BinNodePosi(T));     <span class="comment">// 旋转调整    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>使用减而治之的方法，从根节点出发，逐步缩小查找范围，直到发现目标，或查找到空树，查找失败。</p><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/dataStructure/73352075.jpg" width="75%/"><br></center><p>上面的例子需要查找到23，箭头方向表明了查找的路径，最后查找到了叶节点22，因此查找失败。整个过程可以视为在仿效有序向量的二分查找。</p><h4 id="实现方法一："><a href="#实现方法一：" class="headerlink" title="实现方法一："></a>实现方法一：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">BinNodePosi(T) &amp; BST&lt;T&gt;::search(<span class="keyword">const</span> T &amp; e)&#123;</span><br><span class="line">    <span class="keyword">return</span> searchIn(_root, e, _hot = <span class="literal">NULL</span>);          <span class="comment">// 从根节点启动查找</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 尾递归，可以更改为迭代操作</span></span><br><span class="line"><span class="comment">// v是当前树根节点</span></span><br><span class="line"><span class="comment">// e是目标关键码</span></span><br><span class="line"><span class="comment">// hot为记忆热点</span></span><br><span class="line">static BinNodePosi(T) &amp; searchIn(BinNodePosi(T) &amp; v, const T &amp; e, BinNodePosi(T) &amp; hot)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!v || (e == v-&gt;data))      <span class="comment">// 当前子树已经为空则返回失败</span></span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">    hot = v;</span><br><span class="line">    <span class="keyword">return</span> searchIn((e &lt; v-&gt;data ? v-&gt;lChild : v-&gt;rChild), e, hot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法每递归一次，子树都会下降一层，因此其运行的时间正比于返回节点v的深度，但不超过树高，则耗时为：$O(h)$</p><h4 id="查找接口语义"><a href="#查找接口语义" class="headerlink" title="查找接口语义"></a>查找接口语义</h4><ul><li>返回值引用<ul><li>成功时：指向一个关键码为e且真实存在的节点，<code>_hot</code>指向返回命中节点的父亲</li><li>失败时：指向最后一次试图转向空节点NULL，<code>_hot</code>指向最后一次转向的真实节点</li></ul></li></ul><p>空节点意思是其数值为NULL</p><ul><li>在失败时，可以假象那个空节点为哨兵节点，并将其关键值假象为目标关键码</li><li>引入假象哨兵后，相当于返回值总是等效于命中节点，<code>_hot</code>总是指向命中节点的父亲</li></ul><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><h4 id="过程："><a href="#过程：" class="headerlink" title="过程："></a>过程：</h4><ul><li>借助<code>search(e)</code>确定插入位置和方向，再将新节点作为叶子插入</li><li>若e不存在<ul><li><code>_hot</code>为新节点的父亲</li><li><code>v = search(e)</code>为<code>_hot</code>对新孩子的引用</li></ul></li><li>令<code>_hot</code>通过v指向新节点</li></ul><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; BinNodePosi(T) BST&lt;T&gt;::insert(<span class="keyword">const</span> T &amp; e)&#123;</span><br><span class="line">    BinNodePosi(T) &amp; x = search(e);      <span class="comment">// 查找目标</span></span><br><span class="line">    <span class="keyword">if</span>(!x)&#123;                              <span class="comment">// 查找目标为空，即查找失败</span></span><br><span class="line">        x = <span class="keyword">new</span> BinNode&lt;T&gt;(e, _hot);     <span class="comment">// 在x处创建新节点，并以_hot为父亲</span></span><br><span class="line">        _size++;                         <span class="comment">// 更新全树规模</span></span><br><span class="line">        updateHeightAbouve(x);           <span class="comment">// 更新x及历代祖先的高度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此算法主要的时间消耗在于<code>search(e)</code>和<code>updateHeightAbove(x)</code>两个函数都线性正比于返回节点x的深度，不超过树高<code>O(h)</code>。</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">bool</span> BST&lt;T&gt;::remove(<span class="keyword">const</span> T &amp; e)&#123;</span><br><span class="line">    BinNodePosi(T) &amp; x = search(e);      <span class="comment">// 定位目标节点</span></span><br><span class="line">    <span class="keyword">if</span>(!x)                               <span class="comment">// 忽略元素尚不存在的情况</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    removeAt(x, _hot);</span><br><span class="line">    _size--;</span><br><span class="line">    updateHeightAbove(_hot);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此算法在不考虑<code>removeAt(x, _hot)</code>时，时间主要消耗仍然在于<code>search(e)</code>和<code>updateHeightAbove(x)</code>，累计的时间消耗也是$O(h)$。接下来考虑<code>removeAt(x, _hot)</code>的情况</p><h4 id="情况一"><a href="#情况一" class="headerlink" title="情况一"></a>情况一</h4><p>如果删除的节点还有左孩子或者右孩子，只需要将对象删除，并且以它的子节点作为新进节点替代被删除的节点。这样可以保持BST的拓扑结构，也满足顺序性。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">static</span> <span class="title">BinNodePosi</span><span class="params">(T)</span></span></span><br><span class="line">removeAt(BinNodePosi(T) &amp; x, BinNodePosi(T) &amp; hot)&#123;</span><br><span class="line">    BinNodePosi(T) w = x;                   <span class="comment">// 实际被删除的节点</span></span><br><span class="line">    BinNodePosi(T) succ = <span class="literal">NULL</span>:             <span class="comment">// 被删除节点的替代</span></span><br><span class="line">    <span class="keyword">if</span>(!HasLChild(*x))                      <span class="comment">// 左子树为空</span></span><br><span class="line">    succ = x = x-&gt;rChild;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!HasRChild(*x))                 <span class="comment">// 右子树为空</span></span><br><span class="line">    succ = x = x-&gt;lChild;</span><br><span class="line">    <span class="keyword">else</span>&#123;                                   </span><br><span class="line">        <span class="comment">/******左右子树并存**********/</span></span><br><span class="line">    &#125;</span><br><span class="line">    hot = w-&gt;parent;                        <span class="comment">// 被删除节点的父亲</span></span><br><span class="line">    <span class="keyword">if</span>(succ)</span><br><span class="line">    succ-&gt;parent = hot;</span><br><span class="line">    release(w-&gt;data);                       <span class="comment">// 释放别删除节点</span></span><br><span class="line">    release(w);</span><br><span class="line">    <span class="keyword">return</span> succ;                            <span class="comment">// 返回替代节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下，只需要$O(1)$的时间。当左右孩子都为空时，<code>succ</code>指向<code>NULL</code>，上面的代码仍然正确。</p><h4 id="情况二"><a href="#情况二" class="headerlink" title="情况二"></a>情况二</h4><p>当左右孩子并存的时候，需要化繁为简。此处需要用到在二叉树中实现的一个接口<code>BinNode::succ()</code>该接口的作用是返回当前节点在中序遍历下的直接后继。找到之后将当前需要删除的节点和其直接后继调换位置，这时是一个中间状态，已经不再是一颗BST了。最后删除在直接后继位置处的目标节点，完成节点删除，重新变成一颗BST。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">static</span> <span class="title">BinNodePosi</span><span class="params">(T)</span></span></span><br><span class="line">removeAt(BinNodePosi(T) &amp; x, BinNodePosi(T) &amp; hot)&#123;</span><br><span class="line">    <span class="comment">/*.........*/</span></span><br><span class="line">    <span class="keyword">else</span>&#123;     <span class="comment">// 左右子树均存在</span></span><br><span class="line">        w = w-&gt;succ();</span><br><span class="line">        swap(x-&gt;data, w-&gt;data);           <span class="comment">// *x与其直接后继*w互换数据   </span></span><br><span class="line">        BinNodePosi(T) u = w-&gt;parent;     <span class="comment">// 原问题转换为 摘除直接后继</span></span><br><span class="line">        (u == x ? u-&gt;rChild : u-&gt;lChild) = succ = w-&gt;rChild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*.........*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其直接后继至多只有一个右孩子，因为作为直接后继，它一定是某条分支的左侧末端 。此时的时间消耗主要在于<code>succ()</code>其正比于x的高度，因此<code>search()</code>和<code>succ()</code>共不超过$O(h)$ 。</p><h2 id="平衡等价"><a href="#平衡等价" class="headerlink" title="平衡等价"></a>平衡等价</h2><ul><li><p>BST主要接口的运行时间在最坏的情况下，线性正比于树高$O(h)$</p></li><li><p>在最坏的情况下，BST可能退化为一个列表，此时的查找效率会降为$O(n)$，线性正比于列表的规模</p></li></ul><h3 id="两种口径"><a href="#两种口径" class="headerlink" title="两种口径"></a>两种口径</h3><ol><li>随机生成</li></ol><p>对于n个互异的词条$\left { e_{1},e_{2}, ….., e_{n} \right }$对任一排列$\sigma = \left { e_{i1},e_{i2}, ….., e_{in} \right }$，从空树开始，反复调用<code>insert()</code>接口将各词条依次插入，得到$T(\sigma)$，与$\sigma$对应的$T(\sigma)$称为由$\sigma$随机生成的BST。</p><ul><li>任一排列作为输入的概率均等，为$\frac{1}{n!}$</li><li>由n个互异词条随机生成的BST平均高度为$\Theta \left ( logn \right )$。</li></ul><ol start="2"><li>随机组成</li></ol><p>对于n个互异的词条，在遵循顺序性的前提下，可随机确定拓扑连接关系。由此所得的BST称为这组词条的随机组成。</p><ul><li>由n个互异词条随机组成的BST，若共计$T(n)$棵，$T(n)=catalan(n)=\sum_{k=1}^{n}SP(k-1)\cdot SP(n-k)$。</li><li>所有BST等概论出现，其平均高度为$\Theta(\sqrt{n})$。</li></ul><p>按照两种口径的平均性能，随机组成更为可信。因为在随机生成的过程中，不同的随机序列可能生成同一棵BST</p><h3 id="两种平衡"><a href="#两种平衡" class="headerlink" title="两种平衡"></a>两种平衡</h3><ol><li>理想平衡</li></ol><ul><li>节点数目相对固定时，兄弟子树高度越接近平衡，全树也将倾向于更低。</li><li>由n个节点组成的二叉树，高度不低于$log_{2}n$，当正好等于$log_{2}n$时为理想平衡</li><li>理想平衡时相当于完全树甚至满树，此时条件太苛刻</li></ul><ol start="2"><li>适度平衡</li></ol><ul><li>理想平衡出现概率极低，且维护成本过高，需要适当放松标准</li><li>高度渐进，不超过$O(logn)$，称为适度平衡</li><li>适度平衡BST称为平衡二叉搜索树（BBST)</li></ul><h3 id="等价BST"><a href="#等价BST" class="headerlink" title="等价BST"></a>等价BST</h3><ul><li>上下可变：连接关系不尽相同，承袭关系可能颠倒</li><li>左右不乱：中序遍历序列完全一致，全局单调非降</li></ul><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/dataStructure/21182931.jpg" width="75%/"><br></center><p>如图这个例子可以看出其中序遍历序列完全相同，但其部分子序列拓扑结构并不相同。这样一对BST称为等价的BST。</p><p>对于各种BBST，将BST转换为BBST时，需要限制1. 单次动态修改操作后，至多$O(1)$处局部不再满足限制条件，2. 可以在$O(logn)$时间内，使得这些局部满足更新。</p><h2 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h2><ul><li>AVL树是一种BBST，在AVL的标准下的平衡因子为<code>balFac(v) = height(lc(v)) - height(rc(v))</code></li><li>AVL树即是对任意的节点，其平衡因子都不超过1也不小于-1的BST。</li><li>AVL树是适度平衡的，其高度不超过$O(logn)$</li></ul><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># define Balanced(x) (stature((x).lChild) == stature((x).rChild))  // 理想平衡</span><br><span class="line"># define BalFac(x) (stature((x).lChild) - stature((x).rChild))     // 平衡因子</span><br><span class="line"># define AvlBalabced(x) ((-2 &lt; BalFac(x)) &amp;&amp; (BalFac(x) &lt; 2))      // AVL平衡条件</span><br><span class="line">template &lt;typename T&gt; class AVL:public BST&lt;T&gt; &#123;                    // 继承自BST</span><br><span class="line">    public:                                                        // 沿用BSF::search()接口</span><br><span class="line">    BinNodePosi(T) insert(const T &amp;);                          // 插入重写</span><br><span class="line">    bool remove(const T &amp;);                                    // 删除重写</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><p>在按照BST规则插入或删除节点后，AVL的平衡性会被破坏，因此需要借助等价变换</p><ul><li>局部性：所有旋转都在局部进行 （每次仅需要$O(1)$时间）</li><li>快速性：在每一深度只需检查并旋转至多一次 （共$O(logn)$次）</li></ul><h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><ol><li>单旋插入</li></ol><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/dataStructure/85915049.jpg" width="75%/"><br></center><p>   如上图所示，如果需要在v下面插入左孩子或者右孩子，则需要让g单旋调整，具体过程为：</p><ul><li>引入临时引用，指向节点p</li><li>令p的左子树T1变为g的右子树</li><li>令g为p的左孩子</li><li>局部子树的根g替换为p</li></ul><p>操作完成之后，局部子树的高度恢复，其更高的祖先也必然是平衡的，使得全树复衡。</p><ol start="2"><li>双旋插入</li></ol><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/dataStructure/7993033.jpg" width="75%/"><br></center><p>同时可有多个失衡及诶单，最低者g不低于x的祖父，g经过双旋调整后复衡，子树高度复原，其更高的祖先也必然是平衡的，使得全树复衡。</p><p>其过程为：    </p><ul><li>围绕p顺时针旋转，<code>zig(p)</code><ul><li>引入临时变量，指向节点v</li><li>令v的右子树变为p的左子树</li><li>令p为v的右孩子</li><li>令g的右孩子为v<ul><li>围绕节点g做一次逆时针旋转，<code>zag(g)</code></li></ul></li></ul></li><li>将临时变量指向节点v</li><li>令v的左子树变为g的右子树</li><li>令g为v的左孩子</li><li>局部子树的根由g替换为v</li></ul><h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; BinNodePosi(T) AVL&lt;T&gt;::insert(<span class="keyword">const</span> T &amp; e)&#123;</span><br><span class="line">    BinNodePosi(T) &amp; x = search(e);</span><br><span class="line">    <span class="keyword">if</span> (x)</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">    BinNodePosi(T) xx = x = <span class="keyword">new</span> BinNode&lt;T&gt;(e, _hot);     <span class="comment">// 目标不存在则创建新节点</span></span><br><span class="line">    _size++;</span><br><span class="line">    <span class="comment">// 从x的父亲_hot出发，逐层向上，依次检查各代祖先g</span></span><br><span class="line">    <span class="keyword">for</span> (BinNodePosi(T) g = _hot; g; g = g-&gt;parent)&#123;</span><br><span class="line">        <span class="keyword">if</span> (! AvlBalanced(*g))&#123;                          <span class="comment">// 一旦失衡就进行调整</span></span><br><span class="line">            FromParentTo(*g) = rotateAt(tallerChild(tallerChild(g)));</span><br><span class="line">            <span class="keyword">break</span>;                                       <span class="comment">// 完成对v，p，g的调整后就退出循环</span></span><br><span class="line">        &#125;<span class="keyword">else</span>                                            <span class="comment">// 未失衡，就更新其高度</span></span><br><span class="line">        updateHeight(g);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> xx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><ol><li><p>单旋删除</p><p>在图中这种情况下，g、p、v是朝同一个方向排列。将T3的一个叶节点删除，会引起g点失衡。因此需要围绕点g进行一次zig操作。</p></li></ol><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/dataStructure/85320993.jpg" width="75%/"><br></center><p>   当T2最后的那个节点不存在，即调整后的子树高缩减了1，因此有可能引起更上一层的失衡，称为失衡传播现象，可能需要做$O(logn)$次调整。</p><ol start="2"><li><p>双旋删除</p><p>在此图中，g、p、v并不是朝着同一个方向排列，此时删除T3的一个节点。</p></li></ol><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/dataStructure/69399379.jpg" width="75%/"><br></center><p>   这种情况下首先要围绕p做一次zag旋转，再围绕g做一次zig旋转。</p><p>   旋转完成后，情况和单旋类似，T1和T2这两棵子树可能其中一个会存在一个叶节点，那么旋转之后子树的高度缩减1，仍可能引起失衡，可能需要做$O(logn)$次调整。</p><h5 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">bool</span> AVL&lt;T&gt;::remove(<span class="keyword">const</span> T &amp; e)&#123;</span><br><span class="line">    BinNodePosi(T) &amp; x = search(e);</span><br><span class="line">    <span class="keyword">if</span>(!x)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    removeAt(x, _hot);                         <span class="comment">// x存在则删除x</span></span><br><span class="line">    size--;</span><br><span class="line">    <span class="comment">// 从_hot出发逐层向上，依次检查各代祖先</span></span><br><span class="line">    <span class="keyword">for</span> (BinNodePosi(T) g = _hot; g; g = g-&gt;parent)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!AvlBalanced(*g))</span><br><span class="line">        g = FromParentTo(*g) = rotateAt(tallerChild(tallerChild(g)));</span><br><span class="line">        updateHeight(g);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中for循环可能要做$\Omega(logn)$次调整</p><h3 id="3-4重构"><a href="#3-4重构" class="headerlink" title="3+4重构"></a>3+4重构</h3><p>设g(x)为最低的失衡节点，考察祖孙三代：g、p、v，按照中序遍历次序，将其重命名为$a &lt; b &lt; c$。则他们共拥有互不相交的四棵（可能为空）的子树，按照中序遍历次序命名为$T_{0}&lt; T_{1} &lt; T_{2} &lt; T_{3}$。将原来以g为根的子树替换为一颗新的子树$S’$。</p><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/dataStructure/64989590.jpg" width="75%/"><br></center><h4 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; BinNodePosi(T) BST&lt;T&gt;::connect34(</span><br><span class="line">BinNodePosi(T) a, BinNodePosi(T) b, BinNodePosi(T) c,</span><br><span class="line">BinNodePosi(T) T0, BinNodePosi(T) T1, BinNodePosi(T) T2, BinNodePosi(T) T3,)&#123;</span><br><span class="line">        a-&gt;lChild = T0;</span><br><span class="line">        <span class="keyword">if</span> (T0) </span><br><span class="line">        T0-&gt;parent = a;</span><br><span class="line">        a-&gt;rChild = T1;</span><br><span class="line">        <span class="keyword">if</span> (T1)&#123;</span><br><span class="line">            T1-&gt;parent = a;</span><br><span class="line">            updateHeight(a);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        c-&gt;lChild = T2;</span><br><span class="line">        <span class="keyword">if</span> (T2) </span><br><span class="line">        T2-&gt;parent = c;</span><br><span class="line">        c-&gt;rChild = T3;</span><br><span class="line">        <span class="keyword">if</span> (T3)&#123;</span><br><span class="line">            T3-&gt;parent = c;</span><br><span class="line">            updateHeight(c);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        b-&gt;lChild = a;</span><br><span class="line">        a-&gt;parent = b;</span><br><span class="line">        b-&gt;rChild = c;</span><br><span class="line">        c-&gt;parent = b;</span><br><span class="line">        updateHeight(b);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> b;                  <span class="comment">//返回子树新的根节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将<code>rotateAt()</code>完整化</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;typenmae T&gt; BinNodePosi(T) BST&lt;T&gt;::rotateAt(BinNodePosi(T) v)&#123;</span><br><span class="line">    BinNodePosi(T) p = v-&gt;parent;</span><br><span class="line">    g = p-&gt;parent;</span><br><span class="line">    <span class="keyword">if</span>(IsLChild(*p))&#123;                    <span class="comment">// zig</span></span><br><span class="line">        <span class="keyword">if</span>(IsLChild(*v))&#123;                <span class="comment">// zig-zig</span></span><br><span class="line">            p-&gt;parent = g-&gt;parent;</span><br><span class="line">            <span class="keyword">return</span> connect34(v, p, g, v-&gt;lChild, v-&gt;rChild, p-&gt;rChild, g-&gt;rChild);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;                           <span class="comment">// zig-zag</span></span><br><span class="line">            v-&gt;parent = g-&gt;parent;</span><br><span class="line">            <span class="keyword">return</span> connect34(p, v, g, p-&gt;lChild, v-&gt;lChild, v-&gt;rChild, g-&gt;rChild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;                               <span class="comment">// zag</span></span><br><span class="line">        <span class="keyword">if</span>(IsRChild(*v))&#123;                <span class="comment">// zag-zag</span></span><br><span class="line">            p-&gt;parent = g-&gt;parent;</span><br><span class="line">            <span class="keyword">return</span> connect34(g, p, v, g-&gt;lChild, p-&gt;lChild, v-&gt;lChild, v-&gt;rChild);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;                           <span class="comment">// zag-zig</span></span><br><span class="line">            v-&gt;parent = g-&gt;parent;</span><br><span class="line">            <span class="keyword">return</span> connect34(g, v, p, g-&gt;lChild, v-&gt;lChild, v-&gt;rChild, p-&gt;rChild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>zig-zig 和zig-zag分别对应于：</p><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/dataStructure/88247417.jpg" width="75%/"><br></center><p>剩下两种情况恰好与之相反。</p><h3 id="AVL树性能"><a href="#AVL树性能" class="headerlink" title="AVL树性能"></a>AVL树性能</h3><p>优点： </p><ul><li>无论查找、插入或删除，最坏情况下的复杂度均为$O(logn)$，存储空间为$O(n)$</li></ul><p>缺点：</p><ul><li><p>引入平衡因子，需要改造元素结构或者进行额外封装</p></li><li><p>其实测性能和理论性能差距较大</p><ul><li><p>插入删除时的zig，zag成本高</p></li><li><p>删除操作最多需要旋转$\Omega(logn)$次，若频繁插入或删除成本过高。、</p></li></ul></li><li><p>单次动态调整后，全树拓扑结构变化量可能达到$\Omega(logn)$</p></li></ul>]]></content>
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据结构之二叉树</title>
      <link href="/2018/04/06/data_structure/dataStructureBinaryTree/"/>
      <url>/2018/04/06/data_structure/dataStructureBinaryTree/</url>
      <content type="html"><![CDATA[<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><ul><li>向量的search操作效率较高，如二分查找，其效率可以达到$log(n)$，但其动态操作，无论是插入和删除，其效率都较低，需要线性的时间。</li><li>列表的search操作，其效率较低，需要线性的时间，但由于其循位置访问的方式，一旦给定具体的操作位置，对于列表的动态操作就只需要在局部进行，时间损耗为$O(1)$。</li><li>二叉树结合了向量和列表的优点，可以理解为二维的列表。将树形结构称为半线性结构。</li></ul><h3 id="树的基本概念"><a href="#树的基本概念" class="headerlink" title="树的基本概念"></a>树的基本概念</h3><ol><li>树： 在树型结构中，彼此元素之间的关系为edge，顶点为vertex，区别于列表中的node。需要为每一棵树指定一个特殊的顶点，称为根(root)。</li><li>有根树：指定了其中一个顶点作为根的树。通过彼此的嵌套，小型的有根树可以逐步地整合为规模更大的有根树。</li><li>兄弟树(sibling)：同一棵树的子树，它们之间根据度（degree）来度量。</li><li>度数、顶点、边数间的关系：顶点的度数之和 = 边数 = 顶点总数-1。度数和顶点数同阶，因此在考虑算法时间复杂度时，以顶点数n作为参照。</li><li>有序树：对有同一个父顶点的兄弟树编号，此时的这些兄弟树都是有序树。</li></ol><h3 id="树结构特性"><a href="#树结构特性" class="headerlink" title="树结构特性"></a>树结构特性</h3><h4 id="连通性"><a href="#连通性" class="headerlink" title="连通性"></a>连通性</h4><p>k+1个节点通过k条边依次相连，构成一条路径。其路径长度=边数。<br>连通图（connected）：节点之间均有路径</p><h4 id="无环性"><a href="#无环性" class="headerlink" title="无环性"></a>无环性</h4><p>当第1个节点和第k+1个节点相连时，构成一个环路（loop）<br>无环图（acyclic）：不含环路的图</p><h4 id="树特性"><a href="#树特性" class="headerlink" title="树特性"></a>树特性</h4><ul><li>无环连通图</li><li>极小连通图</li><li>极大无环图</li></ul><p>任一节点v与根之间存在唯一路径。因此一旦确定了根之后，所有的节点都可以根据这条唯一的路径定义一个参数depth，即v在这颗树中的深度。定义在path(v)上的节点为v的祖先（ancestor），v是它们的后代（descendent）。</p><ul><li>半线性：在任意深度v的祖先 / 后代存在，则必然 / 未必唯一。</li></ul><p>没有后代的节点称为叶子（leaf），所有叶子中深度最大的为树的高度，子树的高度也就是其根节点的深度。</p><h3 id="树的表示"><a href="#树的表示" class="headerlink" title="树的表示"></a>树的表示</h3><p>树结构的接口：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root()           根节点</span><br><span class="line">parent()         父节点</span><br><span class="line">firstChild()     长子</span><br><span class="line">nextSibling()    兄弟</span><br><span class="line">insert(i, e)     将e作为第i个孩子插入</span><br><span class="line">remove(i)        删除第i个孩子（及其后代）</span><br><span class="line">traverse()       遍历</span><br></pre></td></tr></table></figure></p><p>由于每个节点只有一个父节的特性，在向上查询时，可以取得很好的效果，但在向下查询时需要遍历所有节点。在表格中增加子节点的信息，使得向下查找只需遍历当前节点的子节点。</p><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/dataStructure/65826164.jpg" width="50%/"><br></center><p>但是这样操作对于子节点仍然有些多余，因此考虑将子节点查找的结构变为：</p><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/dataStructure/70722176.jpg" width="50%/"><br></center><p>每个节点均设置两个引用，横纵坐标方向为firstChild()，纵坐标方向为nextSibling()。</p><h2 id="二叉树-1"><a href="#二叉树-1" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树是节点度数不超过2的树，同一节点的孩子和子树用左右进行区分表示为：</p><ul><li>lChild()     ——   lSubtree()</li><li>rChiled()  ——   rSubtree()<br>这里已经隐含了树的有序性。</li></ul><h3 id="基本特性"><a href="#基本特性" class="headerlink" title="基本特性"></a>基本特性</h3><ul><li>所有深度为k的节点最多不超过$2^{k}$个</li><li>含有n个节点，高度为h的二叉树中，其数量关系为：$h&lt;n&lt;2^{h+1}$<ul><li>当$n=h+1$时，二叉树退化为一条单链</li><li>当$n=2^{h+1}-1$时，得到满二叉树(full binary tree)即所有节点的度数都是2</li></ul></li></ul><p>对于二叉树而言，其宽度随高度呈指数增长，称为涨宽。</p><ul><li>真二叉树：对于只有单分支或者叶子节点添加一个或2个对应数据为0的孩子，将这个二叉树变为一个满二叉树。</li></ul><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/dataStructure/51267035.jpg" width="50%/"><br></center><p>二叉树可以描述任意一颗树，将任意一棵树用长子-兄弟法表示。多出的兄弟节点可以用兄弟节点的子节点表示。</p><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/dataStructure/13837723.jpg" width="50%/"><br></center><h3 id="二叉树的实现"><a href="#二叉树的实现" class="headerlink" title="二叉树的实现"></a>二叉树的实现</h3><p>二叉树的基本组成单位是binary node。<br>BinNode模板类：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> BinNodePosi(T) BinNode<span class="meta-string">&lt;T&gt;*   //节点位置</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">struct</span> <span class="title">BinNode</span>&#123;</span></span><br><span class="line">    BinNodePosi(T) parent, lChild, rChild;</span><br><span class="line">    T data;</span><br><span class="line">    <span class="keyword">int</span> height;  <span class="comment">//高度</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;  <span class="comment">//子树规模</span></span><br><span class="line">    BinNodePosi(T) insertAsLC(T <span class="keyword">const</span> &amp;);                 <span class="comment">//作为左孩子插入</span></span><br><span class="line">    BinNodePosi(T) insertAsRC(T <span class="keyword">const</span> &amp;);                 <span class="comment">//作为右孩子插入</span></span><br><span class="line">    BinNodePosi(T) succ();                                <span class="comment">//当前节点的直接后继</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VST&gt; <span class="function"><span class="keyword">void</span> <span class="title">travLevel</span><span class="params">(VST &amp;)</span></span>;        <span class="comment">//子树层次遍历</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VST&gt; <span class="function"><span class="keyword">void</span> <span class="title">travPre</span><span class="params">(VST &amp;)</span></span>;          <span class="comment">//子树先序遍历</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VST&gt; <span class="function"><span class="keyword">void</span> <span class="title">travIn</span><span class="params">(VST &amp;)</span></span>;           <span class="comment">//子树中序遍历</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VST&gt; <span class="function"><span class="keyword">void</span> <span class="title">travPost</span><span class="params">(VST &amp;)</span></span>;        <span class="comment">//子树后序遍历</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BinNode接口实现：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">BinNodePosi(T) BinNode&lt;T&gt;::insertAsLC(T <span class="keyword">const</span> &amp; e)&#123;</span><br><span class="line">    <span class="keyword">return</span> lChild = <span class="keyword">new</span> BinNode(e, <span class="keyword">this</span>);   <span class="comment">// this.lChild = null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">BinNodePosi(T) BinNode&lt;T&gt;::insertAsRC(T <span class="keyword">const</span> &amp; e)&#123;  <span class="comment">//只需要常数时间</span></span><br><span class="line">    <span class="keyword">return</span> rChild = <span class="keyword">new</span> BinNode(e, <span class="keyword">this</span>);   <span class="comment">// this.rChild = null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;   </span><br><span class="line"><span class="keyword">int</span> BinNode&lt;T&gt;::size()&#123;          <span class="comment">//后代的总数是其根的子树之和。递归统计子树规模，需要线性时间</span></span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(lChild)&#123;</span><br><span class="line">        s += lChild-&gt;size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(rChild)&#123;</span><br><span class="line">        s += rChild-&gt;size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>BinTree模板：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">BinTree</span>&#123;</span></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        <span class="keyword">int</span> _size;</span><br><span class="line">        BinNodePosi(T) _root; <span class="comment">//根节点</span></span><br><span class="line">        virtual int updateHeight(BinNodePosi(T) x);  //更新节点x高度</span><br><span class="line">        void updateHeightAbove(BinNodePosi(T) x);    //更新x及祖先高度</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="keyword">return</span> _size;&#125;              <span class="comment">//国模</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="keyword">return</span> !_root;&#125;           <span class="comment">//判断是否为空树</span></span><br><span class="line">        BinNodePosi(T) root() <span class="keyword">const</span>&#123;<span class="keyword">return</span> _root;&#125;   <span class="comment">//返回树根</span></span><br><span class="line">        <span class="comment">/*子树接入、删除、分离接口*/</span></span><br><span class="line">        <span class="comment">/*遍历接口  */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以高度更新接口为例：通过宏定义的封装方式高度，因为根据树的退化情况，其高度均不同。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> stature(p) ((p) ? (p)-&gt;height : -1)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> BinTree&lt;T&gt;::updateHeight(BinNodePosi(T) x)&#123;</span><br><span class="line">    <span class="keyword">return</span> x-&gt;height = <span class="number">1</span> + max(stature(x-&gt;lChild), stature(x-&gt;rChild));   <span class="comment">//采用常规二叉树规则，其时间复杂度为O(1)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> BinTree&lt;T&gt;::udateHeightAbouve(BinNodePosi(T) x)&#123;<span class="comment">//向上更新节点高度，其时间复杂度正比于树的深度。</span></span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">        updateHeight(x);</span><br><span class="line">        x = x-&gt;parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>节点插入：<br>在一个已有的树节点中，该节点原本没有右孩子。将新生成的一个节点插入到该节点的右侧，将其变为该节点的右孩子。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line">BinNodePosi(T)BinTree&lt;T&gt;::insertAsRC(BinNoidePosi(T) x)&#123;</span><br><span class="line">    _size++;</span><br><span class="line">    x-&gt;insertAsRC(e);</span><br><span class="line">    updateHeightAbove(x);</span><br><span class="line">    <span class="keyword">return</span> x-&gt;rChild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="二叉树相关算法"><a href="#二叉树相关算法" class="headerlink" title="二叉树相关算法"></a>二叉树相关算法</h3><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><p>按照某种次序访问数中的各个节点，使得每个节点被访问恰好一次。遍历分为先序、中序、后序，按照当前节点与其左右孩子节点的访问次序来划分。</p><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/dataStructure/10018835.jpg" width="50%/"><br></center><ol><li>先序遍历，时间复杂度为$O(n)$<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt;</span><br><span class="line">void traverse(BinNodePosi(T) x, VST &amp; visit)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x) <span class="keyword">return</span>;  <span class="comment">//先把树根节点取出访问再递归访问左右子节点</span></span><br><span class="line">    visit(x-&gt;data);</span><br><span class="line">    traverse(x-&gt;lChild, visit);</span><br><span class="line">    traverse(x-&gt;rChild, visit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>可以将尾递归的形式化简为迭代的形式，引入一个栈存储节点的位置。<br>第一种迭代方法：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt;</span><br><span class="line">void travPre_I1(BinNodePosi(T) x, VST &amp; visit)&#123;</span><br><span class="line">    Stack &lt;BinNodePosi(T)&gt; S;</span><br><span class="line">    <span class="keyword">if</span>(x) S.push(x);</span><br><span class="line">    <span class="keyword">while</span>(!S.empty())&#123;</span><br><span class="line">        x = S.pop();</span><br><span class="line">        visit(x-&gt;data);</span><br><span class="line">        <span class="keyword">if</span>(HasRChild(*x)) S.push(x-&gt;rChild); <span class="comment">//右孩子先入后出</span></span><br><span class="line">        <span class="keyword">if</span>(HasLChild(*x)) S.push(x-&gt;lChild); <span class="comment">//左孩子后入先出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第一种迭代方法较难理解，不便于判断子节点的遍历次序，引入第二种迭代方法：</p><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/dataStructure/51411613.jpg" width="50%/"><br></center><p>这种方法自上而下对做侧分支进行访问然后自下而上对右子树遍历。不同的右子树相互独立且自成一个子任务。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt;</span><br><span class="line">static void visitAlongLeftBranch(BinNodePosi(T) x, VST &amp; visit, Stack &lt;BinNodePosi(T)&gt; &amp; S)&#123;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">        visit(x-&gt;rChild);   <span class="comment">//访问当前节点</span></span><br><span class="line">        S.push(x-&gt;rChild);  <span class="comment">//右孩子入栈</span></span><br><span class="line">        x = x-&gt;lChild;      <span class="comment">//沿左侧链下行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt;</span><br><span class="line">void travPre_I2(BinNodePosi(T) x, VST &amp; visit)&#123;</span><br><span class="line">    Stack &lt;BinNodePosi(T)&gt; S;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        visitAlongLeftBranch(x, visit, S);</span><br><span class="line">        <span class="keyword">if</span>(S.empty()) <span class="keyword">break</span>;</span><br><span class="line">        x = S.pop();      <span class="comment">//弹出下一子树根</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>visitAlongLeftBranch()这个函数会从当前节点一直访问左侧链，并自下而上的将右子节点存入栈中。主循环只需要重复执行这个函数直到栈为空退出。</p><ol start="2"><li>中序遍历<br>递归算法：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt;</span><br><span class="line">void traverse(BinNodePosi(T) x, VST &amp; visit)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x) <span class="keyword">return</span>;  </span><br><span class="line">    traverse(x-&gt;lChild, visit);</span><br><span class="line">    visit(x-&gt;data);</span><br><span class="line">    traverse(x-&gt;rChild, visit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>根据观察可以发现中序遍历是从根节点开始沿左侧分支向下，直到找到最后一个左孩子，访问左孩子后再访问上层节点，最后访问该上层节点的右孩子。</p><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/dataStructure/99511231.jpg" width="50%/"><br></center><p>迭代算法：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">static void goAlongLeftBranch(BinNodePosi(T) x, Stack &lt;BinNodePosi(T)&gt; &amp; S)&#123;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">        <span class="comment">//visit(x-&gt;rChild);   //访问当前节点</span></span><br><span class="line">        <span class="comment">//S.push(x-&gt;rChild);  //右孩子入栈</span></span><br><span class="line">        S.push(x);</span><br><span class="line">        x = x-&gt;lChild;      <span class="comment">//沿左侧链下行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt;</span><br><span class="line">void trav_I1(BinNodePosi(T) x, VST &amp; visit)&#123;</span><br><span class="line">    Stack &lt;BinNodePosi(T)&gt; S;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        goAlongLeftBranch(x, S);</span><br><span class="line">        <span class="keyword">if</span>(S.empty()) <span class="keyword">break</span>;</span><br><span class="line">        x = S.pop();      <span class="comment">//左侧节点访问</span></span><br><span class="line">        visit(x-&gt;data);</span><br><span class="line">        x = x-&gt;rChild;    <span class="comment">//转向右子树，当右子树为空时进行处理。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>goAlongLeftBranch（）函数从当前节点出发，逐批将左侧节点逆序入栈，直到找到最左侧节点。在主函数中弹出栈顶节点，进行访问后再转向右子树。最终主程序的时间复杂度为$O(n)$。</p><ol start="3"><li>后续遍历<br>递归算法：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt;</span><br><span class="line">void traverse(BinNodePosi(T) x, VST &amp; visit)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x) <span class="keyword">return</span>;  </span><br><span class="line">    traverse(x-&gt;lChild, visit);</span><br><span class="line">    traverse(x-&gt;rChild, visit);</span><br><span class="line">    visit(x-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/dataStructure/66214575.jpg" width="50%/"><br></center><p>在后序遍历的过程中，从左侧链最后一个节点开始，再访问其右子节点，再自下而上访问其父节点。<br>迭代算法：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">static void gotoHLVFL(Stack &lt;BinNodePosi(T)&gt; &amp; S)&#123;</span><br><span class="line">    <span class="keyword">while</span>(BinNodePosi(T) x= S.top())&#123;</span><br><span class="line">        <span class="keyword">if</span>(HasLChild(*x))&#123;</span><br><span class="line">            <span class="keyword">if</span>(HasRChild(*x)) S.push(x-&gt;rChild);</span><br><span class="line">            S.push(x-&gt;lChild);</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            S.push(x-&gt;rChild);</span><br><span class="line">    S.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt;</span><br><span class="line">void travPost_I(BinNodePosi(T) x, VST &amp; visit)&#123;</span><br><span class="line">    Stack &lt;BinNodePosi(T)&gt; S;</span><br><span class="line">    <span class="keyword">if</span>(x) S.push(x);</span><br><span class="line">    <span class="keyword">while</span>(!S.empth())&#123;</span><br><span class="line">        <span class="keyword">if</span>(S.top()!=x-&gt;parent) gotoHLVFL(S);</span><br><span class="line">        x = S.pop();      <span class="comment">//左侧节点访问</span></span><br><span class="line">        visit(x-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="4"><li>层次遍历<br>上面的三种遍历方式都存在子节点先于父节点接受访问的逆序情况，因此使用栈进行存储。对于层次遍历而言，所有子节点都应严格的后于父节点接受访问，即为顺序对每层访问，需要用到队列。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt;</span><br><span class="line"><span class="keyword">void</span> BinNode&lt;T&gt;::travPost_I( VST &amp; visit)&#123;</span><br><span class="line">    Queue&lt;BinNodePosi(T)&gt; Q;</span><br><span class="line">    Q.enqueue(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">        BinNodePosi(T) x = Q.dequeue();          <span class="comment">//取出队首节点并访问</span></span><br><span class="line">        visit(x-&gt;data);</span><br><span class="line">        <span class="keyword">if</span>(HasLChild(*x) Q.enqueue(x-&gt;lChild));  <span class="comment">//左孩子入队</span></span><br><span class="line">        <span class="keyword">if</span>(HasRChild(*x) Q.enqueue(x-&gt;rChild));  <span class="comment">//右孩子入队</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>每个节点入队、出队的操作恰好为1次，整体的时间复杂度为$O(n)$</p><h4 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h4><p>已知二叉树的排列序列，还原出二叉树。<br>已知树的中序 + 先序/后序 即可还原出原始的二叉树。</p>]]></content>
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据结构之栈和队列</title>
      <link href="/2018/04/06/data_structure/dataStructureStackAndQueue/"/>
      <url>/2018/04/06/data_structure/dataStructureStackAndQueue/</url>
      <content type="html"><![CDATA[<h1 id="栈（stack）"><a href="#栈（stack）" class="headerlink" title="栈（stack）"></a>栈（stack）</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>栈仍然是一个序列，遵循后进先出的原则。可以基于向量或列表派生，共有三种操作方法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push()    入栈   insert(size(), e)</span><br><span class="line">pop()     出栈   remove(size() -1)       </span><br><span class="line">top()     取顶操作    (*this)[size() -1]</span><br></pre></td></tr></table></figure><h2 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h2><ul><li>逆序输出：conversion 输出次序与处理过程颠倒，递归深度和输出长度不易预知</li><li>递归嵌套：stack permutation + parenthesis 具有自相似性的问题可递归描述，但分支位置和嵌套深度不固定</li><li>延迟缓冲：evaluation 线性扫描算法模式中，在预读足够长之后，才能确定可处理的前缀</li></ul><h3 id="逆序输出"><a href="#逆序输出" class="headerlink" title="逆序输出"></a>逆序输出</h3><p>逆序输出的一个应用为进制转换，将整除后的余数入栈，最后出栈。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convert</span><span class="params">(Stack&lt;<span class="keyword">char</span>&gt; &amp; S, _int64)</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> digit[] = &#123;<span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>, <span class="string">'7'</span>, <span class="string">'8'</span>, <span class="string">'9'</span>, <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        S.push(digit[n % base]);</span><br><span class="line">        n /= base;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">main()&#123;</span><br><span class="line">    Stack&lt;<span class="keyword">char</span>&gt; S;</span><br><span class="line">    convert(S, n, base);</span><br><span class="line">    <span class="keyword">while</span>(!S.empty())</span><br><span class="line">        print(<span class="string">"%c"</span>, S.pop());    <span class="comment">//逆序逆序输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="递归嵌套"><a href="#递归嵌套" class="headerlink" title="递归嵌套"></a>递归嵌套</h3><p>括号匹配是递归嵌套的一种应用。找到括号的方法即是遇到“（”则入栈，遇到“）”则出栈。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">paren</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> <span class="built_in">exp</span>[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">    Stack&lt;<span class="keyword">char</span>&gt; S;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = lo; i &lt; hi; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">'('</span> == <span class="built_in">exp</span>[i])          <span class="comment">//若遇到(则进栈</span></span><br><span class="line">            S.push(<span class="built_in">exp</span>[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!S.empty())        <span class="comment">//若遇到)且栈非空则出栈</span></span><br><span class="line">            S.pop();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;         <span class="comment">//若遇到)时栈已空，则不匹配</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> S.empty();              <span class="comment">//只有栈为空时匹配</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种算法可以便捷的推广到多种括号并存的情况，也可以引申至HTML语言中的标签上。</p><h4 id="栈混洗"><a href="#栈混洗" class="headerlink" title="栈混洗"></a>栈混洗</h4><p>将A栈的栈顶弹出存入S中转栈，然后将S栈的栈顶弹出存入到B栈，完成栈的混洗。若A全部转入S后弹出，A和B的栈顶和栈底顺序正好颠倒，若S弹出的开始时间是随机的，那么B栈中存储的数据顺序就是随机的。因此栈混洗的情况有catalan数种：$\frac{2n!}{\left ( n + 1 \right )!\times n!}$。<br>在级数排序时，有几种排序是禁形，如A中元素为123，B中为312，此时B不可能通过混洗得到。若一个排列是栈混洗，当且仅当其排序不包含312的形式。<br>判定是否为栈混洗的时候：</p><ul><li>每次S.pop()之前，判断S是否为空</li><li>若需弹出的元素在S中，却非顶元素</li></ul><h3 id="延迟缓冲"><a href="#延迟缓冲" class="headerlink" title="延迟缓冲"></a>延迟缓冲</h3><p>中缀表达式求值为延迟缓冲的应用<br>以算数表达式为例 ：求值算法=栈+线性扫描<br>实现算法：用两个栈分别存储运算数和运算符<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">evaluate</span><span class="params">(<span class="keyword">char</span>* S, <span class="keyword">char</span>* &amp; RPN)</span></span>&#123;        <span class="comment">//RPN转换</span></span><br><span class="line">    Stack&lt;<span class="keyword">float</span>&gt; opnd;                       <span class="comment">//运算数栈</span></span><br><span class="line">    Stack&lt;<span class="keyword">char</span>&gt; optr;                        <span class="comment">//运算符栈</span></span><br><span class="line">    optr.push(<span class="string">'\0'</span>);                          <span class="comment">//尾哨兵</span></span><br><span class="line">    <span class="keyword">while</span>(!optr.empty())&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isdigit</span>(*S))</span><br><span class="line">            readNumber(S, opnd);             <span class="comment">//读入操作数，可能为多位</span></span><br><span class="line">            append(RPN, opend.top());        <span class="comment">//接入RPN</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">switch</span>(orderBetween(optr.top(), *S))&#123; <span class="comment">//分别处理，判断当前运算符和栈顶运算符之间的优先级高低       </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> opnd.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在读入操作数时，需要进行处理，因为读入数可能是多位。如果当前number为一位数字，就入栈；如果是多位数字就需要对这几位数字进行处理：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">evaluate</span><span class="params">(<span class="keyword">char</span>* S, <span class="keyword">char</span>* &amp; RPN)</span></span>&#123;        <span class="comment">//RPN转换</span></span><br><span class="line">    Stack&lt;<span class="keyword">float</span>&gt; opnd;                       <span class="comment">//运算数栈</span></span><br><span class="line">    Stack&lt;<span class="keyword">char</span>&gt; optr;                        <span class="comment">//运算符栈</span></span><br><span class="line">    optr.push(<span class="string">'\0'</span>);                         <span class="comment">//尾哨兵</span></span><br><span class="line">    <span class="keyword">int</span> numBits = <span class="number">0</span>;                         <span class="comment">//用于存储数字的位数</span></span><br><span class="line">    <span class="keyword">while</span>(!optr.empty())&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isdigit</span>(*S))</span><br><span class="line">            numBits += <span class="number">1</span>;</span><br><span class="line">            readNumber(S, opnd, numBits);    <span class="comment">//读入操作数，可能为多位</span></span><br><span class="line">            append(RPN, opend.top());        <span class="comment">//接入RPN</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            numBits = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">switch</span>(orderBetween(optr.top(), *S))&#123; <span class="comment">//分别处理，判断当前运算符和栈顶运算符之间的优先级高低       </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> opnd.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">readNumber</span><span class="params">(<span class="keyword">char</span>* S, Stack opnd, <span class="keyword">int</span> num)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(num &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        opnd.push(*S);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">float</span> oOpnd = S;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">2</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            <span class="keyword">float</span> bitNum = opnd.pop()*<span class="number">10</span>^(i<span class="number">-1</span>)</span><br><span class="line">            oOpnd += bitNum;</span><br><span class="line">        &#125;</span><br><span class="line">        opnd.push(oOpnd);        </span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>判断运算符优先级采用表格存储，行为当前运算符，列为栈顶运算符 。</p><center><br><img src="https://github.com/niuyuanyuanna/BlogImages/raw/master/dataStructure/20181203.png" width="75%/"><br></center><p>对于不同优先级的处理方法：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(orderBetween(optr.top(), *S))&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'&lt;'</span>:                                  <span class="comment">//栈顶优先级低，推迟计算，当前运算符入栈</span></span><br><span class="line">        optr.push(*S);</span><br><span class="line">        S++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'='</span>:                                  <span class="comment">//优先级相等，脱括号，接收下一字符。只有在括号和\0的时候才有=出现</span></span><br><span class="line">        optr.pop();</span><br><span class="line">        S++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'&gt;'</span>:                                  <span class="comment">//栈顶优先级高，栈顶运算符出栈，执行计算</span></span><br><span class="line">        <span class="keyword">char</span> op = optr.pop();</span><br><span class="line">        append(RPN, op);     <span class="comment">//接入RPN</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">'!'</span> == op) </span><br><span class="line">            opnd.push(calcu(op, opnd.pop()))    <span class="comment">//一元运算符入栈</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">float</span> pOpnd2 = opnd.pop();</span><br><span class="line">            <span class="keyword">float</span> pOpnd1 = opnd.pop();</span><br><span class="line">            opnd.push(calcu(pOpnd1, op, pOpnd2));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逆波兰表达式（RPN）：不使用括号表示优先级，所有操作数的次序和在中缀表达式中的次序相同。</p><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><h2 id="队列基础"><a href="#队列基础" class="headerlink" title="队列基础"></a>队列基础</h2><p>队列接口与实现，先进先出，后进后出，其操作为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dequeue()                                 头部删除</span><br><span class="line">front()                                   头部查询</span><br><span class="line">enqueue(e)                                尾部插入 </span><br><span class="line">rear()                                    尾部查询</span><br></pre></td></tr></table></figure></p><p>其模板类可以直接基于向量或列表派生。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Queue</span>:</span><span class="keyword">public</span> List&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span>:   <span class="comment">//size()和empty()可以直接继承</span></span><br><span class="line">    <span class="function">T <span class="title">dequeue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> remove(first());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T &amp; <span class="title">front</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first()-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据结构之列表</title>
      <link href="/2018/04/05/data_structure/dataStructureList/"/>
      <url>/2018/04/05/data_structure/dataStructureList/</url>
      <content type="html"><![CDATA[<h1 id="列表基础"><a href="#列表基础" class="headerlink" title="列表基础"></a>列表基础</h1><p>对于数据结构的操作可以分为两类：</p><ul><li>静态：仅读取get      $O(1)$、search    $O(logn)$操作</li><li>动态：需写入insert  $O(n)$、remove  $O(n)$操作<br>列表采用动态存储策略：</li><li>列表元素称为节点（node）</li><li>各节点通过指针或引用彼此联接，形成一个线性序列</li><li>相邻节点彼此互称为前驱（predecessor）或后继（successor）</li></ul><h2 id="向量与列表的区别"><a href="#向量与列表的区别" class="headerlink" title="向量与列表的区别"></a>向量与列表的区别</h2><ul><li><p>向量：可根据元素的秩直接确定其物理地址。元素V[i]的物理地址为<br>$V + i × s$<br>(s为单个单元占用的空间量)。寻秩访问效率较高。</p></li><li><p>列表：也可以进行循秩访问，但效率较低。应改为循位置访问（call-by-position）的方式，利用节点之间的互相引用，找到指定节点。</p></li></ul><h2 id="列表节点ADT接口"><a href="#列表节点ADT接口" class="headerlink" title="列表节点ADT接口"></a>列表节点ADT接口</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pred()                                  当前节点前驱节点位置</span><br><span class="line">succ()                                  当前节点后继节点的位置</span><br><span class="line">data()                                  当前节点所存的数据对象</span><br><span class="line">insertAsPred(e)                         插入前驱节点，存入被引用对象e，返回新节点位置</span><br><span class="line">insertAsSuccess(e)                      插入后继节点，存入被引用对象e，返回新节点位置</span><br></pre></td></tr></table></figure><p>定义ListNode模板类：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Posi(T) ListNode<span class="meta-string">&lt;T&gt;*</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;typname T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    T data;</span><br><span class="line">    Posi(T) pred;</span><br><span class="line">    Posi(T) succ;</span><br><span class="line">    ListNode() &#123;&#125;;</span><br><span class="line">    ListNode(T e, Posi(T) p = <span class="literal">NULL</span>, Posi(T) s = <span class="literal">NULL</span>)</span><br><span class="line">        : data(e), pred(p), succ(s) &#123;&#125;</span><br><span class="line">    Posi(T) insertAsPred(T <span class="keyword">const</span>&amp; e);</span><br><span class="line">    Posi(T) insertAsSucc(T <span class="keyword">const</span>&amp; e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接口操作：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">size()</span><br><span class="line">first(), last()                               返回首、末节点的位置</span><br><span class="line">insertAsFirst(e), insertAsLast(e)             将e当做末节点插入</span><br><span class="line">insertBefore(p, e), insertAfter(p, e)         将e当做节点p的直接前驱、后继插入</span><br><span class="line">remove(r)</span><br><span class="line">disordered()</span><br><span class="line">sort()</span><br><span class="line">find(e)                                        查找目标元素e</span><br><span class="line">search(e)                                      查找目标元素e，返回不大于e且秩最大的元素</span><br><span class="line">deduplicate()                                  删除重复元素</span><br><span class="line">uniquify()                                     删除重复元素</span><br><span class="line">traverse()                                     遍历向量并统一处理</span><br></pre></td></tr></table></figure></p><p>在List结构中，为了便于理解，定义：</p><table><thead><tr><th style="text-align:center">-1</th><th style="text-align:center">0</th><th style="text-align:center">……</th><th style="text-align:center">n-1</th><th style="text-align:center">n</th><th></th></tr></thead><tbody><tr><td style="text-align:center">header（头哨兵）</td><td style="text-align:center">first（首节点）</td><td style="text-align:center">……</td><td style="text-align:center">last(末节点)</td><td style="text-align:center">trailer(尾哨兵)</td><td></td></tr><tr><td style="text-align:center">固定存在</td><td style="text-align:center">可能不存在</td><td style="text-align:center">……</td><td style="text-align:center">可能不存在</td><td style="text-align:center">固定存在</td><td></td></tr><tr><td style="text-align:center">对外部invisible</td><td style="text-align:center">对外部visible</td><td style="text-align:center">对外部visible</td><td style="text-align:center">对外部visible</td><td style="text-align:center">对外部invisible</td></tr></tbody></table><h1 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h1><h2 id="寻秩访问"><a href="#寻秩访问" class="headerlink" title="寻秩访问"></a>寻秩访问</h2><p>无序列表可以进行循秩访问，可通过重载下标操作符进行，其时间复杂度为$O(r)$，效率低下。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T List&lt;T&gt;::<span class="keyword">operator</span>[](Rank r) <span class="keyword">const</span>&#123;</span><br><span class="line">    Posi(T) p = first();</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">0</span> &lt; r--)</span><br><span class="line">        p = p-&gt;succ;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="节点查找"><a href="#节点查找" class="headerlink" title="节点查找"></a>节点查找</h2><p>当有多个重复元素的时候，会首先停止在最靠后的位置，在最坏情况下时间复杂度为$O(n)$<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Posi(T) List&lt;T&gt;::find(T <span class="keyword">const</span> &amp; e, <span class="keyword">int</span>  n, Posi(T) p) <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">0</span> &lt; n--)&#123;                  <span class="comment">//命中或越界才返回</span></span><br><span class="line">        <span class="keyword">if</span>(e == (p = p-&gt;pred)-&gt;data) <span class="comment">//取出当前节点的数据域并与e比对</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">find(e, n, p)         <span class="comment">//在p的n个前驱中查找指定元素e</span></span><br><span class="line">find(e, p, n)         <span class="comment">//在p的n个后继中查找指定元素e</span></span><br></pre></td></tr></table></figure></p><h2 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h2><p>当this指向的是首节点，这样操作会使插入的节点的前驱变为头节点。具体步骤为创建新节点时指定新节点的前驱和后继，即将当前节点前驱的后继指定为新节点，将当前节点后继的前驱指定为新节点。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Posi(T) List&lt;T&gt;::insertBefore(Posi(T) p, T <span class="keyword">const</span>&amp; e)&#123;</span><br><span class="line">    _size++;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;insertAsPred(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Posi(T) ListNode&lt;T&gt;::insertAsPred(T <span class="keyword">const</span>&amp; e)&#123;</span><br><span class="line">    Posi(T) x = <span class="keyword">new</span> ListNode(e, pred, <span class="keyword">this</span>);  <span class="comment">//首先创建一个ListNode，耗时</span></span><br><span class="line">    pred -&gt;succ = x;                          <span class="comment">//创建连接</span></span><br><span class="line">    pred = x;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>insertAsLast(e)   等价于  insertBefore(trailer, e)<br>基于复制的构造：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> List&lt;T&gt;::copyNodes(Posi(T) p, <span class="keyword">int</span> n)&#123;</span><br><span class="line">    init();                                 <span class="comment">//创建空的列表</span></span><br><span class="line">    <span class="keyword">while</span>(n--)&#123; </span><br><span class="line">        insertAsLast(p-&gt;data);              <span class="comment">//将从p开始的n项依次作为末节点插入</span></span><br><span class="line">        p = p-&gt;succ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h2><p>在列表中删除指定元素时间复杂度为$O(1)$。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T List&lt;T&gt;::remove(Posi(T) p)&#123;</span><br><span class="line">    T e = p-&gt;data;              <span class="comment">//备份删除节点的数据</span></span><br><span class="line">    p-&gt;pred-&gt;succ = p-&gt;succ;    <span class="comment">//待删除节点的后继 变为 待删除节点的前驱的后继</span></span><br><span class="line">    p-&gt;succ-&gt;pred = p-&gt;pred;    <span class="comment">//待删除节点的前驱 变为 待删除节点的后继的前驱</span></span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    _size--;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>销毁一个已有的列表(析构)，时间复杂度为$O(n)$，相当于反复执行remove操作。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line">List&lt;T&gt;::~List()&#123;</span><br><span class="line">    clear();                   <span class="comment">//删除所有可见节点</span></span><br><span class="line">    <span class="keyword">delete</span> header;</span><br><span class="line">    <span class="keyword">delete</span> trailer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">int</span> List&lt;T&gt;::clear()&#123;</span><br><span class="line">    <span class="keyword">int</span> oldSize = _size;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">0</span> &lt; _size)&#123;</span><br><span class="line">        remove(header-&gt;succ)    <span class="comment">//反复删除首节点，直到列表为空</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="列表唯一化"><a href="#列表唯一化" class="headerlink" title="列表唯一化"></a>列表唯一化</h2><p>将列表分为三部分：</p><ul><li>已经没有重复元素的前面部分</li><li>当前查找的元素e</li><li>还未进行查找的后面部分<br>使用find操作从首节点遍历至末节点，在当前节点的前驱中查找与当前节点数据相同的节点。其时间复杂度为$O(n^{2})$。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T &gt;</span><br><span class="line"><span class="keyword">int</span> List&lt;T&gt;::deduplicate()&#123;</span><br><span class="line">    <span class="keyword">if</span>(_size &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> oldSize = _size;</span><br><span class="line">    Posi(T) p = first();                    <span class="comment">//初始化</span></span><br><span class="line">    Rank r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(trailer != (p=p-&gt;succ))&#123;          <span class="comment">//遍历从首节点直至末节点</span></span><br><span class="line">        Posi(T) q = find(p-&gt;data, r, p);    <span class="comment">//在p的r个前驱中查找相同的元素，r即整个前缀的长度也就是第一部分的长度</span></span><br><span class="line">        q ? remove(q) : r++;                <span class="comment">//如果有就删除该元素，没有就r++</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldSize - _size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h1><h2 id="列表唯一化-1"><a href="#列表唯一化-1" class="headerlink" title="列表唯一化"></a>列表唯一化</h2><p>有序列表的唯一化比无序列表的耗时少，因为其有序，则只需要检测相邻节点的数据是否相同，其时间复杂度为$O(n)$。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;typname T&gt; </span><br><span class="line"><span class="keyword">int</span> List&lt;T&gt;::uniquify()&#123;</span><br><span class="line">    <span class="keyword">if</span>(_size &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> oldSize = _size;</span><br><span class="line">    ListNodePosi(T) p = first();</span><br><span class="line">    ListNodePosi(T) q;</span><br><span class="line">    <span class="keyword">while</span>(trailer != (q=p-&gt;succ))&#123;       <span class="comment">//从首节点遍历到尾节点</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data != q-&gt;data)           <span class="comment">//若相邻节点互异则转入下一个区段</span></span><br><span class="line">            p = q;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            remove(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldSize - _size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="列表查找"><a href="#列表查找" class="headerlink" title="列表查找"></a>列表查找</h2><p>其平均时间复杂度为$O(n)$<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;  &#123;</span><br><span class="line">Posi(T) List&lt;T&gt;::search(T <span class="keyword">const</span> &amp; e, <span class="keyword">int</span> n, Posi(T) p) <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">0</span> &lt;= n--)&#123;                     <span class="comment">//对p的最近n个前驱，从右向左逐个比较</span></span><br><span class="line">        <span class="keyword">if</span>(((p = p-&gt;pred)-&gt;data) &lt;= e)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="列表排序"><a href="#列表排序" class="headerlink" title="列表排序"></a>列表排序</h1><h2 id="选择排序法（selection-sort）"><a href="#选择排序法（selection-sort）" class="headerlink" title="选择排序法（selection sort）"></a>选择排序法（selection sort）</h2><p>类似于冒泡排序法，将序列分成两部分</p><ul><li>前半部分是无序子序列，但最大值不超多后半部分的最小值</li><li>后半部分是有序子序列</li></ul><p>改进方法：</p><ul><li>找到前部分的最大值</li><li>将最大值移到后半部分的最前端</li></ul><p>对列表中起始于位置P的连续n个元素做选择排序：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;typname T&gt;    &#123;&#125;</span><br><span class="line"><span class="keyword">void</span> List&lt;T&gt;::selectionSort(Posi(T) p, <span class="keyword">int</span> n)&#123;</span><br><span class="line">    Posi(T) head = p-&gt;pred;         <span class="comment">//头哨兵初始化</span></span><br><span class="line">    Posi(T) tail = p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;     <span class="comment">//尾哨兵初始化</span></span><br><span class="line">        tail = tail-&gt;succ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span> &lt; n)&#123;</span><br><span class="line">        insertBefore(tail, remove(selectMax(head-&gt;succ, n)));  <span class="comment">//remove返回节点数据</span></span><br><span class="line">        tail = tail-&gt;pred;</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Posi(T) List&lt;T&gt;:selectMax(Posi(T), <span class="keyword">int</span> n)&#123;</span><br><span class="line">    Posi(T) max = p;</span><br><span class="line">    <span class="keyword">for</span>(Posi(T) cur = p; <span class="number">1</span> &lt; n; n--)&#123;    <span class="comment">//遍历后续节点</span></span><br><span class="line">        <span class="keyword">if</span>(!lt((cur = cur-&gt;succ)-&gt;data, max-&gt;data)) </span><br><span class="line">            max = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在选择最大元素时，!lt（not less than）意思是前者比后者不小，也就是&gt;=，如果改为严格&gt;算法会不稳定，遇到相同的max元素的时候无法将该元素移动到末尾。<br>insert和remove都需要动态分配空间，即new一个ListNode和delete，消耗时间，因此需要优化。该算法时间复杂度为$\theta \left ( n^{2} \right )$。</p><h2 id="插入排序法（insert-sort"><a href="#插入排序法（insert-sort" class="headerlink" title="插入排序法（insert sort)"></a>插入排序法（insert sort)</h2><p>将列表看成两个部分：</p><ul><li>前部分sorted</li><li>后部分unsorted</li></ul><p>算法从左到右进行插值，仅使用$O(1)$的辅助空间，属于就地算法(in-place)，时间复杂度为$O(n^{2})$。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> List&lt;T&gt;::insertionSort(Posi(T) p, <span class="keyword">int</span> n)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; n; r++)&#123;</span><br><span class="line">        insertAfter(search(p-&gt;data, r, p))   <span class="comment">//search会返回在p的前面r个元素中不大于p对应的数据的最大值的位置，之后insert在那个位置之后</span></span><br><span class="line">        p = p-&gt;succ;                         <span class="comment">//p转向直接后继</span></span><br><span class="line">        remove(p-&gt;pred);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="逆序对（inversion）"><a href="#逆序对（inversion）" class="headerlink" title="逆序对（inversion）"></a>逆序对（inversion）</h3><p>在插值排序的过程中，将当前元素插入到前缀中的合适位置时，当前元素和前缀中的后缀部分会构成i对逆序对，该值就是search所需的次数，所以总体的插值损耗时间为$O(I + n)$。此算法具有输入敏感(input-sensitive)特性。</p>]]></content>
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据结构之向量</title>
      <link href="/2018/04/04/data_structure/dataStructureVector/"/>
      <url>/2018/04/04/data_structure/dataStructureVector/</url>
      <content type="html"><![CDATA[<p>&emsp;&emsp;根据清华大学邓俊辉老师的课程整理记录。使用C++编程。</p><h2 id="向量基础"><a href="#向量基础" class="headerlink" title="向量基础"></a>向量基础</h2><h3 id="向量概念"><a href="#向量概念" class="headerlink" title="向量概念"></a>向量概念</h3><p>&emsp;&emsp;向量是数组的抽象与泛化，由一组元素按照现行次序封装而成。</p><ul><li>各元素与[0,n)内的秩一一对应</li><li>元素类型不限于基本类型 </li><li>操作、管理、维护更简化、统一、安全</li><li>可更为敏捷参与复杂数据结构的控制与实现</li></ul><p>&emsp;&emsp;向量ADT接口：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">size()</span><br><span class="line">get()</span><br><span class="line">put(r,e)</span><br><span class="line">insert(r,e)</span><br><span class="line">remove(r)</span><br><span class="line">disordered()</span><br><span class="line">sort()</span><br><span class="line">find(e)                 查找目标元素e</span><br><span class="line">search(e)               查找目标元素e，返回不大于e且秩最大的元素</span><br><span class="line">deduplicate()           删除重复元素</span><br><span class="line">uniquify()              删除重复元素</span><br><span class="line">traverse()              遍历向量并统一处理</span><br></pre></td></tr></table></figure><h2 id="无序向量"><a href="#无序向量" class="headerlink" title="无序向量"></a>无序向量</h2><h3 id="向量的动态扩容"><a href="#向量的动态扩容" class="headerlink" title="向量的动态扩容"></a>向量的动态扩容</h3><p>&emsp;&emsp;copyfrom接口在copy向量时申请的容量是copy内容的两倍，因此可根据这种方式来进行扩容，其累计增容时间为$O(n^{2})$,分摊增益时间为$O(n)$</p><p>&emsp;&emsp;扩容代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> Vector&lt;T&gt;::expand()&#123;</span><br><span class="line">    <span class="keyword">if</span>(_size&lt;_capacity) <span class="keyword">return</span>;</span><br><span class="line">    _capacity = max(_capacity,DEFAULT_CAPACITY);</span><br><span class="line">    T* oldElem = _elem;</span><br><span class="line">    _elem = <span class="keyword">new</span> T[_capacity &lt;&lt;=<span class="number">1</span>]; <span class="comment">//容量加倍,移位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _size; i++)</span><br><span class="line">        _elem[i] = oldElem[i];</span><br><span class="line">    <span class="keyword">delete</span> [] oldElem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="向量插入"><a href="#向量插入" class="headerlink" title="向量插入"></a>向量插入</h3><p>&emsp;&emsp;将向量的后继整体向后移位，空出一个位置后将其插入<br>&emsp;&emsp;算法实现：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Rank Vector&lt;T&gt;::insert(Raank r, T <span class="keyword">const</span> &amp; e)&#123;</span><br><span class="line">    expand()  <span class="comment">//如有必要先考虑扩容</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = _size; i &gt; r; i--)  <span class="comment">//从后往前移位，若从前往后移可能出现覆盖的现象</span></span><br><span class="line">        _elem[i] = _elem[i<span class="number">-1</span>];</span><br><span class="line">    _elem[r] = e;</span><br><span class="line">    _size++;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="区间删除"><a href="#区间删除" class="headerlink" title="区间删除"></a>区间删除</h3><p>&emsp;&emsp;将后继左移填补删除部分，时间复杂度为$O(n)$。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> Vector&lt;T&gt;::remove(Rank lo,Rank hi)&#123;</span><br><span class="line">    <span class="keyword">if</span>(lo==hi) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(hi &lt; _size) </span><br><span class="line">        _elem[lo++] = _elem[hi++];</span><br><span class="line">    _size = lo;</span><br><span class="line">    shrink();  <span class="comment">//更新规模</span></span><br><span class="line">    <span class="keyword">return</span> hi - lo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;单元素删除可看做区间删除的特例$[r]=[r,r+1)$，时间复杂度为$O(n)$。若在进行区间操作时，叠加单元素操作进行区间操作会导致$O(n^{2})$的时间复杂度。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">T Vector&lt;T&gt;::remove(Rank r)&#123;</span><br><span class="line">    T e = _elem[r];  <span class="comment">//备份被删除的元素</span></span><br><span class="line">    remove(r, r+<span class="number">1</span>); <span class="comment">//调用区间删除算法</span></span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h3><p>&emsp;&emsp;查找操作都是从后向前查找匹配的元素，在最坏的情况下，其时间复杂度为$O(n)$，但在n给定的情况下其时间复杂度为$O(1)$。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Rank Vector&lt;T&gt;::find(T <span class="keyword">const</span> &amp; e, Rank lo, Rank hi)&#123;</span><br><span class="line">    <span class="keyword">while</span>((lo &lt; hi--) &amp;&amp; (e != _elem[hi]));</span><br><span class="line">    <span class="keyword">return</span> hi; <span class="comment">//hi&lt;lo时查找失败，否则hi为命中元素的秩</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="去重操作"><a href="#去重操作" class="headerlink" title="去重操作"></a>去重操作</h3><p>&emsp;&emsp;无序向量的唯一化需要用到去重操作。<br>&emsp;&emsp;while循环中find操作查找当前元素的前驱，remove对后继操作，则累计时间复杂度为$O(n^{2})$。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> Vector&lt;T&gt;::deduplicate()&#123;</span><br><span class="line">    <span class="keyword">int</span> oldSize = _size;</span><br><span class="line">    Rank i = <span class="number">1</span>;        <span class="comment">//初始值从_elem[1]开始</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; _size)&#123;  <span class="comment">//从前向后查询是否有与_elem[i]相同的元素，若有就删除</span></span><br><span class="line">        (find(_elem[i], <span class="number">0</span>, i)) &lt; <span class="number">0</span> ? i++ : remove(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldSize - _size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="遍历操作"><a href="#遍历操作" class="headerlink" title="遍历操作"></a>遍历操作</h3><p>&emsp;&emsp;统一对各元素实施visit操作<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Increase</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T &amp; e)</span></span>&#123;e++;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increase</span><span class="params">(Vector&lt;T&gt; &amp; V)</span></span>&#123;</span><br><span class="line">    V.traverse(Increase&lt;T&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="有序向量"><a href="#有序向量" class="headerlink" title="有序向量"></a>有序向量</h2><h3 id="唯一化"><a href="#唯一化" class="headerlink" title="唯一化"></a>唯一化</h3><p>&emsp;&emsp;将无序向量有序化后便于操作，如无序向量的去重操作对应有序向量的唯一化操作，前者的时间复杂度为$O(n^{2})$。</p><ul><li>有序序列，任意一对相邻元素顺序</li><li>无序序列，总有一对相邻元素逆序</li><li>相邻逆序对的数量可用于度量向量逆序的程度</li></ul><p>&emsp;&emsp;检查各相邻元素是顺序或者逆序：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> Vector&lt;T&gt;::disordered() condt&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt; _size; i++)</span><br><span class="line">        n += (_elem[i<span class="number">-1</span>] &gt; _elem[i]);</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;将无序向量的去重操作推广到有序向量更为高效。</p><ul><li>有序向量去重法一<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> Vector&lt;T&gt;::uniquify()&#123;</span><br><span class="line">    <span class="keyword">int</span> oldSize = _size;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; _size<span class="number">-1</span>)&#123;</span><br><span class="line">        (_elem[i] == _elem[i+<span class="number">1</span>]) ? remove(i+<span class="number">1</span>):i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldSize - _size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>&emsp;&emsp;此方法的时间复杂度和deduplicate相同，都为$O(n^{2})$。改进算法，将重复的元素批量删除。</p><ul><li>有序向量去重法二<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> Vector&lt;T&gt;::uniquify()&#123;</span><br><span class="line">    Rank i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(++j &lt; _size)&#123;             <span class="comment">//逐一扫描，直至末尾元素</span></span><br><span class="line">        <span class="keyword">if</span>(_elem[i] != _elem[j])    <span class="comment">//找到两个不同元素后将第i+1元素用j元素覆盖</span></span><br><span class="line">            _elem[++i] = _elem[j];</span><br><span class="line">    &#125;</span><br><span class="line">    _size = ++i;</span><br><span class="line">    shrink();     <span class="comment">//如果有必要截除尾部多余元素</span></span><br><span class="line">    <span class="keyword">return</span> j-i;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>&emsp;&emsp;此方法的时间复杂度仅为$O(n)$</p><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>&emsp;&emsp;随机选择使用二分查找还是Fibonacci查找。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Rank Vector&lt;T&gt;::search(T <span class="keyword">const</span> &amp; e, Rank lo,Rank hi) <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (rand() % <span class="number">2</span>) ? binSearch(_elem, e, lo, hi) : fibSearch(_elem, e, lo,hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;补充：Fibonacci数递归公式为$fib(n)=fib(n-1)+fib(n-2)$，若直接实现公式，此方法的时间复杂度为$O(2^{n})$。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">2</span>&gt;n) ? n : fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;优化方法为：进行动态规划，可以将时间复杂度降为$O(n)$。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> g = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">0</span> &lt; n--)&#123;</span><br><span class="line">        g = g + f;</span><br><span class="line">        f = g - f;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;查找的语义约定：</p><ul><li>若查找元素小于向量最小元素，则返回lo-1即左哨兵</li><li>若查找元素大于向量最大元素，则返回hi-1即右侧哨兵左邻</li></ul><ul><li>A版本算法<br>&emsp;&emsp;减而治之，以任意元素 x = S[mi]为界，将待查找区间分为三部分，将mi取做向量的中点，且不考虑重复元素。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Rank <span class="title">binSearch</span><span class="params">(T* A, T <span class="keyword">const</span> &amp; e, Rank lo, Rank hi)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(lo &lt; hi)&#123;</span><br><span class="line">        Rank mi = (lo + hi) &gt;&gt; <span class="number">1</span>;   <span class="comment">//取出lo和hi的中点，&gt;&gt;表示右移一位</span></span><br><span class="line">        <span class="keyword">if</span>(e &lt; A[mi])</span><br><span class="line">            hi = mi;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(A[mi] &lt; e)</span><br><span class="line">            lo = mi + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> mi;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;      <span class="comment">//查找失败，返回-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>&emsp;&emsp;此方法的时间复杂度为$1.5log(n)$。左右分支的比较次数不等，但递归深度相同，左侧的比较次数较少，右侧的比较次数较多，因此可以调整递归深度，将左侧拉深，右侧变浅，从而减少平均比较次数。因此改进算法，将中点设置为$fib(k-1)-1$。</p><p>&emsp;&emsp;Fib查找：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Rank <span class="title">fibSearch</span><span class="params">(T* A, T <span class="keyword">const</span> &amp; e, Rank lo, Rank hi)</span></span>&#123;</span><br><span class="line">    <span class="function">Fib <span class="title">fib</span><span class="params">(hi -lo)</span></span>;  <span class="comment">//创建Fib数列</span></span><br><span class="line">    <span class="keyword">while</span>(lo &lt; hi)&#123;</span><br><span class="line">        <span class="keyword">while</span>(hi - lo &lt; fib.get())   <span class="comment">//前向顺序查找，确定Fib(k)-1的轴</span></span><br><span class="line">            fib.prev()</span><br><span class="line">        Rank mi = lo + fib.get() <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(e &lt; A[mi]) </span><br><span class="line">            hi = mi;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(A[mi] &lt; e)</span><br><span class="line">            lo = mi + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> mi;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;设平均查找长度为$a(\lambda )\times log(n)$，在λ在[0,1)范围内，使得平均查找长度有最优值，可以列出:<br>&emsp;&emsp;$a\left (\lambda \right ) \times log\left (n \right ) = \lambda \times [1 + a\left (\lambda \right ) \times log\left (n \lambda \right )]+ \left (1 - \lambda \right )\times \left [ 2 + a\left (\lambda \right ) \times log\left (n \left (1 - \lambda \right ) \right ) \right ]$<br>&emsp;&emsp;整理后可得$\lambda = \varphi = 0.6180339…$时，$a\left ( \lambda  \right )= 1.44420…$达到最优值。</p><ul><li><p>B版本算法<br>&emsp;&emsp;分为两个区间，mi的前驱和后继判断次数都为1。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">static</span> Rank <span class="title">binSearch</span><span class="params">(T* A, T <span class="keyword">const</span> &amp; e, Rank lo, Rank hi)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span> &lt; hi -lo)&#123;      <span class="comment">//区间宽度为1时退出循环</span></span><br><span class="line">        Rank mi = (lo + hi) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        (e &lt; A[mi]) ? hi = mi : lo = mi;    <span class="comment">//区间划分为[lo, mi)、[mi, hi)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (e == A[lo] ? lo : <span class="number">-1</span>;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>C版本算法<br>&emsp;&emsp;为了实现语义规定，在B版本基础上改进，为最终版本。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;tempename T&gt; <span class="function"><span class="keyword">static</span> Rank <span class="title">binSearch</span><span class="params">(T* A, T <span class="keyword">const</span> &amp; e, Rank lo, Rank hi)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(lo &lt; hi)&#123;         <span class="comment">//区间宽度为0时退出循环</span></span><br><span class="line">        Rank mi = (lo + hi) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        (e &lt; A[mi]) ? hi = mi : lo = mi +<span class="number">1</span>;  <span class="comment">//区间划分为[lo, mi)、(mi, hi]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> --lo;  <span class="comment">//lo-1为不大于e的元素的最大秩 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>&emsp;&emsp;中点的选取可以动态选取，根据$\frac{mi-lo}{hi-lo}\approx \frac{e - A\left [ lo \right ]}{A\left [ hi \right ] - A\left [ lo \right ]}$进行插值查找 ，最终的平均查找次数为$log\left ( log\left ( n \right ) \right )$。<br>&emsp;&emsp;对比普通查找，插值查找的优势不明显，在查找宽度极大或操作成本极高的情况下优势 较为明显。且该方法易受到干扰，需引入乘法及除法的额外计算。</p><ul><li><p>最终可行方法<br>&emsp;&emsp;通过插值查找缩小查找范围，再进行二分查找。<br>&emsp;&emsp;查找方式选择：</p></li><li><p>大规模：插值查找</p></li><li>中规模：折半查找</li><li>小规模：顺序查找</li></ul><h2 id="无序向量有序化"><a href="#无序向量有序化" class="headerlink" title="无序向量有序化"></a>无序向量有序化</h2><p>&emsp;&emsp;向量元素有序排列时，计算效率会大大提升，如去重、查找等操作。</p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> Veector&lt;T&gt;::bubbleSort(Rank lo, Rank hi)&#123;</span><br><span class="line">        <span class="keyword">while</span>( !bubble(lo, hi--));     <span class="comment">//逐趟扫描交换，直至全序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">bool</span> Vector&lt;T&gt;::bubble(Rank lo, Rank hi)&#123;</span><br><span class="line">        <span class="keyword">bool</span> sorted = <span class="literal">true</span>;         <span class="comment">//整体有序标志</span></span><br><span class="line">        <span class="keyword">while</span> (++lo &lt; hi)&#123;           <span class="comment">//逐一检查相邻元素，若为逆序则交换</span></span><br><span class="line">               <span class="keyword">if</span>(_elem[lo<span class="number">-1</span>]&gt;_elem[lo])&#123;</span><br><span class="line">                     sorted = <span class="literal">false</span>;</span><br><span class="line">                     swap(_elem[lo<span class="number">-1</span>], _elem[lo]);</span><br><span class="line">               &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sorted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;相应的java代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataStructure</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> sorted = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] testlist;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        testlist = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">20</span>, <span class="number">15</span>, <span class="number">5</span>, <span class="number">16</span>, <span class="number">10</span>, <span class="number">22</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> hi = testlist.length;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!bubble(lo, hi--) &amp;&amp; hi &gt; <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">bubble</span><span class="params">(<span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(++lo &lt; hi)&#123;</span><br><span class="line">            <span class="keyword">if</span> (testlist[lo -<span class="number">1</span>] &gt; testlist[lo])&#123;</span><br><span class="line">                sorted = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">int</span> change = testlist[lo];</span><br><span class="line">                testlist[lo] = testlist[lo-<span class="number">1</span>];</span><br><span class="line">                testlist[lo-<span class="number">1</span>] = change;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;testlist.length;i++)</span><br><span class="line">            System.out.print(testlist[i] + <span class="string">"\t"</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">return</span> sorted;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;打印结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1    15    5    16    10    20    22    </span><br><span class="line">1    5    15    10    16    20    22    </span><br><span class="line">1    5    10    15    16    20    22    </span><br><span class="line">1    5    10    15    16    20    22    </span><br><span class="line">1    5    10    15    16    20    22    </span><br><span class="line">1    5    10    15    16    20    22    </span><br><span class="line">1    5    10    15    16    20    22</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;可以看出在第四次扫描的时候，所有的元素都已经就位，但算法仍然在进行扫描，因此可以根据此算法进行改进，将hi移动到已经就位的元素的开头。</p><h3 id="并归排序"><a href="#并归排序" class="headerlink" title="并归排序"></a>并归排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Vector&lt;T&gt;::mergeSort(Raank lo, Rank hi)&#123;</span><br><span class="line">    <span class="keyword">if</span>(hi - lo &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mi = (lo + hi) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    mergeSort(lo, mi);  <span class="comment">//前半段排序</span></span><br><span class="line">    mergeSort(mi, hi);  <span class="comment">//后半段排序</span></span><br><span class="line">    merge(lo, mi, hi);  <span class="comment">//归并</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;二路归并：将两个有序的序列合并成一个有序序列，S[lo, hi) = S[lo, mi)+S[mi,hi)。时间消耗为O(n)。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> Vector&lt;T&gt;::merge(Rank lo, Rank hi)&#123;</span><br><span class="line">    T* A = _elem + lo;  <span class="comment">//合并后的向量为A[0, hi -lo) = _elem[lo, hi)</span></span><br><span class="line">    <span class="keyword">int</span> lb = mi -lo;    <span class="comment">//前子向量B[0, lb) = _elem[lo, mi)，为复制的A前半部分的值</span></span><br><span class="line">    T* B = <span class="keyword">new</span> T[lb];</span><br><span class="line">    <span class="keyword">for</span>(Rank i = <span class="number">0</span>; i &lt;lb; b[i] = A[i++]);</span><br><span class="line">    <span class="keyword">int</span> lc = hi - mi;   <span class="comment">//后子向量C[0, lc) = _elem[mi, hi)，直接指向mi之后</span></span><br><span class="line">    T* C = _elem + mi;</span><br><span class="line">    <span class="keyword">for</span>(Rank i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>; (j &lt; lb)||(k &lt;lc);)&#123;</span><br><span class="line">        <span class="keyword">if</span>((j &lt; lb) &amp;&amp; (lc &lt;= k || (B[j] &lt;= C[k]))) <span class="comment">//短路求值，当k值越界</span></span><br><span class="line">            A[i++] = B[j++];</span><br><span class="line">        <span class="keyword">if</span>((k &lt; lc) &amp;&amp; (lb &lt;= j || (C[k] &lt; B[j])))</span><br><span class="line">            A[i++] = C[k++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> [] B;    <span class="comment">//释放临时空间B   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;判断时可以进行精简：不用考虑C提前耗尽的情况，如果C提前耗尽，将B粘贴到A的末尾。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(Rank i = <span class="number">0</span>, j = <span class="number">0</span>, k =<span class="number">0</span>; j &lt; lb;)&#123;</span><br><span class="line">    <span class="keyword">if</span>((k &lt; lc) &amp;&amp; (C[k] &lt; B[j]))</span><br><span class="line">        A[i++] = B[j++];</span><br><span class="line">    <span class="keyword">if</span>(lc &lt;= k || (B[j] &lt;= C[k]))</span><br><span class="line">        A[i++] = C[k++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;java实现：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">testlist = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">15</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">22</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] testlist)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = testlist.length / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[] B = <span class="keyword">new</span> <span class="keyword">int</span>[mid];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mid ;i++)&#123;</span><br><span class="line">            B[i] = testlist[i];</span><br><span class="line">            System.out.print(B[i] + <span class="string">"\t"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">int</span>[] C = <span class="keyword">new</span> <span class="keyword">int</span>[testlist.length - mid];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = mid; i &lt; testlist.length; i++) &#123;</span><br><span class="line">            C[i-mid] = testlist[i];</span><br><span class="line">            System.out.print(C[i-mid] + <span class="string">"\t"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>; j &lt; mid;)&#123;</span><br><span class="line">            <span class="keyword">if</span> (k &lt; C.length &amp;&amp; C[k] &lt; B[j])</span><br><span class="line">                testlist[i++] = C[k++];</span><br><span class="line">            <span class="keyword">if</span> (C.length &lt;= k || B[j] &lt;= C[k])</span><br><span class="line">                testlist[i++] = B[j++];</span><br><span class="line"><span class="comment">//            else</span></span><br><span class="line"><span class="comment">//                testlist[i++] = C[k++];</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; testlist.length; i++) &#123;</span><br><span class="line">            System.out.print(testlist[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;输出结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1    4    15            //B</span><br><span class="line">5    9    10    22    //C </span><br><span class="line">1    4    5    9    10    15    22     //testList</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
